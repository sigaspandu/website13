"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@firebase";
exports.ids = ["vendor-chunks/@firebase"];
exports.modules = {

/***/ "(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/app/dist/esm/index.esm2017.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: () => (/* reexport safe */ _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError),\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION),\n/* harmony export */   _DEFAULT_ENTRY_NAME: () => (/* binding */ DEFAULT_ENTRY_NAME),\n/* harmony export */   _addComponent: () => (/* binding */ _addComponent),\n/* harmony export */   _addOrOverwriteComponent: () => (/* binding */ _addOrOverwriteComponent),\n/* harmony export */   _apps: () => (/* binding */ _apps),\n/* harmony export */   _clearComponents: () => (/* binding */ _clearComponents),\n/* harmony export */   _components: () => (/* binding */ _components),\n/* harmony export */   _getProvider: () => (/* binding */ _getProvider),\n/* harmony export */   _isFirebaseApp: () => (/* binding */ _isFirebaseApp),\n/* harmony export */   _isFirebaseServerApp: () => (/* binding */ _isFirebaseServerApp),\n/* harmony export */   _registerComponent: () => (/* binding */ _registerComponent),\n/* harmony export */   _removeServiceInstance: () => (/* binding */ _removeServiceInstance),\n/* harmony export */   _serverApps: () => (/* binding */ _serverApps),\n/* harmony export */   deleteApp: () => (/* binding */ deleteApp),\n/* harmony export */   getApp: () => (/* binding */ getApp),\n/* harmony export */   getApps: () => (/* binding */ getApps),\n/* harmony export */   initializeApp: () => (/* binding */ initializeApp),\n/* harmony export */   initializeServerApp: () => (/* binding */ initializeServerApp),\n/* harmony export */   onLog: () => (/* binding */ onLog),\n/* harmony export */   registerVersion: () => (/* binding */ registerVersion),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(ssr)/./node_modules/idb/build/index.js\");\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class PlatformLoggerServiceImpl {\n    constructor(container){\n        this.container = container;\n    }\n    // In initial implementation, this will be called by installations on\n    // auth token refresh, and installations will send this string.\n    getPlatformInfoString() {\n        const providers = this.container.getProviders();\n        // Loop through providers and get library/version pairs from any that are\n        // version components.\n        return providers.map((provider)=>{\n            if (isVersionServiceProvider(provider)) {\n                const service = provider.getImmediate();\n                return `${service.library}/${service.version}`;\n            } else {\n                return null;\n            }\n        }).filter((logString)=>logString).join(\" \");\n    }\n}\n/**\r\n *\r\n * @param provider check if this provider provides a VersionService\r\n *\r\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\r\n * provides VersionService. The provider is not necessarily a 'app-version'\r\n * provider.\r\n */ function isVersionServiceProvider(provider) {\n    const component = provider.getComponent();\n    return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* ComponentType.VERSION */ ;\n}\nconst name$o = \"@firebase/app\";\nconst version$1 = \"0.10.2\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(\"@firebase/app\");\nconst name$n = \"@firebase/app-compat\";\nconst name$m = \"@firebase/analytics-compat\";\nconst name$l = \"@firebase/analytics\";\nconst name$k = \"@firebase/app-check-compat\";\nconst name$j = \"@firebase/app-check\";\nconst name$i = \"@firebase/auth\";\nconst name$h = \"@firebase/auth-compat\";\nconst name$g = \"@firebase/database\";\nconst name$f = \"@firebase/database-compat\";\nconst name$e = \"@firebase/functions\";\nconst name$d = \"@firebase/functions-compat\";\nconst name$c = \"@firebase/installations\";\nconst name$b = \"@firebase/installations-compat\";\nconst name$a = \"@firebase/messaging\";\nconst name$9 = \"@firebase/messaging-compat\";\nconst name$8 = \"@firebase/performance\";\nconst name$7 = \"@firebase/performance-compat\";\nconst name$6 = \"@firebase/remote-config\";\nconst name$5 = \"@firebase/remote-config-compat\";\nconst name$4 = \"@firebase/storage\";\nconst name$3 = \"@firebase/storage-compat\";\nconst name$2 = \"@firebase/firestore\";\nconst name$1 = \"@firebase/firestore-compat\";\nconst name = \"firebase\";\nconst version = \"10.11.1\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The default app name\r\n *\r\n * @internal\r\n */ const DEFAULT_ENTRY_NAME = \"[DEFAULT]\";\nconst PLATFORM_LOG_STRING = {\n    [name$o]: \"fire-core\",\n    [name$n]: \"fire-core-compat\",\n    [name$l]: \"fire-analytics\",\n    [name$m]: \"fire-analytics-compat\",\n    [name$j]: \"fire-app-check\",\n    [name$k]: \"fire-app-check-compat\",\n    [name$i]: \"fire-auth\",\n    [name$h]: \"fire-auth-compat\",\n    [name$g]: \"fire-rtdb\",\n    [name$f]: \"fire-rtdb-compat\",\n    [name$e]: \"fire-fn\",\n    [name$d]: \"fire-fn-compat\",\n    [name$c]: \"fire-iid\",\n    [name$b]: \"fire-iid-compat\",\n    [name$a]: \"fire-fcm\",\n    [name$9]: \"fire-fcm-compat\",\n    [name$8]: \"fire-perf\",\n    [name$7]: \"fire-perf-compat\",\n    [name$6]: \"fire-rc\",\n    [name$5]: \"fire-rc-compat\",\n    [name$4]: \"fire-gcs\",\n    [name$3]: \"fire-gcs-compat\",\n    [name$2]: \"fire-fst\",\n    [name$1]: \"fire-fst-compat\",\n    \"fire-js\": \"fire-js\",\n    [name]: \"fire-js-all\"\n};\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @internal\r\n */ const _apps = new Map();\n/**\r\n * @internal\r\n */ const _serverApps = new Map();\n/**\r\n * Registered components.\r\n *\r\n * @internal\r\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst _components = new Map();\n/**\r\n * @param component - the component being added to this app's container\r\n *\r\n * @internal\r\n */ function _addComponent(app, component) {\n    try {\n        app.container.addComponent(component);\n    } catch (e) {\n        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\n    }\n}\n/**\r\n *\r\n * @internal\r\n */ function _addOrOverwriteComponent(app, component) {\n    app.container.addOrOverwriteComponent(component);\n}\n/**\r\n *\r\n * @param component - the component to register\r\n * @returns whether or not the component is registered successfully\r\n *\r\n * @internal\r\n */ function _registerComponent(component) {\n    const componentName = component.name;\n    if (_components.has(componentName)) {\n        logger.debug(`There were multiple attempts to register component ${componentName}.`);\n        return false;\n    }\n    _components.set(componentName, component);\n    // add the component to existing app instances\n    for (const app of _apps.values()){\n        _addComponent(app, component);\n    }\n    for (const serverApp of _serverApps.values()){\n        _addComponent(serverApp, component);\n    }\n    return true;\n}\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n *\r\n * @returns the provider for the service with the matching name\r\n *\r\n * @internal\r\n */ function _getProvider(app, name) {\n    const heartbeatController = app.container.getProvider(\"heartbeat\").getImmediate({\n        optional: true\n    });\n    if (heartbeatController) {\n        void heartbeatController.triggerHeartbeat();\n    }\n    return app.container.getProvider(name);\n}\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\r\n *\r\n * @internal\r\n */ function _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {\n    _getProvider(app, name).clearInstance(instanceIdentifier);\n}\n/**\r\n *\r\n * @param obj - an object of type FirebaseApp or FirebaseOptions.\r\n *\r\n * @returns true if the provide object is of type FirebaseApp.\r\n *\r\n * @internal\r\n */ function _isFirebaseApp(obj) {\n    return obj.options !== undefined;\n}\n/**\r\n *\r\n * @param obj - an object of type FirebaseApp.\r\n *\r\n * @returns true if the provided object is of type FirebaseServerAppImpl.\r\n *\r\n * @internal\r\n */ function _isFirebaseServerApp(obj) {\n    return obj.settings !== undefined;\n}\n/**\r\n * Test only\r\n *\r\n * @internal\r\n */ function _clearComponents() {\n    _components.clear();\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const ERRORS = {\n    [\"no-app\" /* AppError.NO_APP */ ]: \"No Firebase App '{$appName}' has been created - \" + \"call initializeApp() first\",\n    [\"bad-app-name\" /* AppError.BAD_APP_NAME */ ]: \"Illegal App name: '{$appName}'\",\n    [\"duplicate-app\" /* AppError.DUPLICATE_APP */ ]: \"Firebase App named '{$appName}' already exists with different options or config\",\n    [\"app-deleted\" /* AppError.APP_DELETED */ ]: \"Firebase App named '{$appName}' already deleted\",\n    [\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */ ]: \"Firebase Server App has been deleted\",\n    [\"no-options\" /* AppError.NO_OPTIONS */ ]: \"Need to provide options, when not being deployed to hosting via source.\",\n    [\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */ ]: \"firebase.{$appName}() takes either no argument or a \" + \"Firebase App instance.\",\n    [\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */ ]: \"First argument to `onLog` must be null or a function.\",\n    [\"idb-open\" /* AppError.IDB_OPEN */ ]: \"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"idb-get\" /* AppError.IDB_GET */ ]: \"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"idb-set\" /* AppError.IDB_WRITE */ ]: \"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"idb-delete\" /* AppError.IDB_DELETE */ ]: \"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */ ]: \"FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.\",\n    [\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */ ]: \"FirebaseServerApp is not for use in browser environments.\"\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory(\"app\", \"Firebase\", ERRORS);\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class FirebaseAppImpl {\n    constructor(options, config, container){\n        this._isDeleted = false;\n        this._options = Object.assign({}, options);\n        this._config = Object.assign({}, config);\n        this._name = config.name;\n        this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;\n        this._container = container;\n        this.container.addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(\"app\", ()=>this, \"PUBLIC\" /* ComponentType.PUBLIC */ ));\n    }\n    get automaticDataCollectionEnabled() {\n        this.checkDestroyed();\n        return this._automaticDataCollectionEnabled;\n    }\n    set automaticDataCollectionEnabled(val) {\n        this.checkDestroyed();\n        this._automaticDataCollectionEnabled = val;\n    }\n    get name() {\n        this.checkDestroyed();\n        return this._name;\n    }\n    get options() {\n        this.checkDestroyed();\n        return this._options;\n    }\n    get config() {\n        this.checkDestroyed();\n        return this._config;\n    }\n    get container() {\n        return this._container;\n    }\n    get isDeleted() {\n        return this._isDeleted;\n    }\n    set isDeleted(val) {\n        this._isDeleted = val;\n    }\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */ checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"app-deleted\" /* AppError.APP_DELETED */ , {\n                appName: this._name\n            });\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class FirebaseServerAppImpl extends FirebaseAppImpl {\n    constructor(options, serverConfig, name, container){\n        // Build configuration parameters for the FirebaseAppImpl base class.\n        const automaticDataCollectionEnabled = serverConfig.automaticDataCollectionEnabled !== undefined ? serverConfig.automaticDataCollectionEnabled : false;\n        // Create the FirebaseAppSettings object for the FirebaseAppImp constructor.\n        const config = {\n            name,\n            automaticDataCollectionEnabled\n        };\n        if (options.apiKey !== undefined) {\n            // Construct the parent FirebaseAppImp object.\n            super(options, config, container);\n        } else {\n            const appImpl = options;\n            super(appImpl.options, config, container);\n        }\n        // Now construct the data for the FirebaseServerAppImpl.\n        this._serverConfig = Object.assign({\n            automaticDataCollectionEnabled\n        }, serverConfig);\n        this._finalizationRegistry = new FinalizationRegistry(()=>{\n            this.automaticCleanup();\n        });\n        this._refCount = 0;\n        this.incRefCount(this._serverConfig.releaseOnDeref);\n        // Do not retain a hard reference to the dref object, otherwise the FinalizationRegisry\n        // will never trigger.\n        this._serverConfig.releaseOnDeref = undefined;\n        serverConfig.releaseOnDeref = undefined;\n        registerVersion(name$o, version$1, \"serverapp\");\n    }\n    toJSON() {\n        return undefined;\n    }\n    get refCount() {\n        return this._refCount;\n    }\n    // Increment the reference count of this server app. If an object is provided, register it\n    // with the finalization registry.\n    incRefCount(obj) {\n        if (this.isDeleted) {\n            return;\n        }\n        this._refCount++;\n        if (obj !== undefined) {\n            this._finalizationRegistry.register(obj, this);\n        }\n    }\n    // Decrement the reference count.\n    decRefCount() {\n        if (this.isDeleted) {\n            return 0;\n        }\n        return --this._refCount;\n    }\n    // Invoked by the FinalizationRegistry callback to note that this app should go through its\n    // reference counts and delete itself if no reference count remain. The coordinating logic that\n    // handles this is in deleteApp(...).\n    automaticCleanup() {\n        void deleteApp(this);\n    }\n    get settings() {\n        this.checkDestroyed();\n        return this._serverConfig;\n    }\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */ checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */ );\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The current SDK version.\r\n *\r\n * @public\r\n */ const SDK_VERSION = version;\nfunction initializeApp(_options, rawConfig = {}) {\n    let options = _options;\n    if (typeof rawConfig !== \"object\") {\n        const name = rawConfig;\n        rawConfig = {\n            name\n        };\n    }\n    const config = Object.assign({\n        name: DEFAULT_ENTRY_NAME,\n        automaticDataCollectionEnabled: false\n    }, rawConfig);\n    const name = config.name;\n    if (typeof name !== \"string\" || !name) {\n        throw ERROR_FACTORY.create(\"bad-app-name\" /* AppError.BAD_APP_NAME */ , {\n            appName: String(name)\n        });\n    }\n    options || (options = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)());\n    if (!options) {\n        throw ERROR_FACTORY.create(\"no-options\" /* AppError.NO_OPTIONS */ );\n    }\n    const existingApp = _apps.get(name);\n    if (existingApp) {\n        // return the existing app if options and config deep equal the ones in the existing app.\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, existingApp.options) && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(config, existingApp.config)) {\n            return existingApp;\n        } else {\n            throw ERROR_FACTORY.create(\"duplicate-app\" /* AppError.DUPLICATE_APP */ , {\n                appName: name\n            });\n        }\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(name);\n    for (const component of _components.values()){\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseAppImpl(options, config, container);\n    _apps.set(name, newApp);\n    return newApp;\n}\nfunction initializeServerApp(_options, _serverAppConfig) {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isBrowser)()) {\n        // FirebaseServerApp isn't designed to be run in browsers.\n        throw ERROR_FACTORY.create(\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */ );\n    }\n    if (_serverAppConfig.automaticDataCollectionEnabled === undefined) {\n        _serverAppConfig.automaticDataCollectionEnabled = false;\n    }\n    let appOptions;\n    if (_isFirebaseApp(_options)) {\n        appOptions = _options.options;\n    } else {\n        appOptions = _options;\n    }\n    // Build an app name based on a hash of the configuration options.\n    const nameObj = Object.assign(Object.assign({}, _serverAppConfig), appOptions);\n    // However, Do not mangle the name based on releaseOnDeref, since it will vary between the\n    // construction of FirebaseServerApp instances. For example, if the object is the request headers.\n    if (nameObj.releaseOnDeref !== undefined) {\n        delete nameObj.releaseOnDeref;\n    }\n    const hashCode = (s)=>{\n        return [\n            ...s\n        ].reduce((hash, c)=>Math.imul(31, hash) + c.charCodeAt(0) | 0, 0);\n    };\n    if (_serverAppConfig.releaseOnDeref !== undefined) {\n        if (typeof FinalizationRegistry === \"undefined\") {\n            throw ERROR_FACTORY.create(\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */ , {});\n        }\n    }\n    const nameString = \"\" + hashCode(JSON.stringify(nameObj));\n    const existingApp = _serverApps.get(nameString);\n    if (existingApp) {\n        existingApp.incRefCount(_serverAppConfig.releaseOnDeref);\n        return existingApp;\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(nameString);\n    for (const component of _components.values()){\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseServerAppImpl(appOptions, _serverAppConfig, nameString, container);\n    _serverApps.set(nameString, newApp);\n    return newApp;\n}\n/**\r\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * When called with no arguments, the default app is returned. When an app name\r\n * is provided, the app corresponding to that name is returned.\r\n *\r\n * An exception is thrown if the app being retrieved has not yet been\r\n * initialized.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return the default app\r\n * const app = getApp();\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return a named app\r\n * const otherApp = getApp(\"otherApp\");\r\n * ```\r\n *\r\n * @param name - Optional name of the app to return. If no name is\r\n *   provided, the default is `\"[DEFAULT]\"`.\r\n *\r\n * @returns The app corresponding to the provided app name.\r\n *   If no app name is provided, the default app is returned.\r\n *\r\n * @public\r\n */ function getApp(name = DEFAULT_ENTRY_NAME) {\n    const app = _apps.get(name);\n    if (!app && name === DEFAULT_ENTRY_NAME && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)()) {\n        return initializeApp();\n    }\n    if (!app) {\n        throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */ , {\n            appName: name\n        });\n    }\n    return app;\n}\n/**\r\n * A (read-only) array of all initialized apps.\r\n * @public\r\n */ function getApps() {\n    return Array.from(_apps.values());\n}\n/**\r\n * Renders this app unusable and frees the resources of all associated\r\n * services.\r\n *\r\n * @example\r\n * ```javascript\r\n * deleteApp(app)\r\n *   .then(function() {\r\n *     console.log(\"App deleted successfully\");\r\n *   })\r\n *   .catch(function(error) {\r\n *     console.log(\"Error deleting app:\", error);\r\n *   });\r\n * ```\r\n *\r\n * @public\r\n */ async function deleteApp(app) {\n    let cleanupProviders = false;\n    const name = app.name;\n    if (_apps.has(name)) {\n        cleanupProviders = true;\n        _apps.delete(name);\n    } else if (_serverApps.has(name)) {\n        const firebaseServerApp = app;\n        if (firebaseServerApp.decRefCount() <= 0) {\n            _serverApps.delete(name);\n            cleanupProviders = true;\n        }\n    }\n    if (cleanupProviders) {\n        await Promise.all(app.container.getProviders().map((provider)=>provider.delete()));\n        app.isDeleted = true;\n    }\n}\n/**\r\n * Registers a library's name and version for platform logging purposes.\r\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\r\n * @param version - Current version of that library.\r\n * @param variant - Bundle variant, e.g., node, rn, etc.\r\n *\r\n * @public\r\n */ function registerVersion(libraryKeyOrName, version, variant) {\n    var _a;\n    // TODO: We can use this check to whitelist strings when/if we set up\n    // a good whitelist system.\n    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\n    if (variant) {\n        library += `-${variant}`;\n    }\n    const libraryMismatch = library.match(/\\s|\\//);\n    const versionMismatch = version.match(/\\s|\\//);\n    if (libraryMismatch || versionMismatch) {\n        const warning = [\n            `Unable to register library \"${library}\" with version \"${version}\":`\n        ];\n        if (libraryMismatch) {\n            warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        if (libraryMismatch && versionMismatch) {\n            warning.push(\"and\");\n        }\n        if (versionMismatch) {\n            warning.push(`version name \"${version}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        logger.warn(warning.join(\" \"));\n        return;\n    }\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(`${library}-version`, ()=>({\n            library,\n            version\n        }), \"VERSION\" /* ComponentType.VERSION */ ));\n}\n/**\r\n * Sets log handler for all Firebase SDKs.\r\n * @param logCallback - An optional custom log handler that executes user code whenever\r\n * the Firebase SDK makes a logging call.\r\n *\r\n * @public\r\n */ function onLog(logCallback, options) {\n    if (logCallback !== null && typeof logCallback !== \"function\") {\n        throw ERROR_FACTORY.create(\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */ );\n    }\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setUserLogHandler)(logCallback, options);\n}\n/**\r\n * Sets log level for all Firebase SDKs.\r\n *\r\n * All of the log types above the current log level are captured (i.e. if\r\n * you set the log level to `info`, errors are logged, but `debug` and\r\n * `verbose` logs are not).\r\n *\r\n * @public\r\n */ function setLogLevel(logLevel) {\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(logLevel);\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DB_NAME = \"firebase-heartbeat-database\";\nconst DB_VERSION = 1;\nconst STORE_NAME = \"firebase-heartbeat-store\";\nlet dbPromise = null;\nfunction getDbPromise() {\n    if (!dbPromise) {\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DB_NAME, DB_VERSION, {\n            upgrade: (db, oldVersion)=>{\n                // We don't use 'break' in this switch statement, the fall-through\n                // behavior is what we want, because if there are multiple versions between\n                // the old version and the current version, we want ALL the migrations\n                // that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch(oldVersion){\n                    case 0:\n                        try {\n                            db.createObjectStore(STORE_NAME);\n                        } catch (e) {\n                            // Safari/iOS browsers throw occasional exceptions on\n                            // db.createObjectStore() that may be a bug. Avoid blocking\n                            // the rest of the app functionality.\n                            console.warn(e);\n                        }\n                }\n            }\n        }).catch((e)=>{\n            throw ERROR_FACTORY.create(\"idb-open\" /* AppError.IDB_OPEN */ , {\n                originalErrorMessage: e.message\n            });\n        });\n    }\n    return dbPromise;\n}\nasync function readHeartbeatsFromIndexedDB(app) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME);\n        const result = await tx.objectStore(STORE_NAME).get(computeKey(app));\n        // We already have the value but tx.done can throw,\n        // so we need to await it here to catch errors\n        await tx.done;\n        return result;\n    } catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        } else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-get\" /* AppError.IDB_GET */ , {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME, \"readwrite\");\n        const objectStore = tx.objectStore(STORE_NAME);\n        await objectStore.put(heartbeatObject, computeKey(app));\n        await tx.done;\n    } catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        } else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-set\" /* AppError.IDB_WRITE */ , {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nfunction computeKey(app) {\n    return `${app.name}!${app.options.appId}`;\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const MAX_HEADER_BYTES = 1024;\n// 30 days\nconst STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;\nclass HeartbeatServiceImpl {\n    constructor(container){\n        this.container = container;\n        /**\r\n         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\r\n         * the header string.\r\n         * Stores one record per date. This will be consolidated into the standard\r\n         * format of one record per user agent string before being sent as a header.\r\n         * Populated from indexedDB when the controller is instantiated and should\r\n         * be kept in sync with indexedDB.\r\n         * Leave public for easier testing.\r\n         */ this._heartbeatsCache = null;\n        const app = this.container.getProvider(\"app\").getImmediate();\n        this._storage = new HeartbeatStorageImpl(app);\n        this._heartbeatsCachePromise = this._storage.read().then((result)=>{\n            this._heartbeatsCache = result;\n            return result;\n        });\n    }\n    /**\r\n     * Called to report a heartbeat. The function will generate\r\n     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\r\n     * to IndexedDB.\r\n     * Note that we only store one heartbeat per day. So if a heartbeat for today is\r\n     * already logged, subsequent calls to this function in the same day will be ignored.\r\n     */ async triggerHeartbeat() {\n        var _a, _b;\n        const platformLogger = this.container.getProvider(\"platform-logger\").getImmediate();\n        // This is the \"Firebase user agent\" string from the platform logger\n        // service, not the browser user agent.\n        const agent = platformLogger.getPlatformInfoString();\n        const date = getUTCDateString();\n        if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {\n            this._heartbeatsCache = await this._heartbeatsCachePromise;\n            // If we failed to construct a heartbeats cache, then return immediately.\n            if (((_b = this._heartbeatsCache) === null || _b === void 0 ? void 0 : _b.heartbeats) == null) {\n                return;\n            }\n        }\n        // Do not store a heartbeat if one is already stored for this day\n        // or if a header has already been sent today.\n        if (this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some((singleDateHeartbeat)=>singleDateHeartbeat.date === date)) {\n            return;\n        } else {\n            // There is no entry for this date. Create one.\n            this._heartbeatsCache.heartbeats.push({\n                date,\n                agent\n            });\n        }\n        // Remove entries older than 30 days.\n        this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((singleDateHeartbeat)=>{\n            const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\n            const now = Date.now();\n            return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\n        });\n        return this._storage.overwrite(this._heartbeatsCache);\n    }\n    /**\r\n     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\r\n     * It also clears all heartbeats from memory as well as in IndexedDB.\r\n     *\r\n     * NOTE: Consuming product SDKs should not send the header if this method\r\n     * returns an empty string.\r\n     */ async getHeartbeatsHeader() {\n        var _a;\n        if (this._heartbeatsCache === null) {\n            await this._heartbeatsCachePromise;\n        }\n        // If it's still null or the array is empty, there is no data to send.\n        if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0) {\n            return \"\";\n        }\n        const date = getUTCDateString();\n        // Extract as many heartbeats from the cache as will fit under the size limit.\n        const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\n        const headerString = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(JSON.stringify({\n            version: 2,\n            heartbeats: heartbeatsToSend\n        }));\n        // Store last sent date to prevent another being logged/sent for the same day.\n        this._heartbeatsCache.lastSentHeartbeatDate = date;\n        if (unsentEntries.length > 0) {\n            // Store any unsent entries if they exist.\n            this._heartbeatsCache.heartbeats = unsentEntries;\n            // This seems more likely than emptying the array (below) to lead to some odd state\n            // since the cache isn't empty and this will be called again on the next request,\n            // and is probably safest if we await it.\n            await this._storage.overwrite(this._heartbeatsCache);\n        } else {\n            this._heartbeatsCache.heartbeats = [];\n            // Do not wait for this, to reduce latency.\n            void this._storage.overwrite(this._heartbeatsCache);\n        }\n        return headerString;\n    }\n}\nfunction getUTCDateString() {\n    const today = new Date();\n    // Returns date format 'YYYY-MM-DD'\n    return today.toISOString().substring(0, 10);\n}\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\n    // Heartbeats grouped by user agent in the standard format to be sent in\n    // the header.\n    const heartbeatsToSend = [];\n    // Single date format heartbeats that are not sent.\n    let unsentEntries = heartbeatsCache.slice();\n    for (const singleDateHeartbeat of heartbeatsCache){\n        // Look for an existing entry with the same user agent.\n        const heartbeatEntry = heartbeatsToSend.find((hb)=>hb.agent === singleDateHeartbeat.agent);\n        if (!heartbeatEntry) {\n            // If no entry for this user agent exists, create one.\n            heartbeatsToSend.push({\n                agent: singleDateHeartbeat.agent,\n                dates: [\n                    singleDateHeartbeat.date\n                ]\n            });\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                // If the header would exceed max size, remove the added heartbeat\n                // entry and stop adding to the header.\n                heartbeatsToSend.pop();\n                break;\n            }\n        } else {\n            heartbeatEntry.dates.push(singleDateHeartbeat.date);\n            // If the header would exceed max size, remove the added date\n            // and stop adding to the header.\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                heartbeatEntry.dates.pop();\n                break;\n            }\n        }\n        // Pop unsent entry from queue. (Skipped if adding the entry exceeded\n        // quota and the loop breaks early.)\n        unsentEntries = unsentEntries.slice(1);\n    }\n    return {\n        heartbeatsToSend,\n        unsentEntries\n    };\n}\nclass HeartbeatStorageImpl {\n    constructor(app){\n        this.app = app;\n        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\n    }\n    async runIndexedDBEnvironmentCheck() {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\n            return false;\n        } else {\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)().then(()=>true).catch(()=>false);\n        }\n    }\n    /**\r\n     * Read all heartbeats.\r\n     */ async read() {\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return {\n                heartbeats: []\n            };\n        } else {\n            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\n            if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {\n                return idbHeartbeatObject;\n            } else {\n                return {\n                    heartbeats: []\n                };\n            }\n        }\n    }\n    // overwrite the storage with the provided heartbeats\n    async overwrite(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        } else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: heartbeatsObject.heartbeats\n            });\n        }\n    }\n    // add heartbeats\n    async add(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        } else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: [\n                    ...existingHeartbeatsObject.heartbeats,\n                    ...heartbeatsObject.heartbeats\n                ]\n            });\n        }\n    }\n}\n/**\r\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\r\n * in a platform logging header JSON object, stringified, and converted\r\n * to base 64.\r\n */ function countBytes(heartbeatsCache) {\n    // base64 has a restricted set of characters, all of which should be 1 byte.\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(// heartbeatsCache wrapper properties\n    JSON.stringify({\n        version: 2,\n        heartbeats: heartbeatsCache\n    })).length;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function registerCoreComponents(variant) {\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(\"platform-logger\", (container)=>new PlatformLoggerServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(\"heartbeat\", (container)=>new HeartbeatServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    // Register `app` package.\n    registerVersion(name$o, version$1, variant);\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n    registerVersion(name$o, version$1, \"esm2017\");\n    // Register platform SDK identifier (no version).\n    registerVersion(\"fire-js\", \"\");\n}\n/**\r\n * Firebase App\r\n *\r\n * @remarks This package coordinates the communication between the different Firebase components\r\n * @packageDocumentation\r\n */ registerCoreComponents(\"\");\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9FO0FBQ3VCO0FBQzZGO0FBQ3pJO0FBQ2xCO0FBRTdCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELE1BQU1lO0lBQ0ZDLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixJQUFJLENBQUNBLFNBQVMsR0FBR0E7SUFDckI7SUFDQSxxRUFBcUU7SUFDckUsK0RBQStEO0lBQy9EQyx3QkFBd0I7UUFDcEIsTUFBTUMsWUFBWSxJQUFJLENBQUNGLFNBQVMsQ0FBQ0csWUFBWTtRQUM3Qyx5RUFBeUU7UUFDekUsc0JBQXNCO1FBQ3RCLE9BQU9ELFVBQ0ZFLEdBQUcsQ0FBQ0MsQ0FBQUE7WUFDTCxJQUFJQyx5QkFBeUJELFdBQVc7Z0JBQ3BDLE1BQU1FLFVBQVVGLFNBQVNHLFlBQVk7Z0JBQ3JDLE9BQU8sQ0FBQyxFQUFFRCxRQUFRRSxPQUFPLENBQUMsQ0FBQyxFQUFFRixRQUFRRyxPQUFPLENBQUMsQ0FBQztZQUNsRCxPQUNLO2dCQUNELE9BQU87WUFDWDtRQUNKLEdBQ0tDLE1BQU0sQ0FBQ0MsQ0FBQUEsWUFBYUEsV0FDcEJDLElBQUksQ0FBQztJQUNkO0FBQ0o7QUFDQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU1AseUJBQXlCRCxRQUFRO0lBQ3RDLE1BQU1TLFlBQVlULFNBQVNVLFlBQVk7SUFDdkMsT0FBTyxDQUFDRCxjQUFjLFFBQVFBLGNBQWMsS0FBSyxJQUFJLEtBQUssSUFBSUEsVUFBVUUsSUFBSSxNQUFNLFVBQVUseUJBQXlCO0FBQ3pIO0FBRUEsTUFBTUMsU0FBUztBQUNmLE1BQU1DLFlBQVk7QUFFbEI7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTUMsU0FBUyxJQUFJbEMsb0RBQU1BLENBQUM7QUFFMUIsTUFBTW1DLFNBQVM7QUFFZixNQUFNQyxTQUFTO0FBRWYsTUFBTUMsU0FBUztBQUVmLE1BQU1DLFNBQVM7QUFFZixNQUFNQyxTQUFTO0FBRWYsTUFBTUMsU0FBUztBQUVmLE1BQU1DLFNBQVM7QUFFZixNQUFNQyxTQUFTO0FBRWYsTUFBTUMsU0FBUztBQUVmLE1BQU1DLFNBQVM7QUFFZixNQUFNQyxTQUFTO0FBRWYsTUFBTUMsU0FBUztBQUVmLE1BQU1DLFNBQVM7QUFFZixNQUFNQyxTQUFTO0FBRWYsTUFBTUMsU0FBUztBQUVmLE1BQU1DLFNBQVM7QUFFZixNQUFNQyxTQUFTO0FBRWYsTUFBTUMsU0FBUztBQUVmLE1BQU1DLFNBQVM7QUFFZixNQUFNQyxTQUFTO0FBRWYsTUFBTUMsU0FBUztBQUVmLE1BQU1DLFNBQVM7QUFFZixNQUFNQyxTQUFTO0FBRWYsTUFBTUMsT0FBTztBQUNiLE1BQU1qQyxVQUFVO0FBRWhCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEOzs7O0NBSUMsR0FDRCxNQUFNa0MscUJBQXFCO0FBQzNCLE1BQU1DLHNCQUFzQjtJQUN4QixDQUFDNUIsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0csT0FBTyxFQUFFO0lBQ1YsQ0FBQ0UsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0QsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0csT0FBTyxFQUFFO0lBQ1YsQ0FBQ0QsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0UsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0MsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0MsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0MsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0MsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0MsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0MsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0MsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0MsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0MsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0MsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0MsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0MsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0MsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0MsT0FBTyxFQUFFO0lBQ1YsQ0FBQ0MsT0FBTyxFQUFFO0lBQ1Ys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SUFDakQwRixnQkFBZ0IsV0FBVztBQUMvQjtBQUVBOzs7OztDQUtDLEdBQ0QwSCx1QkFBdUI7QUFFNFUsQ0FDblcseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2lnYXNwYW5kdS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanM/NzJjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIENvbXBvbmVudENvbnRhaW5lciB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgTG9nZ2VyLCBzZXRVc2VyTG9nSGFuZGxlciwgc2V0TG9nTGV2ZWwgYXMgc2V0TG9nTGV2ZWwkMSB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JGYWN0b3J5LCBnZXREZWZhdWx0QXBwQ29uZmlnLCBkZWVwRXF1YWwsIGlzQnJvd3NlciwgRmlyZWJhc2VFcnJvciwgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcsIGlzSW5kZXhlZERCQXZhaWxhYmxlLCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuZXhwb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IG9wZW5EQiB9IGZyb20gJ2lkYic7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB9XHJcbiAgICAvLyBJbiBpbml0aWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdpbGwgYmUgY2FsbGVkIGJ5IGluc3RhbGxhdGlvbnMgb25cclxuICAgIC8vIGF1dGggdG9rZW4gcmVmcmVzaCwgYW5kIGluc3RhbGxhdGlvbnMgd2lsbCBzZW5kIHRoaXMgc3RyaW5nLlxyXG4gICAgZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVycygpO1xyXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBwcm92aWRlcnMgYW5kIGdldCBsaWJyYXJ5L3ZlcnNpb24gcGFpcnMgZnJvbSBhbnkgdGhhdCBhcmVcclxuICAgICAgICAvLyB2ZXJzaW9uIGNvbXBvbmVudHMuXHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyc1xyXG4gICAgICAgICAgICAubWFwKHByb3ZpZGVyID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzZXJ2aWNlLmxpYnJhcnl9LyR7c2VydmljZS52ZXJzaW9ufWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5maWx0ZXIobG9nU3RyaW5nID0+IGxvZ1N0cmluZylcclxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHByb3ZpZGVyIGNoZWNrIGlmIHRoaXMgcHJvdmlkZXIgcHJvdmlkZXMgYSBWZXJzaW9uU2VydmljZVxyXG4gKlxyXG4gKiBOT1RFOiBVc2luZyBQcm92aWRlcjwnYXBwLXZlcnNpb24nPiBpcyBhIGhhY2sgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcHJvdmlkZXJcclxuICogcHJvdmlkZXMgVmVyc2lvblNlcnZpY2UuIFRoZSBwcm92aWRlciBpcyBub3QgbmVjZXNzYXJpbHkgYSAnYXBwLXZlcnNpb24nXHJcbiAqIHByb3ZpZGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyKHByb3ZpZGVyKSB7XHJcbiAgICBjb25zdCBjb21wb25lbnQgPSBwcm92aWRlci5nZXRDb21wb25lbnQoKTtcclxuICAgIHJldHVybiAoY29tcG9uZW50ID09PSBudWxsIHx8IGNvbXBvbmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50LnR5cGUpID09PSBcIlZFUlNJT05cIiAvKiBDb21wb25lbnRUeXBlLlZFUlNJT04gKi87XHJcbn1cblxuY29uc3QgbmFtZSRvID0gXCJAZmlyZWJhc2UvYXBwXCI7XG5jb25zdCB2ZXJzaW9uJDEgPSBcIjAuMTAuMlwiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvYXBwJyk7XG5cbmNvbnN0IG5hbWUkbiA9IFwiQGZpcmViYXNlL2FwcC1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRtID0gXCJAZmlyZWJhc2UvYW5hbHl0aWNzLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGwgPSBcIkBmaXJlYmFzZS9hbmFseXRpY3NcIjtcblxuY29uc3QgbmFtZSRrID0gXCJAZmlyZWJhc2UvYXBwLWNoZWNrLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGogPSBcIkBmaXJlYmFzZS9hcHAtY2hlY2tcIjtcblxuY29uc3QgbmFtZSRpID0gXCJAZmlyZWJhc2UvYXV0aFwiO1xuXG5jb25zdCBuYW1lJGggPSBcIkBmaXJlYmFzZS9hdXRoLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGcgPSBcIkBmaXJlYmFzZS9kYXRhYmFzZVwiO1xuXG5jb25zdCBuYW1lJGYgPSBcIkBmaXJlYmFzZS9kYXRhYmFzZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRlID0gXCJAZmlyZWJhc2UvZnVuY3Rpb25zXCI7XG5cbmNvbnN0IG5hbWUkZCA9IFwiQGZpcmViYXNlL2Z1bmN0aW9ucy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRjID0gXCJAZmlyZWJhc2UvaW5zdGFsbGF0aW9uc1wiO1xuXG5jb25zdCBuYW1lJGIgPSBcIkBmaXJlYmFzZS9pbnN0YWxsYXRpb25zLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGEgPSBcIkBmaXJlYmFzZS9tZXNzYWdpbmdcIjtcblxuY29uc3QgbmFtZSQ5ID0gXCJAZmlyZWJhc2UvbWVzc2FnaW5nLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDggPSBcIkBmaXJlYmFzZS9wZXJmb3JtYW5jZVwiO1xuXG5jb25zdCBuYW1lJDcgPSBcIkBmaXJlYmFzZS9wZXJmb3JtYW5jZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ2ID0gXCJAZmlyZWJhc2UvcmVtb3RlLWNvbmZpZ1wiO1xuXG5jb25zdCBuYW1lJDUgPSBcIkBmaXJlYmFzZS9yZW1vdGUtY29uZmlnLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDQgPSBcIkBmaXJlYmFzZS9zdG9yYWdlXCI7XG5cbmNvbnN0IG5hbWUkMyA9IFwiQGZpcmViYXNlL3N0b3JhZ2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkMiA9IFwiQGZpcmViYXNlL2ZpcmVzdG9yZVwiO1xuXG5jb25zdCBuYW1lJDEgPSBcIkBmaXJlYmFzZS9maXJlc3RvcmUtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUgPSBcImZpcmViYXNlXCI7XG5jb25zdCB2ZXJzaW9uID0gXCIxMC4xMS4xXCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBhcHAgbmFtZVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IERFRkFVTFRfRU5UUllfTkFNRSA9ICdbREVGQVVMVF0nO1xyXG5jb25zdCBQTEFURk9STV9MT0dfU1RSSU5HID0ge1xyXG4gICAgW25hbWUkb106ICdmaXJlLWNvcmUnLFxyXG4gICAgW25hbWUkbl06ICdmaXJlLWNvcmUtY29tcGF0JyxcclxuICAgIFtuYW1lJGxdOiAnZmlyZS1hbmFseXRpY3MnLFxyXG4gICAgW25hbWUkbV06ICdmaXJlLWFuYWx5dGljcy1jb21wYXQnLFxyXG4gICAgW25hbWUkal06ICdmaXJlLWFwcC1jaGVjaycsXHJcbiAgICBbbmFtZSRrXTogJ2ZpcmUtYXBwLWNoZWNrLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRpXTogJ2ZpcmUtYXV0aCcsXHJcbiAgICBbbmFtZSRoXTogJ2ZpcmUtYXV0aC1jb21wYXQnLFxyXG4gICAgW25hbWUkZ106ICdmaXJlLXJ0ZGInLFxyXG4gICAgW25hbWUkZl06ICdmaXJlLXJ0ZGItY29tcGF0JyxcclxuICAgIFtuYW1lJGVdOiAnZmlyZS1mbicsXHJcbiAgICBbbmFtZSRkXTogJ2ZpcmUtZm4tY29tcGF0JyxcclxuICAgIFtuYW1lJGNdOiAnZmlyZS1paWQnLFxyXG4gICAgW25hbWUkYl06ICdmaXJlLWlpZC1jb21wYXQnLFxyXG4gICAgW25hbWUkYV06ICdmaXJlLWZjbScsXHJcbiAgICBbbmFtZSQ5XTogJ2ZpcmUtZmNtLWNvbXBhdCcsXHJcbiAgICBbbmFtZSQ4XTogJ2ZpcmUtcGVyZicsXHJcbiAgICBbbmFtZSQ3XTogJ2ZpcmUtcGVyZi1jb21wYXQnLFxyXG4gICAgW25hbWUkNl06ICdmaXJlLXJjJyxcclxuICAgIFtuYW1lJDVdOiAnZmlyZS1yYy1jb21wYXQnLFxyXG4gICAgW25hbWUkNF06ICdmaXJlLWdjcycsXHJcbiAgICBbbmFtZSQzXTogJ2ZpcmUtZ2NzLWNvbXBhdCcsXHJcbiAgICBbbmFtZSQyXTogJ2ZpcmUtZnN0JyxcclxuICAgIFtuYW1lJDFdOiAnZmlyZS1mc3QtY29tcGF0JyxcclxuICAgICdmaXJlLWpzJzogJ2ZpcmUtanMnLFxyXG4gICAgW25hbWVdOiAnZmlyZS1qcy1hbGwnXHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IF9hcHBzID0gbmV3IE1hcCgpO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBfc2VydmVyQXBwcyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIFJlZ2lzdGVyZWQgY29tcG9uZW50cy5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5jb25zdCBfY29tcG9uZW50cyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIEBwYXJhbSBjb21wb25lbnQgLSB0aGUgY29tcG9uZW50IGJlaW5nIGFkZGVkIHRvIHRoaXMgYXBwJ3MgY29udGFpbmVyXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2FkZENvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhcHAuY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBsb2dnZXIuZGVidWcoYENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBmYWlsZWQgdG8gcmVnaXN0ZXIgd2l0aCBGaXJlYmFzZUFwcCAke2FwcC5uYW1lfWAsIGUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xyXG4gICAgYXBwLmNvbnRhaW5lci5hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChjb21wb25lbnQpO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gY29tcG9uZW50IC0gdGhlIGNvbXBvbmVudCB0byByZWdpc3RlclxyXG4gKiBAcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgY29tcG9uZW50IGlzIHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5XHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX3JlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5uYW1lO1xyXG4gICAgaWYgKF9jb21wb25lbnRzLmhhcyhjb21wb25lbnROYW1lKSkge1xyXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlcmUgd2VyZSBtdWx0aXBsZSBhdHRlbXB0cyB0byByZWdpc3RlciBjb21wb25lbnQgJHtjb21wb25lbnROYW1lfS5gKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBfY29tcG9uZW50cy5zZXQoY29tcG9uZW50TmFtZSwgY29tcG9uZW50KTtcclxuICAgIC8vIGFkZCB0aGUgY29tcG9uZW50IHRvIGV4aXN0aW5nIGFwcCBpbnN0YW5jZXNcclxuICAgIGZvciAoY29uc3QgYXBwIG9mIF9hcHBzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgX2FkZENvbXBvbmVudChhcHAsIGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHNlcnZlckFwcCBvZiBfc2VydmVyQXBwcy52YWx1ZXMoKSkge1xyXG4gICAgICAgIF9hZGRDb21wb25lbnQoc2VydmVyQXBwLCBjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZUFwcCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gbmFtZSAtIHNlcnZpY2UgbmFtZVxyXG4gKlxyXG4gKiBAcmV0dXJucyB0aGUgcHJvdmlkZXIgZm9yIHRoZSBzZXJ2aWNlIHdpdGggdGhlIG1hdGNoaW5nIG5hbWVcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKSB7XHJcbiAgICBjb25zdCBoZWFydGJlYXRDb250cm9sbGVyID0gYXBwLmNvbnRhaW5lclxyXG4gICAgICAgIC5nZXRQcm92aWRlcignaGVhcnRiZWF0JylcclxuICAgICAgICAuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XHJcbiAgICBpZiAoaGVhcnRiZWF0Q29udHJvbGxlcikge1xyXG4gICAgICAgIHZvaWQgaGVhcnRiZWF0Q29udHJvbGxlci50cmlnZ2VySGVhcnRiZWF0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwLmNvbnRhaW5lci5nZXRQcm92aWRlcihuYW1lKTtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGFwcCAtIEZpcmViYXNlQXBwIGluc3RhbmNlXHJcbiAqIEBwYXJhbSBuYW1lIC0gc2VydmljZSBuYW1lXHJcbiAqIEBwYXJhbSBpbnN0YW5jZUlkZW50aWZpZXIgLSBzZXJ2aWNlIGluc3RhbmNlIGlkZW50aWZpZXIgaW4gY2FzZSB0aGUgc2VydmljZSBzdXBwb3J0cyBtdWx0aXBsZSBpbnN0YW5jZXNcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfcmVtb3ZlU2VydmljZUluc3RhbmNlKGFwcCwgbmFtZSwgaW5zdGFuY2VJZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKS5jbGVhckluc3RhbmNlKGluc3RhbmNlSWRlbnRpZmllcik7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBvYmogLSBhbiBvYmplY3Qgb2YgdHlwZSBGaXJlYmFzZUFwcCBvciBGaXJlYmFzZU9wdGlvbnMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGUgb2JqZWN0IGlzIG9mIHR5cGUgRmlyZWJhc2VBcHAuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2lzRmlyZWJhc2VBcHAob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqLm9wdGlvbnMgIT09IHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIG9iaiAtIGFuIG9iamVjdCBvZiB0eXBlIEZpcmViYXNlQXBwLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBvYmplY3QgaXMgb2YgdHlwZSBGaXJlYmFzZVNlcnZlckFwcEltcGwuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2lzRmlyZWJhc2VTZXJ2ZXJBcHAob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqLnNldHRpbmdzICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuLyoqXHJcbiAqIFRlc3Qgb25seVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9jbGVhckNvbXBvbmVudHMoKSB7XHJcbiAgICBfY29tcG9uZW50cy5jbGVhcigpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IEVSUk9SUyA9IHtcclxuICAgIFtcIm5vLWFwcFwiIC8qIEFwcEVycm9yLk5PX0FQUCAqL106IFwiTm8gRmlyZWJhc2UgQXBwICd7JGFwcE5hbWV9JyBoYXMgYmVlbiBjcmVhdGVkIC0gXCIgK1xyXG4gICAgICAgICdjYWxsIGluaXRpYWxpemVBcHAoKSBmaXJzdCcsXHJcbiAgICBbXCJiYWQtYXBwLW5hbWVcIiAvKiBBcHBFcnJvci5CQURfQVBQX05BTUUgKi9dOiBcIklsbGVnYWwgQXBwIG5hbWU6ICd7JGFwcE5hbWV9J1wiLFxyXG4gICAgW1wiZHVwbGljYXRlLWFwcFwiIC8qIEFwcEVycm9yLkRVUExJQ0FURV9BUFAgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBleGlzdHMgd2l0aCBkaWZmZXJlbnQgb3B0aW9ucyBvciBjb25maWdcIixcclxuICAgIFtcImFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuQVBQX0RFTEVURUQgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBkZWxldGVkXCIsXHJcbiAgICBbXCJzZXJ2ZXItYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5TRVJWRVJfQVBQX0RFTEVURUQgKi9dOiAnRmlyZWJhc2UgU2VydmVyIEFwcCBoYXMgYmVlbiBkZWxldGVkJyxcclxuICAgIFtcIm5vLW9wdGlvbnNcIiAvKiBBcHBFcnJvci5OT19PUFRJT05TICovXTogJ05lZWQgdG8gcHJvdmlkZSBvcHRpb25zLCB3aGVuIG5vdCBiZWluZyBkZXBsb3llZCB0byBob3N0aW5nIHZpYSBzb3VyY2UuJyxcclxuICAgIFtcImludmFsaWQtYXBwLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9BUFBfQVJHVU1FTlQgKi9dOiAnZmlyZWJhc2UueyRhcHBOYW1lfSgpIHRha2VzIGVpdGhlciBubyBhcmd1bWVudCBvciBhICcgK1xyXG4gICAgICAgICdGaXJlYmFzZSBBcHAgaW5zdGFuY2UuJyxcclxuICAgIFtcImludmFsaWQtbG9nLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9MT0dfQVJHVU1FTlQgKi9dOiAnRmlyc3QgYXJndW1lbnQgdG8gYG9uTG9nYCBtdXN0IGJlIG51bGwgb3IgYSBmdW5jdGlvbi4nLFxyXG4gICAgW1wiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqL106ICdFcnJvciB0aHJvd24gd2hlbiBvcGVuaW5nIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXHJcbiAgICBbXCJpZGItZ2V0XCIgLyogQXBwRXJyb3IuSURCX0dFVCAqL106ICdFcnJvciB0aHJvd24gd2hlbiByZWFkaW5nIGZyb20gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJyxcclxuICAgIFtcImlkYi1zZXRcIiAvKiBBcHBFcnJvci5JREJfV1JJVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gd3JpdGluZyB0byBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxyXG4gICAgW1wiaWRiLWRlbGV0ZVwiIC8qIEFwcEVycm9yLklEQl9ERUxFVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gZGVsZXRpbmcgZnJvbSBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxyXG4gICAgW1wiZmluYWxpemF0aW9uLXJlZ2lzdHJ5LW5vdC1zdXBwb3J0ZWRcIiAvKiBBcHBFcnJvci5GSU5BTElaQVRJT05fUkVHSVNUUllfTk9UX1NVUFBPUlRFRCAqL106ICdGaXJlYmFzZVNlcnZlckFwcCBkZWxldGVPbkRlcmVmIGZpZWxkIGRlZmluZWQgYnV0IHRoZSBKUyBydW50aW1lIGRvZXMgbm90IHN1cHBvcnQgRmluYWxpemF0aW9uUmVnaXN0cnkuJyxcclxuICAgIFtcImludmFsaWQtc2VydmVyLWFwcC1lbnZpcm9ubWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfU0VSVkVSX0FQUF9FTlZJUk9OTUVOVCAqL106ICdGaXJlYmFzZVNlcnZlckFwcCBpcyBub3QgZm9yIHVzZSBpbiBicm93c2VyIGVudmlyb25tZW50cy4nXHJcbn07XHJcbmNvbnN0IEVSUk9SX0ZBQ1RPUlkgPSBuZXcgRXJyb3JGYWN0b3J5KCdhcHAnLCAnRmlyZWJhc2UnLCBFUlJPUlMpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZUFwcEltcGwge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLl9pc0RlbGV0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcclxuICAgICAgICB0aGlzLl9uYW1lID0gY29uZmlnLm5hbWU7XHJcbiAgICAgICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID1cclxuICAgICAgICAgICAgY29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDtcclxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2FwcCcsICgpID0+IHRoaXMsIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pKTtcclxuICAgIH1cclxuICAgIGdldCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQoKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XHJcbiAgICB9XHJcbiAgICBzZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKHZhbCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgbmFtZSgpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICB9XHJcbiAgICBnZXQgb3B0aW9ucygpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBnZXQgY29uZmlnKCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbnRhaW5lcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRGVsZXRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNEZWxldGVkO1xyXG4gICAgfVxyXG4gICAgc2V0IGlzRGVsZXRlZCh2YWwpIHtcclxuICAgICAgICB0aGlzLl9pc0RlbGV0ZWQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBFcnJvciBpZiB0aGUgQXBwIGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZCAtXHJcbiAgICAgKiB1c2UgYmVmb3JlIHBlcmZvcm1pbmcgQVBJIGFjdGlvbnMgb24gdGhlIEFwcC5cclxuICAgICAqL1xyXG4gICAgY2hlY2tEZXN0cm95ZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5BUFBfREVMRVRFRCAqLywgeyBhcHBOYW1lOiB0aGlzLl9uYW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZVNlcnZlckFwcEltcGwgZXh0ZW5kcyBGaXJlYmFzZUFwcEltcGwge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgc2VydmVyQ29uZmlnLCBuYW1lLCBjb250YWluZXIpIHtcclxuICAgICAgICAvLyBCdWlsZCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgZm9yIHRoZSBGaXJlYmFzZUFwcEltcGwgYmFzZSBjbGFzcy5cclxuICAgICAgICBjb25zdCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSBzZXJ2ZXJDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBzZXJ2ZXJDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkXHJcbiAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBGaXJlYmFzZUFwcFNldHRpbmdzIG9iamVjdCBmb3IgdGhlIEZpcmViYXNlQXBwSW1wIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAob3B0aW9ucy5hcGlLZXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIHBhcmVudCBGaXJlYmFzZUFwcEltcCBvYmplY3QuXHJcbiAgICAgICAgICAgIHN1cGVyKG9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFwcEltcGwgPSBvcHRpb25zO1xyXG4gICAgICAgICAgICBzdXBlcihhcHBJbXBsLm9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm93IGNvbnN0cnVjdCB0aGUgZGF0YSBmb3IgdGhlIEZpcmViYXNlU2VydmVyQXBwSW1wbC5cclxuICAgICAgICB0aGlzLl9zZXJ2ZXJDb25maWcgPSBPYmplY3QuYXNzaWduKHsgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkIH0sIHNlcnZlckNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmF1dG9tYXRpY0NsZWFudXAoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9yZWZDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5pbmNSZWZDb3VudCh0aGlzLl9zZXJ2ZXJDb25maWcucmVsZWFzZU9uRGVyZWYpO1xyXG4gICAgICAgIC8vIERvIG5vdCByZXRhaW4gYSBoYXJkIHJlZmVyZW5jZSB0byB0aGUgZHJlZiBvYmplY3QsIG90aGVyd2lzZSB0aGUgRmluYWxpemF0aW9uUmVnaXNyeVxyXG4gICAgICAgIC8vIHdpbGwgbmV2ZXIgdHJpZ2dlci5cclxuICAgICAgICB0aGlzLl9zZXJ2ZXJDb25maWcucmVsZWFzZU9uRGVyZWYgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJG8sIHZlcnNpb24kMSwgJ3NlcnZlcmFwcCcpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBnZXQgcmVmQ291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZkNvdW50O1xyXG4gICAgfVxyXG4gICAgLy8gSW5jcmVtZW50IHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBzZXJ2ZXIgYXBwLiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQsIHJlZ2lzdGVyIGl0XHJcbiAgICAvLyB3aXRoIHRoZSBmaW5hbGl6YXRpb24gcmVnaXN0cnkuXHJcbiAgICBpbmNSZWZDb3VudChvYmopIHtcclxuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZWZDb3VudCsrO1xyXG4gICAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6YXRpb25SZWdpc3RyeS5yZWdpc3RlcihvYmosIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIERlY3JlbWVudCB0aGUgcmVmZXJlbmNlIGNvdW50LlxyXG4gICAgZGVjUmVmQ291bnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLS10aGlzLl9yZWZDb3VudDtcclxuICAgIH1cclxuICAgIC8vIEludm9rZWQgYnkgdGhlIEZpbmFsaXphdGlvblJlZ2lzdHJ5IGNhbGxiYWNrIHRvIG5vdGUgdGhhdCB0aGlzIGFwcCBzaG91bGQgZ28gdGhyb3VnaCBpdHNcclxuICAgIC8vIHJlZmVyZW5jZSBjb3VudHMgYW5kIGRlbGV0ZSBpdHNlbGYgaWYgbm8gcmVmZXJlbmNlIGNvdW50IHJlbWFpbi4gVGhlIGNvb3JkaW5hdGluZyBsb2dpYyB0aGF0XHJcbiAgICAvLyBoYW5kbGVzIHRoaXMgaXMgaW4gZGVsZXRlQXBwKC4uLikuXHJcbiAgICBhdXRvbWF0aWNDbGVhbnVwKCkge1xyXG4gICAgICAgIHZvaWQgZGVsZXRlQXBwKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNldHRpbmdzKCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVyQ29uZmlnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IgaWYgdGhlIEFwcCBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQgLVxyXG4gICAgICogdXNlIGJlZm9yZSBwZXJmb3JtaW5nIEFQSSBhY3Rpb25zIG9uIHRoZSBBcHAuXHJcbiAgICAgKi9cclxuICAgIGNoZWNrRGVzdHJveWVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcInNlcnZlci1hcHAtZGVsZXRlZFwiIC8qIEFwcEVycm9yLlNFUlZFUl9BUFBfREVMRVRFRCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgY3VycmVudCBTREsgdmVyc2lvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgU0RLX1ZFUlNJT04gPSB2ZXJzaW9uO1xyXG5mdW5jdGlvbiBpbml0aWFsaXplQXBwKF9vcHRpb25zLCByYXdDb25maWcgPSB7fSkge1xyXG4gICAgbGV0IG9wdGlvbnMgPSBfb3B0aW9ucztcclxuICAgIGlmICh0eXBlb2YgcmF3Q29uZmlnICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSByYXdDb25maWc7XHJcbiAgICAgICAgcmF3Q29uZmlnID0geyBuYW1lIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKHsgbmFtZTogREVGQVVMVF9FTlRSWV9OQU1FLCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ6IGZhbHNlIH0sIHJhd0NvbmZpZyk7XHJcbiAgICBjb25zdCBuYW1lID0gY29uZmlnLm5hbWU7XHJcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8ICFuYW1lKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJiYWQtYXBwLW5hbWVcIiAvKiBBcHBFcnJvci5CQURfQVBQX05BTUUgKi8sIHtcclxuICAgICAgICAgICAgYXBwTmFtZTogU3RyaW5nKG5hbWUpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0gZ2V0RGVmYXVsdEFwcENvbmZpZygpKTtcclxuICAgIGlmICghb3B0aW9ucykge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibm8tb3B0aW9uc1wiIC8qIEFwcEVycm9yLk5PX09QVElPTlMgKi8pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXhpc3RpbmdBcHAgPSBfYXBwcy5nZXQobmFtZSk7XHJcbiAgICBpZiAoZXhpc3RpbmdBcHApIHtcclxuICAgICAgICAvLyByZXR1cm4gdGhlIGV4aXN0aW5nIGFwcCBpZiBvcHRpb25zIGFuZCBjb25maWcgZGVlcCBlcXVhbCB0aGUgb25lcyBpbiB0aGUgZXhpc3RpbmcgYXBwLlxyXG4gICAgICAgIGlmIChkZWVwRXF1YWwob3B0aW9ucywgZXhpc3RpbmdBcHAub3B0aW9ucykgJiZcclxuICAgICAgICAgICAgZGVlcEVxdWFsKGNvbmZpZywgZXhpc3RpbmdBcHAuY29uZmlnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdBcHA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImR1cGxpY2F0ZS1hcHBcIiAvKiBBcHBFcnJvci5EVVBMSUNBVEVfQVBQICovLCB7IGFwcE5hbWU6IG5hbWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgY29udGFpbmVyID0gbmV3IENvbXBvbmVudENvbnRhaW5lcihuYW1lKTtcclxuICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIF9jb21wb25lbnRzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3QXBwID0gbmV3IEZpcmViYXNlQXBwSW1wbChvcHRpb25zLCBjb25maWcsIGNvbnRhaW5lcik7XHJcbiAgICBfYXBwcy5zZXQobmFtZSwgbmV3QXBwKTtcclxuICAgIHJldHVybiBuZXdBcHA7XHJcbn1cclxuZnVuY3Rpb24gaW5pdGlhbGl6ZVNlcnZlckFwcChfb3B0aW9ucywgX3NlcnZlckFwcENvbmZpZykge1xyXG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XHJcbiAgICAgICAgLy8gRmlyZWJhc2VTZXJ2ZXJBcHAgaXNuJ3QgZGVzaWduZWQgdG8gYmUgcnVuIGluIGJyb3dzZXJzLlxyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW52YWxpZC1zZXJ2ZXItYXBwLWVudmlyb25tZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9TRVJWRVJfQVBQX0VOVklST05NRU5UICovKTtcclxuICAgIH1cclxuICAgIGlmIChfc2VydmVyQXBwQ29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgX3NlcnZlckFwcENvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGxldCBhcHBPcHRpb25zO1xyXG4gICAgaWYgKF9pc0ZpcmViYXNlQXBwKF9vcHRpb25zKSkge1xyXG4gICAgICAgIGFwcE9wdGlvbnMgPSBfb3B0aW9ucy5vcHRpb25zO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXBwT3B0aW9ucyA9IF9vcHRpb25zO1xyXG4gICAgfVxyXG4gICAgLy8gQnVpbGQgYW4gYXBwIG5hbWUgYmFzZWQgb24gYSBoYXNoIG9mIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcbiAgICBjb25zdCBuYW1lT2JqID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfc2VydmVyQXBwQ29uZmlnKSwgYXBwT3B0aW9ucyk7XHJcbiAgICAvLyBIb3dldmVyLCBEbyBub3QgbWFuZ2xlIHRoZSBuYW1lIGJhc2VkIG9uIHJlbGVhc2VPbkRlcmVmLCBzaW5jZSBpdCB3aWxsIHZhcnkgYmV0d2VlbiB0aGVcclxuICAgIC8vIGNvbnN0cnVjdGlvbiBvZiBGaXJlYmFzZVNlcnZlckFwcCBpbnN0YW5jZXMuIEZvciBleGFtcGxlLCBpZiB0aGUgb2JqZWN0IGlzIHRoZSByZXF1ZXN0IGhlYWRlcnMuXHJcbiAgICBpZiAobmFtZU9iai5yZWxlYXNlT25EZXJlZiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZGVsZXRlIG5hbWVPYmoucmVsZWFzZU9uRGVyZWY7XHJcbiAgICB9XHJcbiAgICBjb25zdCBoYXNoQ29kZSA9IChzKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi5zXS5yZWR1Y2UoKGhhc2gsIGMpID0+IChNYXRoLmltdWwoMzEsIGhhc2gpICsgYy5jaGFyQ29kZUF0KDApKSB8IDAsIDApO1xyXG4gICAgfTtcclxuICAgIGlmIChfc2VydmVyQXBwQ29uZmlnLnJlbGVhc2VPbkRlcmVmICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImZpbmFsaXphdGlvbi1yZWdpc3RyeS1ub3Qtc3VwcG9ydGVkXCIgLyogQXBwRXJyb3IuRklOQUxJWkFUSU9OX1JFR0lTVFJZX05PVF9TVVBQT1JURUQgKi8sIHt9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBuYW1lU3RyaW5nID0gJycgKyBoYXNoQ29kZShKU09OLnN0cmluZ2lmeShuYW1lT2JqKSk7XHJcbiAgICBjb25zdCBleGlzdGluZ0FwcCA9IF9zZXJ2ZXJBcHBzLmdldChuYW1lU3RyaW5nKTtcclxuICAgIGlmIChleGlzdGluZ0FwcCkge1xyXG4gICAgICAgIGV4aXN0aW5nQXBwLmluY1JlZkNvdW50KF9zZXJ2ZXJBcHBDb25maWcucmVsZWFzZU9uRGVyZWYpO1xyXG4gICAgICAgIHJldHVybiBleGlzdGluZ0FwcDtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb21wb25lbnRDb250YWluZXIobmFtZVN0cmluZyk7XHJcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZVNlcnZlckFwcEltcGwoYXBwT3B0aW9ucywgX3NlcnZlckFwcENvbmZpZywgbmFtZVN0cmluZywgY29udGFpbmVyKTtcclxuICAgIF9zZXJ2ZXJBcHBzLnNldChuYW1lU3RyaW5nLCBuZXdBcHApO1xyXG4gICAgcmV0dXJuIG5ld0FwcDtcclxufVxyXG4vKipcclxuICogUmV0cmlldmVzIGEge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGluc3RhbmNlLlxyXG4gKlxyXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgdGhlIGRlZmF1bHQgYXBwIGlzIHJldHVybmVkLiBXaGVuIGFuIGFwcCBuYW1lXHJcbiAqIGlzIHByb3ZpZGVkLCB0aGUgYXBwIGNvcnJlc3BvbmRpbmcgdG8gdGhhdCBuYW1lIGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBBbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIHRoZSBhcHAgYmVpbmcgcmV0cmlldmVkIGhhcyBub3QgeWV0IGJlZW5cclxuICogaW5pdGlhbGl6ZWQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gUmV0dXJuIHRoZSBkZWZhdWx0IGFwcFxyXG4gKiBjb25zdCBhcHAgPSBnZXRBcHAoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gUmV0dXJuIGEgbmFtZWQgYXBwXHJcbiAqIGNvbnN0IG90aGVyQXBwID0gZ2V0QXBwKFwib3RoZXJBcHBcIik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZSAtIE9wdGlvbmFsIG5hbWUgb2YgdGhlIGFwcCB0byByZXR1cm4uIElmIG5vIG5hbWUgaXNcclxuICogICBwcm92aWRlZCwgdGhlIGRlZmF1bHQgaXMgYFwiW0RFRkFVTFRdXCJgLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgYXBwIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3ZpZGVkIGFwcCBuYW1lLlxyXG4gKiAgIElmIG5vIGFwcCBuYW1lIGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBhcHAgaXMgcmV0dXJuZWQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldEFwcChuYW1lID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICBjb25zdCBhcHAgPSBfYXBwcy5nZXQobmFtZSk7XHJcbiAgICBpZiAoIWFwcCAmJiBuYW1lID09PSBERUZBVUxUX0VOVFJZX05BTUUgJiYgZ2V0RGVmYXVsdEFwcENvbmZpZygpKSB7XHJcbiAgICAgICAgcmV0dXJuIGluaXRpYWxpemVBcHAoKTtcclxuICAgIH1cclxuICAgIGlmICghYXBwKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1hcHBcIiAvKiBBcHBFcnJvci5OT19BUFAgKi8sIHsgYXBwTmFtZTogbmFtZSB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcHA7XHJcbn1cclxuLyoqXHJcbiAqIEEgKHJlYWQtb25seSkgYXJyYXkgb2YgYWxsIGluaXRpYWxpemVkIGFwcHMuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldEFwcHMoKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbShfYXBwcy52YWx1ZXMoKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGhpcyBhcHAgdW51c2FibGUgYW5kIGZyZWVzIHRoZSByZXNvdXJjZXMgb2YgYWxsIGFzc29jaWF0ZWRcclxuICogc2VydmljZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogZGVsZXRlQXBwKGFwcClcclxuICogICAudGhlbihmdW5jdGlvbigpIHtcclxuICogICAgIGNvbnNvbGUubG9nKFwiQXBwIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xyXG4gKiAgIH0pXHJcbiAqICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGRlbGV0aW5nIGFwcDpcIiwgZXJyb3IpO1xyXG4gKiAgIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlQXBwKGFwcCkge1xyXG4gICAgbGV0IGNsZWFudXBQcm92aWRlcnMgPSBmYWxzZTtcclxuICAgIGNvbnN0IG5hbWUgPSBhcHAubmFtZTtcclxuICAgIGlmIChfYXBwcy5oYXMobmFtZSkpIHtcclxuICAgICAgICBjbGVhbnVwUHJvdmlkZXJzID0gdHJ1ZTtcclxuICAgICAgICBfYXBwcy5kZWxldGUobmFtZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChfc2VydmVyQXBwcy5oYXMobmFtZSkpIHtcclxuICAgICAgICBjb25zdCBmaXJlYmFzZVNlcnZlckFwcCA9IGFwcDtcclxuICAgICAgICBpZiAoZmlyZWJhc2VTZXJ2ZXJBcHAuZGVjUmVmQ291bnQoKSA8PSAwKSB7XHJcbiAgICAgICAgICAgIF9zZXJ2ZXJBcHBzLmRlbGV0ZShuYW1lKTtcclxuICAgICAgICAgICAgY2xlYW51cFByb3ZpZGVycyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGNsZWFudXBQcm92aWRlcnMpIHtcclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChhcHAuY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5nZXRQcm92aWRlcnMoKVxyXG4gICAgICAgICAgICAubWFwKHByb3ZpZGVyID0+IHByb3ZpZGVyLmRlbGV0ZSgpKSk7XHJcbiAgICAgICAgYXBwLmlzRGVsZXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhIGxpYnJhcnkncyBuYW1lIGFuZCB2ZXJzaW9uIGZvciBwbGF0Zm9ybSBsb2dnaW5nIHB1cnBvc2VzLlxyXG4gKiBAcGFyYW0gbGlicmFyeSAtIE5hbWUgb2YgMXAgb3IgM3AgbGlicmFyeSAoZS5nLiBmaXJlc3RvcmUsIGFuZ3VsYXJmaXJlKVxyXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGF0IGxpYnJhcnkuXHJcbiAqIEBwYXJhbSB2YXJpYW50IC0gQnVuZGxlIHZhcmlhbnQsIGUuZy4sIG5vZGUsIHJuLCBldGMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyVmVyc2lvbihsaWJyYXJ5S2V5T3JOYW1lLCB2ZXJzaW9uLCB2YXJpYW50KSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICAvLyBUT0RPOiBXZSBjYW4gdXNlIHRoaXMgY2hlY2sgdG8gd2hpdGVsaXN0IHN0cmluZ3Mgd2hlbi9pZiB3ZSBzZXQgdXBcclxuICAgIC8vIGEgZ29vZCB3aGl0ZWxpc3Qgc3lzdGVtLlxyXG4gICAgbGV0IGxpYnJhcnkgPSAoX2EgPSBQTEFURk9STV9MT0dfU1RSSU5HW2xpYnJhcnlLZXlPck5hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBsaWJyYXJ5S2V5T3JOYW1lO1xyXG4gICAgaWYgKHZhcmlhbnQpIHtcclxuICAgICAgICBsaWJyYXJ5ICs9IGAtJHt2YXJpYW50fWA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsaWJyYXJ5TWlzbWF0Y2ggPSBsaWJyYXJ5Lm1hdGNoKC9cXHN8XFwvLyk7XHJcbiAgICBjb25zdCB2ZXJzaW9uTWlzbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKC9cXHN8XFwvLyk7XHJcbiAgICBpZiAobGlicmFyeU1pc21hdGNoIHx8IHZlcnNpb25NaXNtYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IHdhcm5pbmcgPSBbXHJcbiAgICAgICAgICAgIGBVbmFibGUgdG8gcmVnaXN0ZXIgbGlicmFyeSBcIiR7bGlicmFyeX1cIiB3aXRoIHZlcnNpb24gXCIke3ZlcnNpb259XCI6YFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKGxpYnJhcnlNaXNtYXRjaCkge1xyXG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goYGxpYnJhcnkgbmFtZSBcIiR7bGlicmFyeX1cIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMgKHdoaXRlc3BhY2Ugb3IgXCIvXCIpYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2ggJiYgdmVyc2lvbk1pc21hdGNoKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaCgnYW5kJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ZXJzaW9uTWlzbWF0Y2gpIHtcclxuICAgICAgICAgICAgd2FybmluZy5wdXNoKGB2ZXJzaW9uIG5hbWUgXCIke3ZlcnNpb259XCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzICh3aGl0ZXNwYWNlIG9yIFwiL1wiKWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2dnZXIud2Fybih3YXJuaW5nLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoYCR7bGlicmFyeX0tdmVyc2lvbmAsICgpID0+ICh7IGxpYnJhcnksIHZlcnNpb24gfSksIFwiVkVSU0lPTlwiIC8qIENvbXBvbmVudFR5cGUuVkVSU0lPTiAqLykpO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIGxvZyBoYW5kbGVyIGZvciBhbGwgRmlyZWJhc2UgU0RLcy5cclxuICogQHBhcmFtIGxvZ0NhbGxiYWNrIC0gQW4gb3B0aW9uYWwgY3VzdG9tIGxvZyBoYW5kbGVyIHRoYXQgZXhlY3V0ZXMgdXNlciBjb2RlIHdoZW5ldmVyXHJcbiAqIHRoZSBGaXJlYmFzZSBTREsgbWFrZXMgYSBsb2dnaW5nIGNhbGwuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIG9uTG9nKGxvZ0NhbGxiYWNrLCBvcHRpb25zKSB7XHJcbiAgICBpZiAobG9nQ2FsbGJhY2sgIT09IG51bGwgJiYgdHlwZW9mIGxvZ0NhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpbnZhbGlkLWxvZy1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfTE9HX0FSR1VNRU5UICovKTtcclxuICAgIH1cclxuICAgIHNldFVzZXJMb2dIYW5kbGVyKGxvZ0NhbGxiYWNrLCBvcHRpb25zKTtcclxufVxyXG4vKipcclxuICogU2V0cyBsb2cgbGV2ZWwgZm9yIGFsbCBGaXJlYmFzZSBTREtzLlxyXG4gKlxyXG4gKiBBbGwgb2YgdGhlIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgYXJlIGNhcHR1cmVkIChpLmUuIGlmXHJcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgaW5mb2AsIGVycm9ycyBhcmUgbG9nZ2VkLCBidXQgYGRlYnVnYCBhbmRcclxuICogYHZlcmJvc2VgIGxvZ3MgYXJlIG5vdCkuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XHJcbiAgICBzZXRMb2dMZXZlbCQxKGxvZ0xldmVsKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBEQl9OQU1FID0gJ2ZpcmViYXNlLWhlYXJ0YmVhdC1kYXRhYmFzZSc7XHJcbmNvbnN0IERCX1ZFUlNJT04gPSAxO1xyXG5jb25zdCBTVE9SRV9OQU1FID0gJ2ZpcmViYXNlLWhlYXJ0YmVhdC1zdG9yZSc7XHJcbmxldCBkYlByb21pc2UgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXREYlByb21pc2UoKSB7XHJcbiAgICBpZiAoIWRiUHJvbWlzZSkge1xyXG4gICAgICAgIGRiUHJvbWlzZSA9IG9wZW5EQihEQl9OQU1FLCBEQl9WRVJTSU9OLCB7XHJcbiAgICAgICAgICAgIHVwZ3JhZGU6IChkYiwgb2xkVmVyc2lvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXNlICdicmVhaycgaW4gdGhpcyBzd2l0Y2ggc3RhdGVtZW50LCB0aGUgZmFsbC10aHJvdWdoXHJcbiAgICAgICAgICAgICAgICAvLyBiZWhhdmlvciBpcyB3aGF0IHdlIHdhbnQsIGJlY2F1c2UgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHZlcnNpb25zIGJldHdlZW5cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBvbGQgdmVyc2lvbiBhbmQgdGhlIGN1cnJlbnQgdmVyc2lvbiwgd2Ugd2FudCBBTEwgdGhlIG1pZ3JhdGlvbnNcclxuICAgICAgICAgICAgICAgIC8vIHRoYXQgY29ycmVzcG9uZCB0byB0aG9zZSB2ZXJzaW9ucyB0byBydW4sIG5vdCBvbmx5IHRoZSBsYXN0IG9uZS5cclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob2xkVmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkvaU9TIGJyb3dzZXJzIHRocm93IG9jY2FzaW9uYWwgZXhjZXB0aW9ucyBvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGIuY3JlYXRlT2JqZWN0U3RvcmUoKSB0aGF0IG1heSBiZSBhIGJ1Zy4gQXZvaWQgYmxvY2tpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXN0IG9mIHRoZSBhcHAgZnVuY3Rpb25hbGl0eS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqLywge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvck1lc3NhZ2U6IGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYlByb21pc2U7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKGFwcCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdHgub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSkuZ2V0KGNvbXB1dGVLZXkoYXBwKSk7XHJcbiAgICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIHRoZSB2YWx1ZSBidXQgdHguZG9uZSBjYW4gdGhyb3csXHJcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byBhd2FpdCBpdCBoZXJlIHRvIGNhdGNoIGVycm9yc1xyXG4gICAgICAgIGF3YWl0IHR4LmRvbmU7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBpZGJHZXRFcnJvciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLWdldFwiIC8qIEFwcEVycm9yLklEQl9HRVQgKi8sIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKGFwcCwgaGVhcnRiZWF0T2JqZWN0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XHJcbiAgICAgICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihTVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcclxuICAgICAgICBhd2FpdCBvYmplY3RTdG9yZS5wdXQoaGVhcnRiZWF0T2JqZWN0LCBjb21wdXRlS2V5KGFwcCkpO1xyXG4gICAgICAgIGF3YWl0IHR4LmRvbmU7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihlLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaWRiR2V0RXJyb3IgPSBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImlkYi1zZXRcIiAvKiBBcHBFcnJvci5JREJfV1JJVEUgKi8sIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVLZXkoYXBwKSB7XHJcbiAgICByZXR1cm4gYCR7YXBwLm5hbWV9ISR7YXBwLm9wdGlvbnMuYXBwSWR9YDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBNQVhfSEVBREVSX0JZVEVTID0gMTAyNDtcclxuLy8gMzAgZGF5c1xyXG5jb25zdCBTVE9SRURfSEVBUlRCRUFUX1JFVEVOVElPTl9NQVhfTUlMTElTID0gMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xyXG5jbGFzcyBIZWFydGJlYXRTZXJ2aWNlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbi1tZW1vcnkgY2FjaGUgZm9yIGhlYXJ0YmVhdHMsIHVzZWQgYnkgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIHRvIGdlbmVyYXRlXHJcbiAgICAgICAgICogdGhlIGhlYWRlciBzdHJpbmcuXHJcbiAgICAgICAgICogU3RvcmVzIG9uZSByZWNvcmQgcGVyIGRhdGUuIFRoaXMgd2lsbCBiZSBjb25zb2xpZGF0ZWQgaW50byB0aGUgc3RhbmRhcmRcclxuICAgICAgICAgKiBmb3JtYXQgb2Ygb25lIHJlY29yZCBwZXIgdXNlciBhZ2VudCBzdHJpbmcgYmVmb3JlIGJlaW5nIHNlbnQgYXMgYSBoZWFkZXIuXHJcbiAgICAgICAgICogUG9wdWxhdGVkIGZyb20gaW5kZXhlZERCIHdoZW4gdGhlIGNvbnRyb2xsZXIgaXMgaW5zdGFudGlhdGVkIGFuZCBzaG91bGRcclxuICAgICAgICAgKiBiZSBrZXB0IGluIHN5bmMgd2l0aCBpbmRleGVkREIuXHJcbiAgICAgICAgICogTGVhdmUgcHVibGljIGZvciBlYXNpZXIgdGVzdGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICB0aGlzLl9zdG9yYWdlID0gbmV3IEhlYXJ0YmVhdFN0b3JhZ2VJbXBsKGFwcCk7XHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZSA9IHRoaXMuX3N0b3JhZ2UucmVhZCgpLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gcmVzdWx0O1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgdG8gcmVwb3J0IGEgaGVhcnRiZWF0LiBUaGUgZnVuY3Rpb24gd2lsbCBnZW5lcmF0ZVxyXG4gICAgICogYSBIZWFydGJlYXRzQnlVc2VyQWdlbnQgb2JqZWN0LCB1cGRhdGUgaGVhcnRiZWF0c0NhY2hlLCBhbmQgcGVyc2lzdCBpdFxyXG4gICAgICogdG8gSW5kZXhlZERCLlxyXG4gICAgICogTm90ZSB0aGF0IHdlIG9ubHkgc3RvcmUgb25lIGhlYXJ0YmVhdCBwZXIgZGF5LiBTbyBpZiBhIGhlYXJ0YmVhdCBmb3IgdG9kYXkgaXNcclxuICAgICAqIGFscmVhZHkgbG9nZ2VkLCBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoaXMgZnVuY3Rpb24gaW4gdGhlIHNhbWUgZGF5IHdpbGwgYmUgaWdub3JlZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgdHJpZ2dlckhlYXJ0YmVhdCgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IHBsYXRmb3JtTG9nZ2VyID0gdGhpcy5jb250YWluZXJcclxuICAgICAgICAgICAgLmdldFByb3ZpZGVyKCdwbGF0Zm9ybS1sb2dnZXInKVxyXG4gICAgICAgICAgICAuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgXCJGaXJlYmFzZSB1c2VyIGFnZW50XCIgc3RyaW5nIGZyb20gdGhlIHBsYXRmb3JtIGxvZ2dlclxyXG4gICAgICAgIC8vIHNlcnZpY2UsIG5vdCB0aGUgYnJvd3NlciB1c2VyIGFnZW50LlxyXG4gICAgICAgIGNvbnN0IGFnZW50ID0gcGxhdGZvcm1Mb2dnZXIuZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgZGF0ZSA9IGdldFVUQ0RhdGVTdHJpbmcoKTtcclxuICAgICAgICBpZiAoKChfYSA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYXJ0YmVhdHMpID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcclxuICAgICAgICAgICAgLy8gSWYgd2UgZmFpbGVkIHRvIGNvbnN0cnVjdCBhIGhlYXJ0YmVhdHMgY2FjaGUsIHRoZW4gcmV0dXJuIGltbWVkaWF0ZWx5LlxyXG4gICAgICAgICAgICBpZiAoKChfYiA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlYXJ0YmVhdHMpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEbyBub3Qgc3RvcmUgYSBoZWFydGJlYXQgaWYgb25lIGlzIGFscmVhZHkgc3RvcmVkIGZvciB0aGlzIGRheVxyXG4gICAgICAgIC8vIG9yIGlmIGEgaGVhZGVyIGhhcyBhbHJlYWR5IGJlZW4gc2VudCB0b2RheS5cclxuICAgICAgICBpZiAodGhpcy5faGVhcnRiZWF0c0NhY2hlLmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA9PT0gZGF0ZSB8fFxyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5zb21lKHNpbmdsZURhdGVIZWFydGJlYXQgPT4gc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlID09PSBkYXRlKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBlbnRyeSBmb3IgdGhpcyBkYXRlLiBDcmVhdGUgb25lLlxyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5wdXNoKHsgZGF0ZSwgYWdlbnQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBlbnRyaWVzIG9sZGVyIHRoYW4gMzAgZGF5cy5cclxuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLmZpbHRlcihzaW5nbGVEYXRlSGVhcnRiZWF0ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaGJUaW1lc3RhbXAgPSBuZXcgRGF0ZShzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUpLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vdyAtIGhiVGltZXN0YW1wIDw9IFNUT1JFRF9IRUFSVEJFQVRfUkVURU5USU9OX01BWF9NSUxMSVM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgd2hpY2ggY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBoZWFydGJlYXQtc3BlY2lmaWMgaGVhZGVyIGRpcmVjdGx5LlxyXG4gICAgICogSXQgYWxzbyBjbGVhcnMgYWxsIGhlYXJ0YmVhdHMgZnJvbSBtZW1vcnkgYXMgd2VsbCBhcyBpbiBJbmRleGVkREIuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogQ29uc3VtaW5nIHByb2R1Y3QgU0RLcyBzaG91bGQgbm90IHNlbmQgdGhlIGhlYWRlciBpZiB0aGlzIG1ldGhvZFxyXG4gICAgICogcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEhlYXJ0YmVhdHNIZWFkZXIoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgaXQncyBzdGlsbCBudWxsIG9yIHRoZSBhcnJheSBpcyBlbXB0eSwgdGhlcmUgaXMgbm8gZGF0YSB0byBzZW5kLlxyXG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhcnRiZWF0cykgPT0gbnVsbCB8fFxyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRlID0gZ2V0VVRDRGF0ZVN0cmluZygpO1xyXG4gICAgICAgIC8vIEV4dHJhY3QgYXMgbWFueSBoZWFydGJlYXRzIGZyb20gdGhlIGNhY2hlIGFzIHdpbGwgZml0IHVuZGVyIHRoZSBzaXplIGxpbWl0LlxyXG4gICAgICAgIGNvbnN0IHsgaGVhcnRiZWF0c1RvU2VuZCwgdW5zZW50RW50cmllcyB9ID0gZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIodGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMpO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlclN0cmluZyA9IGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogMiwgaGVhcnRiZWF0czogaGVhcnRiZWF0c1RvU2VuZCB9KSk7XHJcbiAgICAgICAgLy8gU3RvcmUgbGFzdCBzZW50IGRhdGUgdG8gcHJldmVudCBhbm90aGVyIGJlaW5nIGxvZ2dlZC9zZW50IGZvciB0aGUgc2FtZSBkYXkuXHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA9IGRhdGU7XHJcbiAgICAgICAgaWYgKHVuc2VudEVudHJpZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAvLyBTdG9yZSBhbnkgdW5zZW50IGVudHJpZXMgaWYgdGhleSBleGlzdC5cclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPSB1bnNlbnRFbnRyaWVzO1xyXG4gICAgICAgICAgICAvLyBUaGlzIHNlZW1zIG1vcmUgbGlrZWx5IHRoYW4gZW1wdHlpbmcgdGhlIGFycmF5IChiZWxvdykgdG8gbGVhZCB0byBzb21lIG9kZCBzdGF0ZVxyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgY2FjaGUgaXNuJ3QgZW1wdHkgYW5kIHRoaXMgd2lsbCBiZSBjYWxsZWQgYWdhaW4gb24gdGhlIG5leHQgcmVxdWVzdCxcclxuICAgICAgICAgICAgLy8gYW5kIGlzIHByb2JhYmx5IHNhZmVzdCBpZiB3ZSBhd2FpdCBpdC5cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gW107XHJcbiAgICAgICAgICAgIC8vIERvIG5vdCB3YWl0IGZvciB0aGlzLCB0byByZWR1Y2UgbGF0ZW5jeS5cclxuICAgICAgICAgICAgdm9pZCB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGVhZGVyU3RyaW5nO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFVUQ0RhdGVTdHJpbmcoKSB7XHJcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XHJcbiAgICAvLyBSZXR1cm5zIGRhdGUgZm9ybWF0ICdZWVlZLU1NLUREJ1xyXG4gICAgcmV0dXJuIHRvZGF5LnRvSVNPU3RyaW5nKCkuc3Vic3RyaW5nKDAsIDEwKTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0SGVhcnRiZWF0c0ZvckhlYWRlcihoZWFydGJlYXRzQ2FjaGUsIG1heFNpemUgPSBNQVhfSEVBREVSX0JZVEVTKSB7XHJcbiAgICAvLyBIZWFydGJlYXRzIGdyb3VwZWQgYnkgdXNlciBhZ2VudCBpbiB0aGUgc3RhbmRhcmQgZm9ybWF0IHRvIGJlIHNlbnQgaW5cclxuICAgIC8vIHRoZSBoZWFkZXIuXHJcbiAgICBjb25zdCBoZWFydGJlYXRzVG9TZW5kID0gW107XHJcbiAgICAvLyBTaW5nbGUgZGF0ZSBmb3JtYXQgaGVhcnRiZWF0cyB0aGF0IGFyZSBub3Qgc2VudC5cclxuICAgIGxldCB1bnNlbnRFbnRyaWVzID0gaGVhcnRiZWF0c0NhY2hlLnNsaWNlKCk7XHJcbiAgICBmb3IgKGNvbnN0IHNpbmdsZURhdGVIZWFydGJlYXQgb2YgaGVhcnRiZWF0c0NhY2hlKSB7XHJcbiAgICAgICAgLy8gTG9vayBmb3IgYW4gZXhpc3RpbmcgZW50cnkgd2l0aCB0aGUgc2FtZSB1c2VyIGFnZW50LlxyXG4gICAgICAgIGNvbnN0IGhlYXJ0YmVhdEVudHJ5ID0gaGVhcnRiZWF0c1RvU2VuZC5maW5kKGhiID0+IGhiLmFnZW50ID09PSBzaW5nbGVEYXRlSGVhcnRiZWF0LmFnZW50KTtcclxuICAgICAgICBpZiAoIWhlYXJ0YmVhdEVudHJ5KSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIGVudHJ5IGZvciB0aGlzIHVzZXIgYWdlbnQgZXhpc3RzLCBjcmVhdGUgb25lLlxyXG4gICAgICAgICAgICBoZWFydGJlYXRzVG9TZW5kLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgYWdlbnQ6IHNpbmdsZURhdGVIZWFydGJlYXQuYWdlbnQsXHJcbiAgICAgICAgICAgICAgICBkYXRlczogW3NpbmdsZURhdGVIZWFydGJlYXQuZGF0ZV1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChjb3VudEJ5dGVzKGhlYXJ0YmVhdHNUb1NlbmQpID4gbWF4U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgaGVhcnRiZWF0XHJcbiAgICAgICAgICAgICAgICAvLyBlbnRyeSBhbmQgc3RvcCBhZGRpbmcgdG8gdGhlIGhlYWRlci5cclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGVhcnRiZWF0RW50cnkuZGF0ZXMucHVzaChzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgaGVhZGVyIHdvdWxkIGV4Y2VlZCBtYXggc2l6ZSwgcmVtb3ZlIHRoZSBhZGRlZCBkYXRlXHJcbiAgICAgICAgICAgIC8vIGFuZCBzdG9wIGFkZGluZyB0byB0aGUgaGVhZGVyLlxyXG4gICAgICAgICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdEVudHJ5LmRhdGVzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUG9wIHVuc2VudCBlbnRyeSBmcm9tIHF1ZXVlLiAoU2tpcHBlZCBpZiBhZGRpbmcgdGhlIGVudHJ5IGV4Y2VlZGVkXHJcbiAgICAgICAgLy8gcXVvdGEgYW5kIHRoZSBsb29wIGJyZWFrcyBlYXJseS4pXHJcbiAgICAgICAgdW5zZW50RW50cmllcyA9IHVuc2VudEVudHJpZXMuc2xpY2UoMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQsXHJcbiAgICAgICAgdW5zZW50RW50cmllc1xyXG4gICAgfTtcclxufVxyXG5jbGFzcyBIZWFydGJlYXRTdG9yYWdlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHApIHtcclxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcclxuICAgICAgICB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlID0gdGhpcy5ydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCkge1xyXG4gICAgICAgIGlmICghaXNJbmRleGVkREJBdmFpbGFibGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0cnVlKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYWxsIGhlYXJ0YmVhdHMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlYWQoKSB7XHJcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcclxuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xyXG4gICAgICAgICAgICByZXR1cm4geyBoZWFydGJlYXRzOiBbXSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaWRiSGVhcnRiZWF0T2JqZWN0ID0gYXdhaXQgcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKHRoaXMuYXBwKTtcclxuICAgICAgICAgICAgaWYgKGlkYkhlYXJ0YmVhdE9iamVjdCA9PT0gbnVsbCB8fCBpZGJIZWFydGJlYXRPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkYkhlYXJ0YmVhdE9iamVjdC5oZWFydGJlYXRzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWRiSGVhcnRiZWF0T2JqZWN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaGVhcnRiZWF0czogW10gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG92ZXJ3cml0ZSB0aGUgc3RvcmFnZSB3aXRoIHRoZSBwcm92aWRlZCBoZWFydGJlYXRzXHJcbiAgICBhc3luYyBvdmVyd3JpdGUoaGVhcnRiZWF0c09iamVjdCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xyXG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCA9IGF3YWl0IHRoaXMucmVhZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gd3JpdGVIZWFydGJlYXRzVG9JbmRleGVkREIodGhpcy5hcHAsIHtcclxuICAgICAgICAgICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTogKF9hID0gaGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzOiBoZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gYWRkIGhlYXJ0YmVhdHNcclxuICAgIGFzeW5jIGFkZChoZWFydGJlYXRzT2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XHJcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0ID0gYXdhaXQgdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQih0aGlzLmFwcCwge1xyXG4gICAgICAgICAgICAgICAgbGFzdFNlbnRIZWFydGJlYXREYXRlOiAoX2EgPSBoZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSxcclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHM6IFtcclxuICAgICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0cyxcclxuICAgICAgICAgICAgICAgICAgICAuLi5oZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgYnl0ZXMgb2YgYSBIZWFydGJlYXRzQnlVc2VyQWdlbnQgYXJyYXkgYWZ0ZXIgYmVpbmcgd3JhcHBlZFxyXG4gKiBpbiBhIHBsYXRmb3JtIGxvZ2dpbmcgaGVhZGVyIEpTT04gb2JqZWN0LCBzdHJpbmdpZmllZCwgYW5kIGNvbnZlcnRlZFxyXG4gKiB0byBiYXNlIDY0LlxyXG4gKi9cclxuZnVuY3Rpb24gY291bnRCeXRlcyhoZWFydGJlYXRzQ2FjaGUpIHtcclxuICAgIC8vIGJhc2U2NCBoYXMgYSByZXN0cmljdGVkIHNldCBvZiBjaGFyYWN0ZXJzLCBhbGwgb2Ygd2hpY2ggc2hvdWxkIGJlIDEgYnl0ZS5cclxuICAgIHJldHVybiBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhcclxuICAgIC8vIGhlYXJ0YmVhdHNDYWNoZSB3cmFwcGVyIHByb3BlcnRpZXNcclxuICAgIEpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogMiwgaGVhcnRiZWF0czogaGVhcnRiZWF0c0NhY2hlIH0pKS5sZW5ndGg7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJDb3JlQ29tcG9uZW50cyh2YXJpYW50KSB7XHJcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgncGxhdGZvcm0tbG9nZ2VyJywgY29udGFpbmVyID0+IG5ldyBQbGF0Zm9ybUxvZ2dlclNlcnZpY2VJbXBsKGNvbnRhaW5lciksIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2hlYXJ0YmVhdCcsIGNvbnRhaW5lciA9PiBuZXcgSGVhcnRiZWF0U2VydmljZUltcGwoY29udGFpbmVyKSwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKSk7XHJcbiAgICAvLyBSZWdpc3RlciBgYXBwYCBwYWNrYWdlLlxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUkbywgdmVyc2lvbiQxLCB2YXJpYW50KTtcclxuICAgIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbTUsIGVzbTIwMTcsIGNqczUsIGV0YyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSRvLCB2ZXJzaW9uJDEsICdlc20yMDE3Jyk7XHJcbiAgICAvLyBSZWdpc3RlciBwbGF0Zm9ybSBTREsgaWRlbnRpZmllciAobm8gdmVyc2lvbikuXHJcbiAgICByZWdpc3RlclZlcnNpb24oJ2ZpcmUtanMnLCAnJyk7XHJcbn1cblxuLyoqXHJcbiAqIEZpcmViYXNlIEFwcFxyXG4gKlxyXG4gKiBAcmVtYXJrcyBUaGlzIHBhY2thZ2UgY29vcmRpbmF0ZXMgdGhlIGNvbW11bmljYXRpb24gYmV0d2VlbiB0aGUgZGlmZmVyZW50IEZpcmViYXNlIGNvbXBvbmVudHNcclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xyXG5yZWdpc3RlckNvcmVDb21wb25lbnRzKCcnKTtcblxuZXhwb3J0IHsgU0RLX1ZFUlNJT04sIERFRkFVTFRfRU5UUllfTkFNRSBhcyBfREVGQVVMVF9FTlRSWV9OQU1FLCBfYWRkQ29tcG9uZW50LCBfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQsIF9hcHBzLCBfY2xlYXJDb21wb25lbnRzLCBfY29tcG9uZW50cywgX2dldFByb3ZpZGVyLCBfaXNGaXJlYmFzZUFwcCwgX2lzRmlyZWJhc2VTZXJ2ZXJBcHAsIF9yZWdpc3RlckNvbXBvbmVudCwgX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSwgX3NlcnZlckFwcHMsIGRlbGV0ZUFwcCwgZ2V0QXBwLCBnZXRBcHBzLCBpbml0aWFsaXplQXBwLCBpbml0aWFsaXplU2VydmVyQXBwLCBvbkxvZywgcmVnaXN0ZXJWZXJzaW9uLCBzZXRMb2dMZXZlbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJDb21wb25lbnQiLCJDb21wb25lbnRDb250YWluZXIiLCJMb2dnZXIiLCJzZXRVc2VyTG9nSGFuZGxlciIsInNldExvZ0xldmVsIiwic2V0TG9nTGV2ZWwkMSIsIkVycm9yRmFjdG9yeSIsImdldERlZmF1bHRBcHBDb25maWciLCJkZWVwRXF1YWwiLCJpc0Jyb3dzZXIiLCJGaXJlYmFzZUVycm9yIiwiYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmciLCJpc0luZGV4ZWREQkF2YWlsYWJsZSIsInZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUiLCJvcGVuREIiLCJQbGF0Zm9ybUxvZ2dlclNlcnZpY2VJbXBsIiwiY29uc3RydWN0b3IiLCJjb250YWluZXIiLCJnZXRQbGF0Zm9ybUluZm9TdHJpbmciLCJwcm92aWRlcnMiLCJnZXRQcm92aWRlcnMiLCJtYXAiLCJwcm92aWRlciIsImlzVmVyc2lvblNlcnZpY2VQcm92aWRlciIsInNlcnZpY2UiLCJnZXRJbW1lZGlhdGUiLCJsaWJyYXJ5IiwidmVyc2lvbiIsImZpbHRlciIsImxvZ1N0cmluZyIsImpvaW4iLCJjb21wb25lbnQiLCJnZXRDb21wb25lbnQiLCJ0eXBlIiwibmFtZSRvIiwidmVyc2lvbiQxIiwibG9nZ2VyIiwibmFtZSRuIiwibmFtZSRtIiwibmFtZSRsIiwibmFtZSRrIiwibmFtZSRqIiwibmFtZSRpIiwibmFtZSRoIiwibmFtZSRnIiwibmFtZSRmIiwibmFtZSRlIiwibmFtZSRkIiwibmFtZSRjIiwibmFtZSRiIiwibmFtZSRhIiwibmFtZSQ5IiwibmFtZSQ4IiwibmFtZSQ3IiwibmFtZSQ2IiwibmFtZSQ1IiwibmFtZSQ0IiwibmFtZSQzIiwibmFtZSQyIiwibmFtZSQxIiwibmFtZSIsIkRFRkFVTFRfRU5UUllfTkFNRSIsIlBMQVRGT1JNX0xPR19TVFJJTkciLCJfYXBwcyIsIk1hcCIsIl9zZXJ2ZXJBcHBzIiwiX2NvbXBvbmVudHMiLCJfYWRkQ29tcG9uZW50IiwiYXBwIiwiYWRkQ29tcG9uZW50IiwiZSIsImRlYnVnIiwiX2FkZE9yT3ZlcndyaXRlQ29tcG9uZW50IiwiYWRkT3JPdmVyd3JpdGVDb21wb25lbnQiLCJfcmVnaXN0ZXJDb21wb25lbnQiLCJjb21wb25lbnROYW1lIiwiaGFzIiwic2V0IiwidmFsdWVzIiwic2VydmVyQXBwIiwiX2dldFByb3ZpZGVyIiwiaGVhcnRiZWF0Q29udHJvbGxlciIsImdldFByb3ZpZGVyIiwib3B0aW9uYWwiLCJ0cmlnZ2VySGVhcnRiZWF0IiwiX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSIsImluc3RhbmNlSWRlbnRpZmllciIsImNsZWFySW5zdGFuY2UiLCJfaXNGaXJlYmFzZUFwcCIsIm9iaiIsIm9wdGlvbnMiLCJ1bmRlZmluZWQiLCJfaXNGaXJlYmFzZVNlcnZlckFwcCIsInNldHRpbmdzIiwiX2NsZWFyQ29tcG9uZW50cyIsImNsZWFyIiwiRVJST1JTIiwiRVJST1JfRkFDVE9SWSIsIkZpcmViYXNlQXBwSW1wbCIsImNvbmZpZyIsIl9pc0RlbGV0ZWQiLCJfb3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsIl9jb25maWciLCJfbmFtZSIsIl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQiLCJhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQiLCJfY29udGFpbmVyIiwiY2hlY2tEZXN0cm95ZWQiLCJ2YWwiLCJpc0RlbGV0ZWQiLCJjcmVhdGUiLCJhcHBOYW1lIiwiRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsIiwic2VydmVyQ29uZmlnIiwiYXBpS2V5IiwiYXBwSW1wbCIsIl9zZXJ2ZXJDb25maWciLCJfZmluYWxpemF0aW9uUmVnaXN0cnkiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsImF1dG9tYXRpY0NsZWFudXAiLCJfcmVmQ291bnQiLCJpbmNSZWZDb3VudCIsInJlbGVhc2VPbkRlcmVmIiwicmVnaXN0ZXJWZXJzaW9uIiwidG9KU09OIiwicmVmQ291bnQiLCJyZWdpc3RlciIsImRlY1JlZkNvdW50IiwiZGVsZXRlQXBwIiwiU0RLX1ZFUlNJT04iLCJpbml0aWFsaXplQXBwIiwicmF3Q29uZmlnIiwiU3RyaW5nIiwiZXhpc3RpbmdBcHAiLCJnZXQiLCJuZXdBcHAiLCJpbml0aWFsaXplU2VydmVyQXBwIiwiX3NlcnZlckFwcENvbmZpZyIsImFwcE9wdGlvbnMiLCJuYW1lT2JqIiwiaGFzaENvZGUiLCJzIiwicmVkdWNlIiwiaGFzaCIsImMiLCJNYXRoIiwiaW11bCIsImNoYXJDb2RlQXQiLCJuYW1lU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldEFwcCIsImdldEFwcHMiLCJBcnJheSIsImZyb20iLCJjbGVhbnVwUHJvdmlkZXJzIiwiZGVsZXRlIiwiZmlyZWJhc2VTZXJ2ZXJBcHAiLCJQcm9taXNlIiwiYWxsIiwibGlicmFyeUtleU9yTmFtZSIsInZhcmlhbnQiLCJfYSIsImxpYnJhcnlNaXNtYXRjaCIsIm1hdGNoIiwidmVyc2lvbk1pc21hdGNoIiwid2FybmluZyIsInB1c2giLCJ3YXJuIiwib25Mb2ciLCJsb2dDYWxsYmFjayIsImxvZ0xldmVsIiwiREJfTkFNRSIsIkRCX1ZFUlNJT04iLCJTVE9SRV9OQU1FIiwiZGJQcm9taXNlIiwiZ2V0RGJQcm9taXNlIiwidXBncmFkZSIsImRiIiwib2xkVmVyc2lvbiIsImNyZWF0ZU9iamVjdFN0b3JlIiwiY29uc29sZSIsImNhdGNoIiwib3JpZ2luYWxFcnJvck1lc3NhZ2UiLCJtZXNzYWdlIiwicmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCIiwidHgiLCJ0cmFuc2FjdGlvbiIsInJlc3VsdCIsIm9iamVjdFN0b3JlIiwiY29tcHV0ZUtleSIsImRvbmUiLCJpZGJHZXRFcnJvciIsIndyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCIiwiaGVhcnRiZWF0T2JqZWN0IiwicHV0IiwiYXBwSWQiLCJNQVhfSEVBREVSX0JZVEVTIiwiU1RPUkVEX0hFQVJUQkVBVF9SRVRFTlRJT05fTUFYX01JTExJUyIsIkhlYXJ0YmVhdFNlcnZpY2VJbXBsIiwiX2hlYXJ0YmVhdHNDYWNoZSIsIl9zdG9yYWdlIiwiSGVhcnRiZWF0U3RvcmFnZUltcGwiLCJfaGVhcnRiZWF0c0NhY2hlUHJvbWlzZSIsInJlYWQiLCJ0aGVuIiwiX2IiLCJwbGF0Zm9ybUxvZ2dlciIsImFnZW50IiwiZGF0ZSIsImdldFVUQ0RhdGVTdHJpbmciLCJoZWFydGJlYXRzIiwibGFzdFNlbnRIZWFydGJlYXREYXRlIiwic29tZSIsInNpbmdsZURhdGVIZWFydGJlYXQiLCJoYlRpbWVzdGFtcCIsIkRhdGUiLCJ2YWx1ZU9mIiwibm93Iiwib3ZlcndyaXRlIiwiZ2V0SGVhcnRiZWF0c0hlYWRlciIsImxlbmd0aCIsImhlYXJ0YmVhdHNUb1NlbmQiLCJ1bnNlbnRFbnRyaWVzIiwiZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIiLCJoZWFkZXJTdHJpbmciLCJ0b2RheSIsInRvSVNPU3RyaW5nIiwic3Vic3RyaW5nIiwiaGVhcnRiZWF0c0NhY2hlIiwibWF4U2l6ZSIsInNsaWNlIiwiaGVhcnRiZWF0RW50cnkiLCJmaW5kIiwiaGIiLCJkYXRlcyIsImNvdW50Qnl0ZXMiLCJwb3AiLCJfY2FuVXNlSW5kZXhlZERCUHJvbWlzZSIsInJ1bkluZGV4ZWREQkVudmlyb25tZW50Q2hlY2siLCJjYW5Vc2VJbmRleGVkREIiLCJpZGJIZWFydGJlYXRPYmplY3QiLCJoZWFydGJlYXRzT2JqZWN0IiwiZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0IiwiYWRkIiwicmVnaXN0ZXJDb3JlQ29tcG9uZW50cyIsIl9ERUZBVUxUX0VOVFJZX05BTUUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/component/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ Component),\n/* harmony export */   ComponentContainer: () => (/* binding */ ComponentContainer),\n/* harmony export */   Provider: () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */ class Component {\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */ constructor(name, instanceFactory, type){\n        this.name = name;\n        this.instanceFactory = instanceFactory;\n        this.type = type;\n        this.multipleInstances = false;\n        /**\r\n         * Properties to be added to the service namespace\r\n         */ this.serviceProps = {};\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */ ;\n        this.onInstanceCreated = null;\n    }\n    setInstantiationMode(mode) {\n        this.instantiationMode = mode;\n        return this;\n    }\n    setMultipleInstances(multipleInstances) {\n        this.multipleInstances = multipleInstances;\n        return this;\n    }\n    setServiceProps(props) {\n        this.serviceProps = props;\n        return this;\n    }\n    setInstanceCreatedCallback(callback) {\n        this.onInstanceCreated = callback;\n        return this;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DEFAULT_ENTRY_NAME = \"[DEFAULT]\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */ class Provider {\n    constructor(name, container){\n        this.name = name;\n        this.container = container;\n        this.component = null;\n        this.instances = new Map();\n        this.instancesDeferred = new Map();\n        this.instancesOptions = new Map();\n        this.onInitCallbacks = new Map();\n    }\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */ get(identifier) {\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\n            const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\n            if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n                // initialize the service if it can be auto-initialized\n                try {\n                    const instance = this.getOrInitializeService({\n                        instanceIdentifier: normalizedIdentifier\n                    });\n                    if (instance) {\n                        deferred.resolve(instance);\n                    }\n                } catch (e) {\n                // when the instance factory throws an exception during get(), it should not cause\n                // a fatal error. We just return the unresolved promise in this case.\n                }\n            }\n        }\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\n    }\n    getImmediate(options) {\n        var _a;\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n        if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n            try {\n                return this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n            } catch (e) {\n                if (optional) {\n                    return null;\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\n            if (optional) {\n                return null;\n            } else {\n                throw Error(`Service ${this.name} is not available`);\n            }\n        }\n    }\n    getComponent() {\n        return this.component;\n    }\n    setComponent(component) {\n        if (component.name !== this.name) {\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n        }\n        if (this.component) {\n            throw Error(`Component for ${this.name} has already been provided`);\n        }\n        this.component = component;\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n        if (!this.shouldAutoInitialize()) {\n            return;\n        }\n        // if the service is eager, initialize the default instance\n        if (isComponentEager(component)) {\n            try {\n                this.getOrInitializeService({\n                    instanceIdentifier: DEFAULT_ENTRY_NAME\n                });\n            } catch (e) {\n            // when the instance factory for an eager Component throws an exception during the eager\n            // initialization, it should not cause a fatal error.\n            // TODO: Investigate if we need to make it configurable, because some component may want to cause\n            // a fatal error in this case?\n            }\n        }\n        // Create service instances for the pending promises and resolve them\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\n        // and all promises with resolve with it regardless of the identifier.\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()){\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            try {\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n                const instance = this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n                instanceDeferred.resolve(instance);\n            } catch (e) {\n            // when the instance factory throws an exception, it should not cause\n            // a fatal error. We just leave the promise unresolved.\n            }\n        }\n    }\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n        this.instancesDeferred.delete(identifier);\n        this.instancesOptions.delete(identifier);\n        this.instances.delete(identifier);\n    }\n    // app.delete() will call this method on every provider to delete the services\n    // TODO: should we mark the provider as deleted?\n    async delete() {\n        const services = Array.from(this.instances.values());\n        await Promise.all([\n            ...services.filter((service)=>\"INTERNAL\" in service) // legacy services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map((service)=>service.INTERNAL.delete()),\n            ...services.filter((service)=>\"_delete\" in service) // modularized services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map((service)=>service._delete())\n        ]);\n    }\n    isComponentSet() {\n        return this.component != null;\n    }\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instances.has(identifier);\n    }\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instancesOptions.get(identifier) || {};\n    }\n    initialize(opts = {}) {\n        const { options = {} } = opts;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n        if (this.isInitialized(normalizedIdentifier)) {\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n        }\n        if (!this.isComponentSet()) {\n            throw Error(`Component ${this.name} has not been registered yet`);\n        }\n        const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier,\n            options\n        });\n        // resolve any pending promise waiting for the service instance\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()){\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\n                instanceDeferred.resolve(instance);\n            }\n        }\n        return instance;\n    }\n    /**\r\n     *\r\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n     *\r\n     * @param identifier An optional instance identifier\r\n     * @returns a function to unregister the callback\r\n     */ onInit(callback, identifier) {\n        var _a;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n        existingCallbacks.add(callback);\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n        const existingInstance = this.instances.get(normalizedIdentifier);\n        if (existingInstance) {\n            callback(existingInstance, normalizedIdentifier);\n        }\n        return ()=>{\n            existingCallbacks.delete(callback);\n        };\n    }\n    /**\r\n     * Invoke onInit callbacks synchronously\r\n     * @param instance the service instance`\r\n     */ invokeOnInitCallbacks(instance, identifier) {\n        const callbacks = this.onInitCallbacks.get(identifier);\n        if (!callbacks) {\n            return;\n        }\n        for (const callback of callbacks){\n            try {\n                callback(instance, identifier);\n            } catch (_a) {\n            // ignore errors in the onInit callback\n            }\n        }\n    }\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\n        let instance = this.instances.get(instanceIdentifier);\n        if (!instance && this.component) {\n            instance = this.component.instanceFactory(this.container, {\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n                options\n            });\n            this.instances.set(instanceIdentifier, instance);\n            this.instancesOptions.set(instanceIdentifier, options);\n            /**\r\n             * Invoke onInit listeners.\r\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n             * while onInit listeners are registered by consumers of the provider.\r\n             */ this.invokeOnInitCallbacks(instance, instanceIdentifier);\n            /**\r\n             * Order is important\r\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n             * makes `isInitialized()` return true.\r\n             */ if (this.component.onInstanceCreated) {\n                try {\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n                } catch (_a) {\n                // ignore errors in the onInstanceCreatedCallback\n                }\n            }\n        }\n        return instance || null;\n    }\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n        if (this.component) {\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n        } else {\n            return identifier; // assume multiple instances are supported before the component is provided.\n        }\n    }\n    shouldAutoInitialize() {\n        return !!this.component && this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */ ;\n    }\n}\n// undefined should be passed to the service factory for the default instance\nfunction normalizeIdentifierForFactory(identifier) {\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\nfunction isComponentEager(component) {\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */ ;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */ class ComponentContainer {\n    constructor(name){\n        this.name = name;\n        this.providers = new Map();\n    }\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */ addComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n        }\n        provider.setComponent(component);\n    }\n    addOrOverwriteComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            // delete the existing provider from the container, so we can register the new component\n            this.providers.delete(component.name);\n        }\n        this.addComponent(component);\n    }\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */ getProvider(name) {\n        if (this.providers.has(name)) {\n            return this.providers.get(name);\n        }\n        // create a Provider for a service that hasn't registered with Firebase\n        const provider = new Provider(name, this);\n        this.providers.set(name, provider);\n        return provider;\n    }\n    getProviders() {\n        return Array.from(this.providers.values());\n    }\n}\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEM7QUFFMUM7O0NBRUMsR0FDRCxNQUFNQztJQUNGOzs7OztLQUtDLEdBQ0RDLFlBQVlDLElBQUksRUFBRUMsZUFBZSxFQUFFQyxJQUFJLENBQUU7UUFDckMsSUFBSSxDQUFDRixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxlQUFlLEdBQUdBO1FBQ3ZCLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekI7O1NBRUMsR0FDRCxJQUFJLENBQUNDLFlBQVksR0FBRyxDQUFDO1FBQ3JCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsT0FBTywwQkFBMEI7UUFDMUQsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztJQUM3QjtJQUNBQyxxQkFBcUJDLElBQUksRUFBRTtRQUN2QixJQUFJLENBQUNILGlCQUFpQixHQUFHRztRQUN6QixPQUFPLElBQUk7SUFDZjtJQUNBQyxxQkFBcUJOLGlCQUFpQixFQUFFO1FBQ3BDLElBQUksQ0FBQ0EsaUJBQWlCLEdBQUdBO1FBQ3pCLE9BQU8sSUFBSTtJQUNmO0lBQ0FPLGdCQUFnQkMsS0FBSyxFQUFFO1FBQ25CLElBQUksQ0FBQ1AsWUFBWSxHQUFHTztRQUNwQixPQUFPLElBQUk7SUFDZjtJQUNBQywyQkFBMkJDLFFBQVEsRUFBRTtRQUNqQyxJQUFJLENBQUNQLGlCQUFpQixHQUFHTztRQUN6QixPQUFPLElBQUk7SUFDZjtBQUNKO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTUMscUJBQXFCO0FBRTNCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEOzs7Q0FHQyxHQUNELE1BQU1DO0lBQ0ZoQixZQUFZQyxJQUFJLEVBQUVnQixTQUFTLENBQUU7UUFDekIsSUFBSSxDQUFDaEIsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2dC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T0FBT0E7SUFDWDtJQUNBRyxlQUFlO1FBQ1gsT0FBTzlCLE1BQU1DLElBQUksQ0FBQyxJQUFJLENBQUN3QixTQUFTLENBQUN2QixNQUFNO0lBQzNDO0FBQ0o7QUFFbUQsQ0FDbkQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2lnYXNwYW5kdS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvY29tcG9uZW50L2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanM/MjQzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuLyoqXHJcbiAqIENvbXBvbmVudCBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gYGF1dGhgLCBgYXV0aC1pbnRlcm5hbGBcclxuICovXHJcbmNsYXNzIENvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgcHVibGljIHNlcnZpY2UgbmFtZSwgZS5nLiBhcHAsIGF1dGgsIGZpcmVzdG9yZSwgZGF0YWJhc2VcclxuICAgICAqIEBwYXJhbSBpbnN0YW5jZUZhY3RvcnkgU2VydmljZSBmYWN0b3J5IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgcHVibGljIGludGVyZmFjZVxyXG4gICAgICogQHBhcmFtIHR5cGUgd2hldGhlciB0aGUgc2VydmljZSBwcm92aWRlZCBieSB0aGUgY29tcG9uZW50IGlzIHB1YmxpYyBvciBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGluc3RhbmNlRmFjdG9yeSwgdHlwZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZUZhY3RvcnkgPSBpbnN0YW5jZUZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGVydGllcyB0byBiZSBhZGRlZCB0byB0aGUgc2VydmljZSBuYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBcIkxBWllcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5MQVpZICovO1xyXG4gICAgICAgIHRoaXMub25JbnN0YW5jZUNyZWF0ZWQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgc2V0SW5zdGFudGlhdGlvbk1vZGUobW9kZSkge1xyXG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBtb2RlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0TXVsdGlwbGVJbnN0YW5jZXMobXVsdGlwbGVJbnN0YW5jZXMpIHtcclxuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gbXVsdGlwbGVJbnN0YW5jZXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzZXRTZXJ2aWNlUHJvcHMocHJvcHMpIHtcclxuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHByb3BzO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0SW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLm9uSW5zdGFuY2VDcmVhdGVkID0gY2FsbGJhY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlciBmb3IgaW5zdGFuY2UgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuICdhdXRoJywgJ2F1dGgtaW50ZXJuYWwnXHJcbiAqIE5hbWVTZXJ2aWNlTWFwcGluZ1tUXSBpcyBhbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgdGhlIGluc3RhbmNlXHJcbiAqL1xyXG5jbGFzcyBQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzT3B0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQSBwcm92aWRlciBjYW4gcHJvdmlkZSBtdWxpdHBsZSBpbnN0YW5jZXMgb2YgYSBzZXJ2aWNlXHJcbiAgICAgKiBpZiB0aGlzLmNvbXBvbmVudC5tdWx0aXBsZUluc3RhbmNlcyBpcyB0cnVlLlxyXG4gICAgICovXHJcbiAgICBnZXQoaWRlbnRpZmllcikge1xyXG4gICAgICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuaGFzKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZGVmZXJyZWQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzZXJ2aWNlIGlmIGl0IGNhbiBiZSBhdXRvLWluaXRpYWxpemVkXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllclxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgZ2V0KCksIGl0IHNob3VsZCBub3QgY2F1c2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IHJldHVybiB0aGUgdW5yZXNvbHZlZCBwcm9taXNlIGluIHRoaXMgY2FzZS5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICBnZXRJbW1lZGlhdGUob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAvLyBpZiBtdWx0aXBsZUluc3RhbmNlcyBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGhlIGRlZmF1bHQgbmFtZVxyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlkZW50aWZpZXIpO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbmFsID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wdGlvbmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxyXG4gICAgICAgICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEluIGNhc2UgYSBjb21wb25lbnQgaXMgbm90IGluaXRpYWxpemVkIGFuZCBzaG91bGQvY2FuIG5vdCBiZSBhdXRvLWluaXRpYWxpemVkIGF0IHRoZSBtb21lbnQsIHJldHVybiBudWxsIGlmIHRoZSBvcHRpb25hbCBmbGFnIGlzIHNldCwgb3IgdGhyb3dcclxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBTZXJ2aWNlICR7dGhpcy5uYW1lfSBpcyBub3QgYXZhaWxhYmxlYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50O1xyXG4gICAgfVxyXG4gICAgc2V0Q29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGlmIChjb21wb25lbnQubmFtZSAhPT0gdGhpcy5uYW1lKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBNaXNtYXRjaGluZyBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gZm9yIFByb3ZpZGVyICR7dGhpcy5uYW1lfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgZm9yICR7dGhpcy5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIHByb3ZpZGVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIC8vIHJldHVybiBlYXJseSB3aXRob3V0IGF0dGVtcHRpbmcgdG8gaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50IGlmIHRoZSBjb21wb25lbnQgcmVxdWlyZXMgZXhwbGljaXQgaW5pdGlhbGl6YXRpb24gKGNhbGxpbmcgYFByb3ZpZGVyLmluaXRpYWxpemUoKWApXHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgc2VydmljZSBpcyBlYWdlciwgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZVxyXG4gICAgICAgIGlmIChpc0NvbXBvbmVudEVhZ2VyKGNvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7IGluc3RhbmNlSWRlbnRpZmllcjogREVGQVVMVF9FTlRSWV9OQU1FIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IGZvciBhbiBlYWdlciBDb21wb25lbnQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgdGhlIGVhZ2VyXHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXphdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZSBhIGZhdGFsIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgaWYgd2UgbmVlZCB0byBtYWtlIGl0IGNvbmZpZ3VyYWJsZSwgYmVjYXVzZSBzb21lIGNvbXBvbmVudCBtYXkgd2FudCB0byBjYXVzZVxyXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvciBpbiB0aGlzIGNhc2U/XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ3JlYXRlIHNlcnZpY2UgaW5zdGFuY2VzIGZvciB0aGUgcGVuZGluZyBwcm9taXNlcyBhbmQgcmVzb2x2ZSB0aGVtXHJcbiAgICAgICAgLy8gTk9URTogaWYgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyBpcyBmYWxzZSwgb25seSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWRcclxuICAgICAgICAvLyBhbmQgYWxsIHByb21pc2VzIHdpdGggcmVzb2x2ZSB3aXRoIGl0IHJlZ2FyZGxlc3Mgb2YgdGhlIGlkZW50aWZpZXIuXHJcbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBgZ2V0T3JJbml0aWFsaXplU2VydmljZSgpYCBzaG91bGQgYWx3YXlzIHJldHVybiBhIHZhbGlkIGluc3RhbmNlIHNpbmNlIGEgY29tcG9uZW50IGlzIGd1YXJhbnRlZWQuIHVzZSAhIHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZVxyXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvci4gV2UganVzdCBsZWF2ZSB0aGUgcHJvbWlzZSB1bnJlc29sdmVkLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXJJbnN0YW5jZShpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5kZWxldGUoaWRlbnRpZmllcik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNPcHRpb25zLmRlbGV0ZShpZGVudGlmaWVyKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlcy5kZWxldGUoaWRlbnRpZmllcik7XHJcbiAgICB9XHJcbiAgICAvLyBhcHAuZGVsZXRlKCkgd2lsbCBjYWxsIHRoaXMgbWV0aG9kIG9uIGV2ZXJ5IHByb3ZpZGVyIHRvIGRlbGV0ZSB0aGUgc2VydmljZXNcclxuICAgIC8vIFRPRE86IHNob3VsZCB3ZSBtYXJrIHRoZSBwcm92aWRlciBhcyBkZWxldGVkP1xyXG4gICAgYXN5bmMgZGVsZXRlKCkge1xyXG4gICAgICAgIGNvbnN0IHNlcnZpY2VzID0gQXJyYXkuZnJvbSh0aGlzLmluc3RhbmNlcy52YWx1ZXMoKSk7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAuLi5zZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdJTlRFUk5BTCcgaW4gc2VydmljZSkgLy8gbGVnYWN5IHNlcnZpY2VzXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgLm1hcChzZXJ2aWNlID0+IHNlcnZpY2UuSU5URVJOQUwuZGVsZXRlKCkpLFxyXG4gICAgICAgICAgICAuLi5zZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdfZGVsZXRlJyBpbiBzZXJ2aWNlKSAvLyBtb2R1bGFyaXplZCBzZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIC5tYXAoc2VydmljZSA9PiBzZXJ2aWNlLl9kZWxldGUoKSlcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGlzQ29tcG9uZW50U2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudCAhPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaXNJbml0aWFsaXplZChpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzLmhhcyhpZGVudGlmaWVyKTtcclxuICAgIH1cclxuICAgIGdldE9wdGlvbnMoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlc09wdGlvbnMuZ2V0KGlkZW50aWZpZXIpIHx8IHt9O1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShvcHRzID0ge30pIHtcclxuICAgICAgICBjb25zdCB7IG9wdGlvbnMgPSB7fSB9ID0gb3B0cztcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKG9wdHMuaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgJHt0aGlzLm5hbWV9KCR7bm9ybWFsaXplZElkZW50aWZpZXJ9KSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pc0NvbXBvbmVudFNldCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgJHt0aGlzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XHJcbiAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXIsXHJcbiAgICAgICAgICAgIG9wdGlvbnNcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyByZXNvbHZlIGFueSBwZW5kaW5nIHByb21pc2Ugd2FpdGluZyBmb3IgdGhlIHNlcnZpY2UgaW5zdGFuY2VcclxuICAgICAgICBmb3IgKGNvbnN0IFtpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlRGVmZXJyZWRdIG9mIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZElkZW50aWZpZXIgPT09IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCAgYWZ0ZXIgdGhlIHByb3ZpZGVyIGhhcyBiZWVuIGluaXRpYWxpemVkIGJ5IGNhbGxpbmcgcHJvdmlkZXIuaW5pdGlhbGl6ZSgpLlxyXG4gICAgICogVGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgU1lOQ0hST05PVVNMWSwgc28gaXQgc2hvdWxkIG5vdCBleGVjdXRlIGFueSBsb25ncnVubmluZyB0YXNrcyBpbiBvcmRlciB0byBub3QgYmxvY2sgdGhlIHByb2dyYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQW4gb3B0aW9uYWwgaW5zdGFuY2UgaWRlbnRpZmllclxyXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0byB1bnJlZ2lzdGVyIHRoZSBjYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBvbkluaXQoY2FsbGJhY2ssIGlkZW50aWZpZXIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ0NhbGxiYWNrcyA9IChfYSA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChub3JtYWxpemVkSWRlbnRpZmllcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBTZXQoKTtcclxuICAgICAgICBleGlzdGluZ0NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xyXG4gICAgICAgIHRoaXMub25Jbml0Q2FsbGJhY2tzLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZXhpc3RpbmdDYWxsYmFja3MpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpO1xyXG4gICAgICAgIGlmIChleGlzdGluZ0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGV4aXN0aW5nSW5zdGFuY2UsIG5vcm1hbGl6ZWRJZGVudGlmaWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZXhpc3RpbmdDYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2Ugb25Jbml0IGNhbGxiYWNrcyBzeW5jaHJvbm91c2x5XHJcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2UgdGhlIHNlcnZpY2UgaW5zdGFuY2VgXHJcbiAgICAgKi9cclxuICAgIGludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaWRlbnRpZmllcikge1xyXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChpZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoIWNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpbnN0YW5jZSwgaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluaXQgY2FsbGJhY2tcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoeyBpbnN0YW5jZUlkZW50aWZpZXIsIG9wdGlvbnMgPSB7fSB9KSB7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZXMuZ2V0KGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZSAmJiB0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZSA9IHRoaXMuY29tcG9uZW50Lmluc3RhbmNlRmFjdG9yeSh0aGlzLmNvbnRhaW5lciwge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVJZGVudGlmaWVyRm9yRmFjdG9yeShpbnN0YW5jZUlkZW50aWZpZXIpLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbnZva2Ugb25Jbml0IGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICogTm90ZSB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCBpcyBkaWZmZXJlbnQsIHdoaWNoIGlzIHVzZWQgYnkgdGhlIGNvbXBvbmVudCBjcmVhdG9yLFxyXG4gICAgICAgICAgICAgKiB3aGlsZSBvbkluaXQgbGlzdGVuZXJzIGFyZSByZWdpc3RlcmVkIGJ5IGNvbnN1bWVycyBvZiB0aGUgcHJvdmlkZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9yZGVyIGlzIGltcG9ydGFudFxyXG4gICAgICAgICAgICAgKiBvbkluc3RhbmNlQ3JlYXRlZCgpIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpOyB3aGljaFxyXG4gICAgICAgICAgICAgKiBtYWtlcyBgaXNJbml0aWFsaXplZCgpYCByZXR1cm4gdHJ1ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCh0aGlzLmNvbnRhaW5lciwgaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluc3RhbmNlQ3JlYXRlZENhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQubXVsdGlwbGVJbnN0YW5jZXMgPyBpZGVudGlmaWVyIDogREVGQVVMVF9FTlRSWV9OQU1FO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7IC8vIGFzc3VtZSBtdWx0aXBsZSBpbnN0YW5jZXMgYXJlIHN1cHBvcnRlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBwcm92aWRlZC5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzaG91bGRBdXRvSW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICByZXR1cm4gKCEhdGhpcy5jb21wb25lbnQgJiZcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgIT09IFwiRVhQTElDSVRcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVCAqLyk7XHJcbiAgICB9XHJcbn1cclxuLy8gdW5kZWZpbmVkIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHNlcnZpY2UgZmFjdG9yeSBmb3IgdGhlIGRlZmF1bHQgaW5zdGFuY2VcclxuZnVuY3Rpb24gbm9ybWFsaXplSWRlbnRpZmllckZvckZhY3RvcnkoaWRlbnRpZmllcikge1xyXG4gICAgcmV0dXJuIGlkZW50aWZpZXIgPT09IERFRkFVTFRfRU5UUllfTkFNRSA/IHVuZGVmaW5lZCA6IGlkZW50aWZpZXI7XHJcbn1cclxuZnVuY3Rpb24gaXNDb21wb25lbnRFYWdlcihjb21wb25lbnQpIHtcclxuICAgIHJldHVybiBjb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgPT09IFwiRUFHRVJcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FQUdFUiAqLztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29tcG9uZW50Q29udGFpbmVyIHRoYXQgcHJvdmlkZXMgUHJvdmlkZXJzIGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiBgYXV0aGAsIGBhdXRoLWludGVybmFsYFxyXG4gKi9cclxuY2xhc3MgQ29tcG9uZW50Q29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCBDb21wb25lbnQgYmVpbmcgYWRkZWRcclxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgV2hlbiBhIGNvbXBvbmVudCB3aXRoIHRoZSBzYW1lIG5hbWUgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLFxyXG4gICAgICogaWYgb3ZlcndyaXRlIGlzIHRydWU6IG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgY29tcG9uZW50IHdpdGggdGhlIG5ldyBjb21wb25lbnQgYW5kIGNyZWF0ZSBhIG5ld1xyXG4gICAgICogcHJvdmlkZXIgd2l0aCB0aGUgbmV3IGNvbXBvbmVudC4gSXQgY2FuIGJlIHVzZWZ1bCBpbiB0ZXN0cyB3aGVyZSB5b3Ugd2FudCB0byB1c2UgZGlmZmVyZW50IG1vY2tzXHJcbiAgICAgKiBmb3IgZGlmZmVyZW50IHRlc3RzLlxyXG4gICAgICogaWYgb3ZlcndyaXRlIGlzIGZhbHNlOiB0aHJvdyBhbiBleGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgYWRkQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihjb21wb25lbnQubmFtZSk7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyLmlzQ29tcG9uZW50U2V0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIHdpdGggJHt0aGlzLm5hbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3ZpZGVyLnNldENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKGNvbXBvbmVudC5uYW1lKTtcclxuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xyXG4gICAgICAgICAgICAvLyBkZWxldGUgdGhlIGV4aXN0aW5nIHByb3ZpZGVyIGZyb20gdGhlIGNvbnRhaW5lciwgc28gd2UgY2FuIHJlZ2lzdGVyIHRoZSBuZXcgY29tcG9uZW50XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLmRlbGV0ZShjb21wb25lbnQubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGdldFByb3ZpZGVyIHByb3ZpZGVzIGEgdHlwZSBzYWZlIGludGVyZmFjZSB3aGVyZSBpdCBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIGZpZWxkIG5hbWVcclxuICAgICAqIHByZXNlbnQgaW4gTmFtZVNlcnZpY2VNYXBwaW5nIGludGVyZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBGaXJlYmFzZSBTREtzIHByb3ZpZGluZyBzZXJ2aWNlcyBzaG91bGQgZXh0ZW5kIE5hbWVTZXJ2aWNlTWFwcGluZyBpbnRlcmZhY2UgdG8gcmVnaXN0ZXJcclxuICAgICAqIHRoZW1zZWx2ZXMuXHJcbiAgICAgKi9cclxuICAgIGdldFByb3ZpZGVyKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm92aWRlcnMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVycy5nZXQobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNyZWF0ZSBhIFByb3ZpZGVyIGZvciBhIHNlcnZpY2UgdGhhdCBoYXNuJ3QgcmVnaXN0ZXJlZCB3aXRoIEZpcmViYXNlXHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIobmFtZSwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5hbWUsIHByb3ZpZGVyKTtcclxuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XHJcbiAgICB9XHJcbiAgICBnZXRQcm92aWRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wcm92aWRlcnMudmFsdWVzKCkpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50Q29udGFpbmVyLCBQcm92aWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJEZWZlcnJlZCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwibmFtZSIsImluc3RhbmNlRmFjdG9yeSIsInR5cGUiLCJtdWx0aXBsZUluc3RhbmNlcyIsInNlcnZpY2VQcm9wcyIsImluc3RhbnRpYXRpb25Nb2RlIiwib25JbnN0YW5jZUNyZWF0ZWQiLCJzZXRJbnN0YW50aWF0aW9uTW9kZSIsIm1vZGUiLCJzZXRNdWx0aXBsZUluc3RhbmNlcyIsInNldFNlcnZpY2VQcm9wcyIsInByb3BzIiwic2V0SW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2siLCJjYWxsYmFjayIsIkRFRkFVTFRfRU5UUllfTkFNRSIsIlByb3ZpZGVyIiwiY29udGFpbmVyIiwiY29tcG9uZW50IiwiaW5zdGFuY2VzIiwiTWFwIiwiaW5zdGFuY2VzRGVmZXJyZWQiLCJpbnN0YW5jZXNPcHRpb25zIiwib25Jbml0Q2FsbGJhY2tzIiwiZ2V0IiwiaWRlbnRpZmllciIsIm5vcm1hbGl6ZWRJZGVudGlmaWVyIiwibm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyIiwiaGFzIiwiZGVmZXJyZWQiLCJzZXQiLCJpc0luaXRpYWxpemVkIiwic2hvdWxkQXV0b0luaXRpYWxpemUiLCJpbnN0YW5jZSIsImdldE9ySW5pdGlhbGl6ZVNlcnZpY2UiLCJpbnN0YW5jZUlkZW50aWZpZXIiLCJyZXNvbHZlIiwiZSIsInByb21pc2UiLCJnZXRJbW1lZGlhdGUiLCJvcHRpb25zIiwiX2EiLCJvcHRpb25hbCIsIkVycm9yIiwiZ2V0Q29tcG9uZW50Iiwic2V0Q29tcG9uZW50IiwiaXNDb21wb25lbnRFYWdlciIsImluc3RhbmNlRGVmZXJyZWQiLCJlbnRyaWVzIiwiY2xlYXJJbnN0YW5jZSIsImRlbGV0ZSIsInNlcnZpY2VzIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiUHJvbWlzZSIsImFsbCIsImZpbHRlciIsInNlcnZpY2UiLCJtYXAiLCJJTlRFUk5BTCIsIl9kZWxldGUiLCJpc0NvbXBvbmVudFNldCIsImdldE9wdGlvbnMiLCJpbml0aWFsaXplIiwib3B0cyIsIm5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIiLCJvbkluaXQiLCJleGlzdGluZ0NhbGxiYWNrcyIsIlNldCIsImFkZCIsImV4aXN0aW5nSW5zdGFuY2UiLCJpbnZva2VPbkluaXRDYWxsYmFja3MiLCJjYWxsYmFja3MiLCJub3JtYWxpemVJZGVudGlmaWVyRm9yRmFjdG9yeSIsInVuZGVmaW5lZCIsIkNvbXBvbmVudENvbnRhaW5lciIsInByb3ZpZGVycyIsImFkZENvbXBvbmVudCIsInByb3ZpZGVyIiwiZ2V0UHJvdmlkZXIiLCJhZGRPck92ZXJ3cml0ZUNvbXBvbmVudCIsImdldFByb3ZpZGVycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/firestore/dist/lite/index.node.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@firebase/firestore/dist/lite/index.node.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AggregateField: () => (/* binding */ AggregateField),\n/* harmony export */   AggregateQuerySnapshot: () => (/* binding */ AggregateQuerySnapshot),\n/* harmony export */   Bytes: () => (/* binding */ Bytes),\n/* harmony export */   CollectionReference: () => (/* binding */ CollectionReference),\n/* harmony export */   DocumentReference: () => (/* binding */ DocumentReference),\n/* harmony export */   DocumentSnapshot: () => (/* binding */ DocumentSnapshot),\n/* harmony export */   FieldPath: () => (/* binding */ FieldPath),\n/* harmony export */   FieldValue: () => (/* binding */ FieldValue),\n/* harmony export */   Firestore: () => (/* binding */ Firestore),\n/* harmony export */   FirestoreError: () => (/* binding */ FirestoreError),\n/* harmony export */   GeoPoint: () => (/* binding */ GeoPoint),\n/* harmony export */   Query: () => (/* binding */ Query),\n/* harmony export */   QueryCompositeFilterConstraint: () => (/* binding */ QueryCompositeFilterConstraint),\n/* harmony export */   QueryConstraint: () => (/* binding */ QueryConstraint),\n/* harmony export */   QueryDocumentSnapshot: () => (/* binding */ QueryDocumentSnapshot),\n/* harmony export */   QueryEndAtConstraint: () => (/* binding */ QueryEndAtConstraint),\n/* harmony export */   QueryFieldFilterConstraint: () => (/* binding */ QueryFieldFilterConstraint),\n/* harmony export */   QueryLimitConstraint: () => (/* binding */ QueryLimitConstraint),\n/* harmony export */   QueryOrderByConstraint: () => (/* binding */ QueryOrderByConstraint),\n/* harmony export */   QuerySnapshot: () => (/* binding */ QuerySnapshot),\n/* harmony export */   QueryStartAtConstraint: () => (/* binding */ QueryStartAtConstraint),\n/* harmony export */   Timestamp: () => (/* binding */ Timestamp),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   WriteBatch: () => (/* binding */ WriteBatch),\n/* harmony export */   addDoc: () => (/* binding */ addDoc),\n/* harmony export */   aggregateFieldEqual: () => (/* binding */ aggregateFieldEqual),\n/* harmony export */   aggregateQuerySnapshotEqual: () => (/* binding */ aggregateQuerySnapshotEqual),\n/* harmony export */   and: () => (/* binding */ and),\n/* harmony export */   arrayRemove: () => (/* binding */ arrayRemove),\n/* harmony export */   arrayUnion: () => (/* binding */ arrayUnion),\n/* harmony export */   average: () => (/* binding */ average),\n/* harmony export */   collection: () => (/* binding */ collection),\n/* harmony export */   collectionGroup: () => (/* binding */ collectionGroup),\n/* harmony export */   connectFirestoreEmulator: () => (/* binding */ connectFirestoreEmulator),\n/* harmony export */   count: () => (/* binding */ count),\n/* harmony export */   deleteDoc: () => (/* binding */ deleteDoc),\n/* harmony export */   deleteField: () => (/* binding */ deleteField),\n/* harmony export */   doc: () => (/* binding */ doc),\n/* harmony export */   documentId: () => (/* binding */ documentId),\n/* harmony export */   endAt: () => (/* binding */ endAt),\n/* harmony export */   endBefore: () => (/* binding */ endBefore),\n/* harmony export */   getAggregate: () => (/* binding */ getAggregate),\n/* harmony export */   getCount: () => (/* binding */ getCount),\n/* harmony export */   getDoc: () => (/* binding */ getDoc),\n/* harmony export */   getDocs: () => (/* binding */ getDocs),\n/* harmony export */   getFirestore: () => (/* binding */ getFirestore),\n/* harmony export */   increment: () => (/* binding */ increment),\n/* harmony export */   initializeFirestore: () => (/* binding */ initializeFirestore),\n/* harmony export */   limit: () => (/* binding */ limit),\n/* harmony export */   limitToLast: () => (/* binding */ limitToLast),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   orderBy: () => (/* binding */ orderBy),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   queryEqual: () => (/* binding */ queryEqual),\n/* harmony export */   refEqual: () => (/* binding */ refEqual),\n/* harmony export */   runTransaction: () => (/* binding */ runTransaction),\n/* harmony export */   serverTimestamp: () => (/* binding */ serverTimestamp),\n/* harmony export */   setDoc: () => (/* binding */ setDoc),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   snapshotEqual: () => (/* binding */ snapshotEqual),\n/* harmony export */   startAfter: () => (/* binding */ startAfter),\n/* harmony export */   startAt: () => (/* binding */ startAt),\n/* harmony export */   sum: () => (/* binding */ sum),\n/* harmony export */   terminate: () => (/* binding */ terminate),\n/* harmony export */   updateDoc: () => (/* binding */ updateDoc),\n/* harmony export */   where: () => (/* binding */ where),\n/* harmony export */   writeBatch: () => (/* binding */ writeBatch)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! undici */ \"(ssr)/./node_modules/undici/index.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! crypto */ \"crypto\");\n\n\n\n\n\n\n\nconst version$1 = \"4.6.1\";\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Simple wrapper around a nullable UID. Mostly exists to make code more\r\n * readable.\r\n */ class User {\n    constructor(uid){\n        this.uid = uid;\n    }\n    isAuthenticated() {\n        return this.uid != null;\n    }\n    /**\r\n     * Returns a key representing this user, suitable for inclusion in a\r\n     * dictionary.\r\n     */ toKey() {\n        if (this.isAuthenticated()) {\n            return \"uid:\" + this.uid;\n        } else {\n            return \"anonymous-user\";\n        }\n    }\n    isEqual(otherUser) {\n        return otherUser.uid === this.uid;\n    }\n}\n/** A user with a null UID. */ User.UNAUTHENTICATED = new User(null);\n// TODO(mikelehen): Look into getting a proper uid-equivalent for\n// non-FirebaseAuth providers.\nUser.GOOGLE_CREDENTIALS = new User(\"google-credentials-uid\");\nUser.FIRST_PARTY = new User(\"first-party-uid\");\nUser.MOCK_USER = new User(\"mock-user\");\nconst version = \"10.11.1\";\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let SDK_VERSION = version;\nfunction setSDKVersion(version) {\n    SDK_VERSION = version;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** Formats an object as a JSON string, suitable for logging. */ function formatJSON(value) {\n    // util.inspect() results in much more readable output than JSON.stringify()\n    return (0,util__WEBPACK_IMPORTED_MODULE_3__.inspect)(value, {\n        depth: 100\n    });\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.Logger(\"@firebase/firestore\");\n/**\r\n * Sets the verbosity of Cloud Firestore logs (debug, error, or silent).\r\n *\r\n * @param logLevel - The verbosity you set for activity and error logging. Can\r\n *   be any of the following values:\r\n *\r\n *   <ul>\r\n *     <li>`debug` for the most verbose logging level, primarily for\r\n *     debugging.</li>\r\n *     <li>`error` to log errors only.</li>\r\n *     <li><code>`silent` to turn off logging.</li>\r\n *   </ul>\r\n */ function setLogLevel(logLevel) {\n    logClient.setLogLevel(logLevel);\n}\nfunction logDebug(msg, ...obj) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n        const args = obj.map(argToString);\n        logClient.debug(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n    }\n}\nfunction logError(msg, ...obj) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.ERROR) {\n        const args = obj.map(argToString);\n        logClient.error(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n    }\n}\n/**\r\n * @internal\r\n */ function logWarn(msg, ...obj) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.WARN) {\n        const args = obj.map(argToString);\n        logClient.warn(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n    }\n}\n/**\r\n * Converts an additional log parameter to a string representation.\r\n */ function argToString(obj) {\n    if (typeof obj === \"string\") {\n        return obj;\n    } else {\n        try {\n            return formatJSON(obj);\n        } catch (e) {\n            // Converting to JSON failed, just log the object directly\n            return obj;\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Unconditionally fails, throwing an Error with the given message.\r\n * Messages are stripped in production builds.\r\n *\r\n * Returns `never` and can be used in expressions:\r\n * @example\r\n * let futureVar = fail('not implemented yet');\r\n */ function fail(failure = \"Unexpected state\") {\n    // Log the failure in addition to throw an exception, just in case the\n    // exception is swallowed.\n    const message = `FIRESTORE (${SDK_VERSION}) INTERNAL ASSERTION FAILED: ` + failure;\n    logError(message);\n    // NOTE: We don't use FirestoreError here because these are internal failures\n    // that cannot be handled by the user. (Also it would create a circular\n    // dependency between the error and assert modules which doesn't work.)\n    throw new Error(message);\n}\n/**\r\n * Fails if the given assertion condition is false, throwing an Error with the\r\n * given message if it did.\r\n *\r\n * Messages are stripped in production builds.\r\n */ function hardAssert(assertion, message) {\n    if (!assertion) {\n        fail();\n    }\n}\n/**\r\n * Casts `obj` to `T`. In non-production builds, verifies that `obj` is an\r\n * instance of `T` before casting.\r\n */ function debugCast(obj, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nconstructor) {\n    return obj;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const Code = {\n    // Causes are copied from:\n    // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n    /** Not an error; returned on success. */ OK: \"ok\",\n    /** The operation was cancelled (typically by the caller). */ CANCELLED: \"cancelled\",\n    /** Unknown error or an error from a different error domain. */ UNKNOWN: \"unknown\",\n    /**\r\n     * Client specified an invalid argument. Note that this differs from\r\n     * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\r\n     * problematic regardless of the state of the system (e.g., a malformed file\r\n     * name).\r\n     */ INVALID_ARGUMENT: \"invalid-argument\",\n    /**\r\n     * Deadline expired before operation could complete. For operations that\r\n     * change the state of the system, this error may be returned even if the\r\n     * operation has completed successfully. For example, a successful response\r\n     * from a server could have been delayed long enough for the deadline to\r\n     * expire.\r\n     */ DEADLINE_EXCEEDED: \"deadline-exceeded\",\n    /** Some requested entity (e.g., file or directory) was not found. */ NOT_FOUND: \"not-found\",\n    /**\r\n     * Some entity that we attempted to create (e.g., file or directory) already\r\n     * exists.\r\n     */ ALREADY_EXISTS: \"already-exists\",\n    /**\r\n     * The caller does not have permission to execute the specified operation.\r\n     * PERMISSION_DENIED must not be used for rejections caused by exhausting\r\n     * some resource (use RESOURCE_EXHAUSTED instead for those errors).\r\n     * PERMISSION_DENIED must not be used if the caller can not be identified\r\n     * (use UNAUTHENTICATED instead for those errors).\r\n     */ PERMISSION_DENIED: \"permission-denied\",\n    /**\r\n     * The request does not have valid authentication credentials for the\r\n     * operation.\r\n     */ UNAUTHENTICATED: \"unauthenticated\",\n    /**\r\n     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the\r\n     * entire file system is out of space.\r\n     */ RESOURCE_EXHAUSTED: \"resource-exhausted\",\n    /**\r\n     * Operation was rejected because the system is not in a state required for\r\n     * the operation's execution. For example, directory to be deleted may be\r\n     * non-empty, an rmdir operation is applied to a non-directory, etc.\r\n     *\r\n     * A litmus test that may help a service implementor in deciding\r\n     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\r\n     *  (a) Use UNAVAILABLE if the client can retry just the failing call.\r\n     *  (b) Use ABORTED if the client should retry at a higher-level\r\n     *      (e.g., restarting a read-modify-write sequence).\r\n     *  (c) Use FAILED_PRECONDITION if the client should not retry until\r\n     *      the system state has been explicitly fixed. E.g., if an \"rmdir\"\r\n     *      fails because the directory is non-empty, FAILED_PRECONDITION\r\n     *      should be returned since the client should not retry unless\r\n     *      they have first fixed up the directory by deleting files from it.\r\n     *  (d) Use FAILED_PRECONDITION if the client performs conditional\r\n     *      REST Get/Update/Delete on a resource and the resource on the\r\n     *      server does not match the condition. E.g., conflicting\r\n     *      read-modify-write on the same resource.\r\n     */ FAILED_PRECONDITION: \"failed-precondition\",\n    /**\r\n     * The operation was aborted, typically due to a concurrency issue like\r\n     * sequencer check failures, transaction aborts, etc.\r\n     *\r\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\r\n     * and UNAVAILABLE.\r\n     */ ABORTED: \"aborted\",\n    /**\r\n     * Operation was attempted past the valid range. E.g., seeking or reading\r\n     * past end of file.\r\n     *\r\n     * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\r\n     * if the system state changes. For example, a 32-bit file system will\r\n     * generate INVALID_ARGUMENT if asked to read at an offset that is not in the\r\n     * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\r\n     * an offset past the current file size.\r\n     *\r\n     * There is a fair bit of overlap between FAILED_PRECONDITION and\r\n     * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\r\n     * when it applies so that callers who are iterating through a space can\r\n     * easily look for an OUT_OF_RANGE error to detect when they are done.\r\n     */ OUT_OF_RANGE: \"out-of-range\",\n    /** Operation is not implemented or not supported/enabled in this service. */ UNIMPLEMENTED: \"unimplemented\",\n    /**\r\n     * Internal errors. Means some invariants expected by underlying System has\r\n     * been broken. If you see one of these errors, Something is very broken.\r\n     */ INTERNAL: \"internal\",\n    /**\r\n     * The service is currently unavailable. This is a most likely a transient\r\n     * condition and may be corrected by retrying with a backoff.\r\n     *\r\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\r\n     * and UNAVAILABLE.\r\n     */ UNAVAILABLE: \"unavailable\",\n    /** Unrecoverable data loss or corruption. */ DATA_LOSS: \"data-loss\"\n};\n/** An error returned by a Firestore operation. */ class FirestoreError extends _firebase_util__WEBPACK_IMPORTED_MODULE_4__.FirebaseError {\n    /** @hideconstructor */ constructor(/**\r\n     * The backend error code associated with this error.\r\n     */ code, /**\r\n     * A custom error description.\r\n     */ message){\n        super(code, message);\n        this.code = code;\n        this.message = message;\n        // HACK: We write a toString property directly because Error is not a real\n        // class and so inheritance does not work correctly. We could alternatively\n        // do the same \"back-door inheritance\" trick that FirebaseError does.\n        this.toString = ()=>`${this.name}: [code=${this.code}]: ${this.message}`;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Deferred {\n    constructor(){\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class OAuthToken {\n    constructor(value, user){\n        this.user = user;\n        this.type = \"OAuth\";\n        this.headers = new Map();\n        this.headers.set(\"Authorization\", `Bearer ${value}`);\n    }\n}\n/**\r\n * A CredentialsProvider that always yields an empty token.\r\n * @internal\r\n */ class EmptyAuthCredentialsProvider {\n    getToken() {\n        return Promise.resolve(null);\n    }\n    invalidateToken() {}\n    start(asyncQueue, changeListener) {\n        // Fire with initial user.\n        asyncQueue.enqueueRetryable(()=>changeListener(User.UNAUTHENTICATED));\n    }\n    shutdown() {}\n}\n/**\r\n * A CredentialsProvider that always returns a constant token. Used for\r\n * emulator token mocking.\r\n */ class EmulatorAuthCredentialsProvider {\n    constructor(token){\n        this.token = token;\n        /**\r\n         * Stores the listener registered with setChangeListener()\r\n         * This isn't actually necessary since the UID never changes, but we use this\r\n         * to verify the listen contract is adhered to in tests.\r\n         */ this.changeListener = null;\n    }\n    getToken() {\n        return Promise.resolve(this.token);\n    }\n    invalidateToken() {}\n    start(asyncQueue, changeListener) {\n        this.changeListener = changeListener;\n        // Fire with initial user.\n        asyncQueue.enqueueRetryable(()=>changeListener(this.token.user));\n    }\n    shutdown() {\n        this.changeListener = null;\n    }\n}\n/** Credential provider for the Lite SDK. */ class LiteAuthCredentialsProvider {\n    constructor(authProvider){\n        this.auth = null;\n        authProvider.onInit((auth)=>{\n            this.auth = auth;\n        });\n    }\n    getToken() {\n        if (!this.auth) {\n            return Promise.resolve(null);\n        }\n        return this.auth.getToken().then((tokenData)=>{\n            if (tokenData) {\n                hardAssert(typeof tokenData.accessToken === \"string\");\n                return new OAuthToken(tokenData.accessToken, new User(this.auth.getUid()));\n            } else {\n                return null;\n            }\n        });\n    }\n    invalidateToken() {}\n    start(asyncQueue, changeListener) {}\n    shutdown() {}\n}\n/*\r\n * FirstPartyToken provides a fresh token each time its value\r\n * is requested, because if the token is too old, requests will be rejected.\r\n * Technically this may no longer be necessary since the SDK should gracefully\r\n * recover from unauthenticated errors (see b/33147818 for context), but it's\r\n * safer to keep the implementation as-is.\r\n */ class FirstPartyToken {\n    constructor(sessionIndex, iamToken, authTokenFactory){\n        this.sessionIndex = sessionIndex;\n        this.iamToken = iamToken;\n        this.authTokenFactory = authTokenFactory;\n        this.type = \"FirstParty\";\n        this.user = User.FIRST_PARTY;\n        this._headers = new Map();\n    }\n    /**\r\n     * Gets an authorization token, using a provided factory function, or return\r\n     * null.\r\n     */ getAuthToken() {\n        if (this.authTokenFactory) {\n            return this.authTokenFactory();\n        } else {\n            return null;\n        }\n    }\n    get headers() {\n        this._headers.set(\"X-Goog-AuthUser\", this.sessionIndex);\n        // Use array notation to prevent minification\n        const authHeaderTokenValue = this.getAuthToken();\n        if (authHeaderTokenValue) {\n            this._headers.set(\"Authorization\", authHeaderTokenValue);\n        }\n        if (this.iamToken) {\n            this._headers.set(\"X-Goog-Iam-Authorization-Token\", this.iamToken);\n        }\n        return this._headers;\n    }\n}\n/*\r\n * Provides user credentials required for the Firestore JavaScript SDK\r\n * to authenticate the user, using technique that is only available\r\n * to applications hosted by Google.\r\n */ class FirstPartyAuthCredentialsProvider {\n    constructor(sessionIndex, iamToken, authTokenFactory){\n        this.sessionIndex = sessionIndex;\n        this.iamToken = iamToken;\n        this.authTokenFactory = authTokenFactory;\n    }\n    getToken() {\n        return Promise.resolve(new FirstPartyToken(this.sessionIndex, this.iamToken, this.authTokenFactory));\n    }\n    start(asyncQueue, changeListener) {\n        // Fire with initial uid.\n        asyncQueue.enqueueRetryable(()=>changeListener(User.FIRST_PARTY));\n    }\n    shutdown() {}\n    invalidateToken() {}\n}\nclass AppCheckToken {\n    constructor(value){\n        this.value = value;\n        this.type = \"AppCheck\";\n        this.headers = new Map();\n        if (value && value.length > 0) {\n            this.headers.set(\"x-firebase-appcheck\", this.value);\n        }\n    }\n}\n/** AppCheck token provider for the Lite SDK. */ class LiteAppCheckTokenProvider {\n    constructor(appCheckProvider){\n        this.appCheckProvider = appCheckProvider;\n        this.appCheck = null;\n        appCheckProvider.onInit((appCheck)=>{\n            this.appCheck = appCheck;\n        });\n    }\n    getToken() {\n        if (!this.appCheck) {\n            return Promise.resolve(null);\n        }\n        return this.appCheck.getToken().then((tokenResult)=>{\n            if (tokenResult) {\n                hardAssert(typeof tokenResult.token === \"string\");\n                return new AppCheckToken(tokenResult.token);\n            } else {\n                return null;\n            }\n        });\n    }\n    invalidateToken() {}\n    start(asyncQueue, changeListener) {}\n    shutdown() {}\n}\n/**\r\n * Builds a CredentialsProvider depending on the type of\r\n * the credentials passed in.\r\n */ function makeAuthCredentialsProvider(credentials) {\n    if (!credentials) {\n        return new EmptyAuthCredentialsProvider();\n    }\n    switch(credentials[\"type\"]){\n        case \"firstParty\":\n            return new FirstPartyAuthCredentialsProvider(credentials[\"sessionIndex\"] || \"0\", credentials[\"iamToken\"] || null, credentials[\"authTokenFactory\"] || null);\n        case \"provider\":\n            return credentials[\"client\"];\n        default:\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"makeAuthCredentialsProvider failed due to invalid credential type\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class DatabaseInfo {\n    /**\r\n     * Constructs a DatabaseInfo using the provided host, databaseId and\r\n     * persistenceKey.\r\n     *\r\n     * @param databaseId - The database to use.\r\n     * @param appId - The Firebase App Id.\r\n     * @param persistenceKey - A unique identifier for this Firestore's local\r\n     * storage (used in conjunction with the databaseId).\r\n     * @param host - The Firestore backend host to connect to.\r\n     * @param ssl - Whether to use SSL when connecting.\r\n     * @param forceLongPolling - Whether to use the forceLongPolling option\r\n     * when using WebChannel as the network transport.\r\n     * @param autoDetectLongPolling - Whether to use the detectBufferingProxy\r\n     * option when using WebChannel as the network transport.\r\n     * @param longPollingOptions Options that configure long-polling.\r\n     * @param useFetchStreams Whether to use the Fetch API instead of\r\n     * XMLHTTPRequest\r\n     */ constructor(databaseId, appId, persistenceKey, host, ssl, forceLongPolling, autoDetectLongPolling, longPollingOptions, useFetchStreams){\n        this.databaseId = databaseId;\n        this.appId = appId;\n        this.persistenceKey = persistenceKey;\n        this.host = host;\n        this.ssl = ssl;\n        this.forceLongPolling = forceLongPolling;\n        this.autoDetectLongPolling = autoDetectLongPolling;\n        this.longPollingOptions = longPollingOptions;\n        this.useFetchStreams = useFetchStreams;\n    }\n}\n/** The default database name for a project. */ const DEFAULT_DATABASE_NAME = \"(default)\";\n/**\r\n * Represents the database ID a Firestore client is associated with.\r\n * @internal\r\n */ class DatabaseId {\n    constructor(projectId, database){\n        this.projectId = projectId;\n        this.database = database ? database : DEFAULT_DATABASE_NAME;\n    }\n    static empty() {\n        return new DatabaseId(\"\", \"\");\n    }\n    get isDefaultDatabase() {\n        return this.database === DEFAULT_DATABASE_NAME;\n    }\n    isEqual(other) {\n        return other instanceof DatabaseId && other.projectId === this.projectId && other.database === this.database;\n    }\n}\nfunction databaseIdFromApp(app, database) {\n    if (!Object.prototype.hasOwnProperty.apply(app.options, [\n        \"projectId\"\n    ])) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\n    }\n    return new DatabaseId(app.options.projectId, database);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DOCUMENT_KEY_NAME = \"__name__\";\n/**\r\n * Path represents an ordered sequence of string segments.\r\n */ class BasePath {\n    constructor(segments, offset, length){\n        if (offset === undefined) {\n            offset = 0;\n        } else if (offset > segments.length) {\n            fail();\n        }\n        if (length === undefined) {\n            length = segments.length - offset;\n        } else if (length > segments.length - offset) {\n            fail();\n        }\n        this.segments = segments;\n        this.offset = offset;\n        this.len = length;\n    }\n    get length() {\n        return this.len;\n    }\n    isEqual(other) {\n        return BasePath.comparator(this, other) === 0;\n    }\n    child(nameOrPath) {\n        const segments = this.segments.slice(this.offset, this.limit());\n        if (nameOrPath instanceof BasePath) {\n            nameOrPath.forEach((segment)=>{\n                segments.push(segment);\n            });\n        } else {\n            segments.push(nameOrPath);\n        }\n        return this.construct(segments);\n    }\n    /** The index of one past the last segment of the path. */ limit() {\n        return this.offset + this.length;\n    }\n    popFirst(size) {\n        size = size === undefined ? 1 : size;\n        return this.construct(this.segments, this.offset + size, this.length - size);\n    }\n    popLast() {\n        return this.construct(this.segments, this.offset, this.length - 1);\n    }\n    firstSegment() {\n        return this.segments[this.offset];\n    }\n    lastSegment() {\n        return this.get(this.length - 1);\n    }\n    get(index) {\n        return this.segments[this.offset + index];\n    }\n    isEmpty() {\n        return this.length === 0;\n    }\n    isPrefixOf(other) {\n        if (other.length < this.length) {\n            return false;\n        }\n        for(let i = 0; i < this.length; i++){\n            if (this.get(i) !== other.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isImmediateParentOf(potentialChild) {\n        if (this.length + 1 !== potentialChild.length) {\n            return false;\n        }\n        for(let i = 0; i < this.length; i++){\n            if (this.get(i) !== potentialChild.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    forEach(fn) {\n        for(let i = this.offset, end = this.limit(); i < end; i++){\n            fn(this.segments[i]);\n        }\n    }\n    toArray() {\n        return this.segments.slice(this.offset, this.limit());\n    }\n    static comparator(p1, p2) {\n        const len = Math.min(p1.length, p2.length);\n        for(let i = 0; i < len; i++){\n            const left = p1.get(i);\n            const right = p2.get(i);\n            if (left < right) {\n                return -1;\n            }\n            if (left > right) {\n                return 1;\n            }\n        }\n        if (p1.length < p2.length) {\n            return -1;\n        }\n        if (p1.length > p2.length) {\n            return 1;\n        }\n        return 0;\n    }\n}\n/**\r\n * A slash-separated path for navigating resources (documents and collections)\r\n * within Firestore.\r\n *\r\n * @internal\r\n */ class ResourcePath extends BasePath {\n    construct(segments, offset, length) {\n        return new ResourcePath(segments, offset, length);\n    }\n    canonicalString() {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        return this.toArray().join(\"/\");\n    }\n    toString() {\n        return this.canonicalString();\n    }\n    /**\r\n     * Returns a string representation of this path\r\n     * where each path segment has been encoded with\r\n     * `encodeURIComponent`.\r\n     */ toUriEncodedString() {\n        return this.toArray().map(encodeURIComponent).join(\"/\");\n    }\n    /**\r\n     * Creates a resource path from the given slash-delimited string. If multiple\r\n     * arguments are provided, all components are combined. Leading and trailing\r\n     * slashes from all components are ignored.\r\n     */ static fromString(...pathComponents) {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        const segments = [];\n        for (const path of pathComponents){\n            if (path.indexOf(\"//\") >= 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid segment (${path}). Paths must not contain // in them.`);\n            }\n            // Strip leading and traling slashed.\n            segments.push(...path.split(\"/\").filter((segment)=>segment.length > 0));\n        }\n        return new ResourcePath(segments);\n    }\n    static emptyPath() {\n        return new ResourcePath([]);\n    }\n}\nconst identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n/**\r\n * A dot-separated path for navigating sub-objects within a document.\r\n * @internal\r\n */ class FieldPath$1 extends BasePath {\n    construct(segments, offset, length) {\n        return new FieldPath$1(segments, offset, length);\n    }\n    /**\r\n     * Returns true if the string could be used as a segment in a field path\r\n     * without escaping.\r\n     */ static isValidIdentifier(segment) {\n        return identifierRegExp.test(segment);\n    }\n    canonicalString() {\n        return this.toArray().map((str)=>{\n            str = str.replace(/\\\\/g, \"\\\\\\\\\").replace(/`/g, \"\\\\`\");\n            if (!FieldPath$1.isValidIdentifier(str)) {\n                str = \"`\" + str + \"`\";\n            }\n            return str;\n        }).join(\".\");\n    }\n    toString() {\n        return this.canonicalString();\n    }\n    /**\r\n     * Returns true if this field references the key of a document.\r\n     */ isKeyField() {\n        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\n    }\n    /**\r\n     * The field designating the key of a document.\r\n     */ static keyField() {\n        return new FieldPath$1([\n            DOCUMENT_KEY_NAME\n        ]);\n    }\n    /**\r\n     * Parses a field string from the given server-formatted string.\r\n     *\r\n     * - Splitting the empty string is not allowed (for now at least).\r\n     * - Empty segments within the string (e.g. if there are two consecutive\r\n     *   separators) are not allowed.\r\n     *\r\n     * TODO(b/37244157): we should make this more strict. Right now, it allows\r\n     * non-identifier path components, even if they aren't escaped.\r\n     */ static fromServerFormat(path) {\n        const segments = [];\n        let current = \"\";\n        let i = 0;\n        const addCurrentSegment = ()=>{\n            if (current.length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field path (${path}). Paths must not be empty, begin ` + `with '.', end with '.', or contain '..'`);\n            }\n            segments.push(current);\n            current = \"\";\n        };\n        let inBackticks = false;\n        while(i < path.length){\n            const c = path[i];\n            if (c === \"\\\\\") {\n                if (i + 1 === path.length) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Path has trailing escape character: \" + path);\n                }\n                const next = path[i + 1];\n                if (!(next === \"\\\\\" || next === \".\" || next === \"`\")) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Path has invalid escape sequence: \" + path);\n                }\n                current += next;\n                i += 2;\n            } else if (c === \"`\") {\n                inBackticks = !inBackticks;\n                i++;\n            } else if (c === \".\" && !inBackticks) {\n                addCurrentSegment();\n                i++;\n            } else {\n                current += c;\n                i++;\n            }\n        }\n        addCurrentSegment();\n        if (inBackticks) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Unterminated ` in path: \" + path);\n        }\n        return new FieldPath$1(segments);\n    }\n    static emptyPath() {\n        return new FieldPath$1([]);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @internal\r\n */ class DocumentKey {\n    constructor(path){\n        this.path = path;\n    }\n    static fromPath(path) {\n        return new DocumentKey(ResourcePath.fromString(path));\n    }\n    static fromName(name) {\n        return new DocumentKey(ResourcePath.fromString(name).popFirst(5));\n    }\n    static empty() {\n        return new DocumentKey(ResourcePath.emptyPath());\n    }\n    get collectionGroup() {\n        return this.path.popLast().lastSegment();\n    }\n    /** Returns true if the document is in the specified collectionId. */ hasCollectionId(collectionId) {\n        return this.path.length >= 2 && this.path.get(this.path.length - 2) === collectionId;\n    }\n    /** Returns the collection group (i.e. the name of the parent collection) for this key. */ getCollectionGroup() {\n        return this.path.get(this.path.length - 2);\n    }\n    /** Returns the fully qualified path to the parent collection. */ getCollectionPath() {\n        return this.path.popLast();\n    }\n    isEqual(other) {\n        return other !== null && ResourcePath.comparator(this.path, other.path) === 0;\n    }\n    toString() {\n        return this.path.toString();\n    }\n    static comparator(k1, k2) {\n        return ResourcePath.comparator(k1.path, k2.path);\n    }\n    static isDocumentKey(path) {\n        return path.length % 2 === 0;\n    }\n    /**\r\n     * Creates and returns a new document key with the given segments.\r\n     *\r\n     * @param segments - The segments of the path to the document\r\n     * @returns A new instance of DocumentKey\r\n     */ static fromSegments(segments) {\n        return new DocumentKey(new ResourcePath(segments.slice()));\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function validateNonEmptyArgument(functionName, argumentName, argument) {\n    if (!argument) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() cannot be called with an empty ${argumentName}.`);\n    }\n}\n/**\r\n * Validates that two boolean options are not set at the same time.\r\n * @internal\r\n */ function validateIsNotUsedTogether(optionName1, argument1, optionName2, argument2) {\n    if (argument1 === true && argument2 === true) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `${optionName1} and ${optionName2} cannot be used together.`);\n    }\n}\n/**\r\n * Validates that `path` refers to a document (indicated by the fact it contains\r\n * an even numbers of segments).\r\n */ function validateDocumentPath(path) {\n    if (!DocumentKey.isDocumentKey(path)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${path} has ${path.length}.`);\n    }\n}\n/**\r\n * Validates that `path` refers to a collection (indicated by the fact it\r\n * contains an odd numbers of segments).\r\n */ function validateCollectionPath(path) {\n    if (DocumentKey.isDocumentKey(path)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${path} has ${path.length}.`);\n    }\n}\n/**\r\n * Returns true if it's a non-null object without a custom prototype\r\n * (i.e. excludes Array, Date, etc.).\r\n */ function isPlainObject(input) {\n    return typeof input === \"object\" && input !== null && (Object.getPrototypeOf(input) === Object.prototype || Object.getPrototypeOf(input) === null);\n}\n/** Returns a string describing the type / value of the provided input. */ function valueDescription(input) {\n    if (input === undefined) {\n        return \"undefined\";\n    } else if (input === null) {\n        return \"null\";\n    } else if (typeof input === \"string\") {\n        if (input.length > 20) {\n            input = `${input.substring(0, 20)}...`;\n        }\n        return JSON.stringify(input);\n    } else if (typeof input === \"number\" || typeof input === \"boolean\") {\n        return \"\" + input;\n    } else if (typeof input === \"object\") {\n        if (input instanceof Array) {\n            return \"an array\";\n        } else {\n            const customObjectName = tryGetCustomObjectType(input);\n            if (customObjectName) {\n                return `a custom ${customObjectName} object`;\n            } else {\n                return \"an object\";\n            }\n        }\n    } else if (typeof input === \"function\") {\n        return \"a function\";\n    } else {\n        return fail();\n    }\n}\n/** try to get the constructor name for an object. */ function tryGetCustomObjectType(input) {\n    if (input.constructor) {\n        return input.constructor.name;\n    }\n    return null;\n}\n/**\r\n * Casts `obj` to `T`, optionally unwrapping Compat types to expose the\r\n * underlying instance. Throws if  `obj` is not an instance of `T`.\r\n *\r\n * This cast is used in the Lite and Full SDK to verify instance types for\r\n * arguments passed to the public API.\r\n * @internal\r\n */ function cast(obj, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nconstructor) {\n    if (\"_delegate\" in obj) {\n        // Unwrap Compat types\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        obj = obj._delegate;\n    }\n    if (!(obj instanceof constructor)) {\n        if (constructor.name === obj.constructor.name) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Type does not match the expected instance. Did you pass a \" + `reference from a different Firestore SDK?`);\n        } else {\n            const description = valueDescription(obj);\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Expected type '${constructor.name}', but it was: ${description}`);\n        }\n    }\n    return obj;\n}\nfunction validatePositiveNumber(functionName, n) {\n    if (n <= 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() requires a positive number, but it was: ${n}.`);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Compares two `ExperimentalLongPollingOptions` objects for equality.\r\n */ function longPollingOptionsEqual(options1, options2) {\n    return options1.timeoutSeconds === options2.timeoutSeconds;\n}\n/**\r\n * Creates and returns a new `ExperimentalLongPollingOptions` with the same\r\n * option values as the given instance.\r\n */ function cloneLongPollingOptions(options) {\n    const clone = {};\n    if (options.timeoutSeconds !== undefined) {\n        clone.timeoutSeconds = options.timeoutSeconds;\n    }\n    return clone;\n}\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The value returned from the most recent invocation of\r\n * `generateUniqueDebugId()`, or null if it has never been invoked.\r\n */ let lastUniqueDebugId = null;\n/**\r\n * Generates and returns an initial value for `lastUniqueDebugId`.\r\n *\r\n * The returned value is randomly selected from a range of integers that are\r\n * represented as 8 hexadecimal digits. This means that (within reason) any\r\n * numbers generated by incrementing the returned number by 1 will also be\r\n * represented by 8 hexadecimal digits. This leads to all \"IDs\" having the same\r\n * length when converted to a hexadecimal string, making reading logs containing\r\n * these IDs easier to follow. And since the return value is randomly selected\r\n * it will help to differentiate between logs from different executions.\r\n */ function generateInitialUniqueDebugId() {\n    const minResult = 0x10000000;\n    const maxResult = 0x90000000;\n    const resultRange = maxResult - minResult;\n    const resultOffset = Math.round(resultRange * Math.random());\n    return minResult + resultOffset;\n}\n/**\r\n * Generates and returns a unique ID as a hexadecimal string.\r\n *\r\n * The returned ID is intended to be used in debug logging messages to help\r\n * correlate log messages that may be spatially separated in the logs, but\r\n * logically related. For example, a network connection could include the same\r\n * \"debug ID\" string in all of its log messages to help trace a specific\r\n * connection over time.\r\n *\r\n * @return the 10-character generated ID (e.g. \"0xa1b2c3d4\").\r\n */ function generateUniqueDebugId() {\n    if (lastUniqueDebugId === null) {\n        lastUniqueDebugId = generateInitialUniqueDebugId();\n    } else {\n        lastUniqueDebugId++;\n    }\n    return \"0x\" + lastUniqueDebugId.toString(16);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const LOG_TAG$3 = \"RestConnection\";\n/**\r\n * Maps RPC names to the corresponding REST endpoint name.\r\n *\r\n * We use array notation to avoid mangling.\r\n */ const RPC_NAME_URL_MAPPING = {};\nRPC_NAME_URL_MAPPING[\"BatchGetDocuments\"] = \"batchGet\";\nRPC_NAME_URL_MAPPING[\"Commit\"] = \"commit\";\nRPC_NAME_URL_MAPPING[\"RunQuery\"] = \"runQuery\";\nRPC_NAME_URL_MAPPING[\"RunAggregationQuery\"] = \"runAggregationQuery\";\nconst RPC_URL_VERSION = \"v1\";\n// SDK_VERSION is updated to different value at runtime depending on the entry point,\n// so we need to get its value when we need it in a function.\nfunction getGoogApiClientValue() {\n    return \"gl-js/ fire/\" + SDK_VERSION;\n}\n/**\r\n * Base class for all Rest-based connections to the backend (WebChannel and\r\n * HTTP).\r\n */ class RestConnection {\n    constructor(databaseInfo){\n        this.databaseInfo = databaseInfo;\n        this.databaseId = databaseInfo.databaseId;\n        const proto = databaseInfo.ssl ? \"https\" : \"http\";\n        const projectId = encodeURIComponent(this.databaseId.projectId);\n        const databaseId = encodeURIComponent(this.databaseId.database);\n        this.baseUrl = proto + \"://\" + databaseInfo.host;\n        this.databasePath = `projects/${projectId}/databases/${databaseId}`;\n        this.requestParams = this.databaseId.database === DEFAULT_DATABASE_NAME ? `project_id=${projectId}` : `project_id=${projectId}&database_id=${databaseId}`;\n    }\n    get shouldResourcePathBeIncludedInRequest() {\n        // Both `invokeRPC()` and `invokeStreamingRPC()` use their `path` arguments to determine\n        // where to run the query, and expect the `request` to NOT specify the \"path\".\n        return false;\n    }\n    invokeRPC(rpcName, path, req, authToken, appCheckToken) {\n        const streamId = generateUniqueDebugId();\n        const url = this.makeUrl(rpcName, path.toUriEncodedString());\n        logDebug(LOG_TAG$3, `Sending RPC '${rpcName}' ${streamId}:`, url, req);\n        const headers = {\n            \"google-cloud-resource-prefix\": this.databasePath,\n            \"x-goog-request-params\": this.requestParams\n        };\n        this.modifyHeadersForRequest(headers, authToken, appCheckToken);\n        return this.performRPCRequest(rpcName, url, headers, req).then((response)=>{\n            logDebug(LOG_TAG$3, `Received RPC '${rpcName}' ${streamId}: `, response);\n            return response;\n        }, (err)=>{\n            logWarn(LOG_TAG$3, `RPC '${rpcName}' ${streamId} failed with error: `, err, \"url: \", url, \"request:\", req);\n            throw err;\n        });\n    }\n    invokeStreamingRPC(rpcName, path, request, authToken, appCheckToken, expectedResponseCount) {\n        // The REST API automatically aggregates all of the streamed results, so we\n        // can just use the normal invoke() method.\n        return this.invokeRPC(rpcName, path, request, authToken, appCheckToken);\n    }\n    /**\r\n     * Modifies the headers for a request, adding any authorization token if\r\n     * present and any additional headers for the request.\r\n     */ modifyHeadersForRequest(headers, authToken, appCheckToken) {\n        headers[\"X-Goog-Api-Client\"] = getGoogApiClientValue();\n        // Content-Type: text/plain will avoid preflight requests which might\n        // mess with CORS and redirects by proxies. If we add custom headers\n        // we will need to change this code to potentially use the $httpOverwrite\n        // parameter supported by ESF to avoid triggering preflight requests.\n        headers[\"Content-Type\"] = \"text/plain\";\n        if (this.databaseInfo.appId) {\n            headers[\"X-Firebase-GMPID\"] = this.databaseInfo.appId;\n        }\n        if (authToken) {\n            authToken.headers.forEach((value, key)=>headers[key] = value);\n        }\n        if (appCheckToken) {\n            appCheckToken.headers.forEach((value, key)=>headers[key] = value);\n        }\n    }\n    makeUrl(rpcName, path) {\n        const urlRpcName = RPC_NAME_URL_MAPPING[rpcName];\n        return `${this.baseUrl}/${RPC_URL_VERSION}/${path}:${urlRpcName}`;\n    }\n    /**\r\n     * Closes and cleans up any resources associated with the connection. This\r\n     * implementation is a no-op because there are no resources associated\r\n     * with the RestConnection that need to be cleaned up.\r\n     */ terminate() {\n    // No-op\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Error Codes describing the different ways GRPC can fail. These are copied\r\n * directly from GRPC's sources here:\r\n *\r\n * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\r\n *\r\n * Important! The names of these identifiers matter because the string forms\r\n * are used for reverse lookups from the webchannel stream. Do NOT change the\r\n * names of these identifiers or change this into a const enum.\r\n */ var RpcCode;\n(function(RpcCode) {\n    RpcCode[RpcCode[\"OK\"] = 0] = \"OK\";\n    RpcCode[RpcCode[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    RpcCode[RpcCode[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    RpcCode[RpcCode[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    RpcCode[RpcCode[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    RpcCode[RpcCode[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    RpcCode[RpcCode[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    RpcCode[RpcCode[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    RpcCode[RpcCode[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n    RpcCode[RpcCode[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    RpcCode[RpcCode[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    RpcCode[RpcCode[\"ABORTED\"] = 10] = \"ABORTED\";\n    RpcCode[RpcCode[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    RpcCode[RpcCode[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    RpcCode[RpcCode[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    RpcCode[RpcCode[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    RpcCode[RpcCode[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n})(RpcCode || (RpcCode = {}));\n/**\r\n * Determines whether an error code represents a permanent error when received\r\n * in response to a non-write operation.\r\n *\r\n * See isPermanentWriteError for classifying write errors.\r\n */ function isPermanentError(code) {\n    switch(code){\n        case Code.OK:\n            return fail();\n        case Code.CANCELLED:\n        case Code.UNKNOWN:\n        case Code.DEADLINE_EXCEEDED:\n        case Code.RESOURCE_EXHAUSTED:\n        case Code.INTERNAL:\n        case Code.UNAVAILABLE:\n        // Unauthenticated means something went wrong with our token and we need\n        // to retry with new credentials which will happen automatically.\n        case Code.UNAUTHENTICATED:\n            return false;\n        case Code.INVALID_ARGUMENT:\n        case Code.NOT_FOUND:\n        case Code.ALREADY_EXISTS:\n        case Code.PERMISSION_DENIED:\n        case Code.FAILED_PRECONDITION:\n        // Aborted might be retried in some scenarios, but that is dependant on\n        // the context and should handled individually by the calling code.\n        // See https://cloud.google.com/apis/design/errors.\n        case Code.ABORTED:\n        case Code.OUT_OF_RANGE:\n        case Code.UNIMPLEMENTED:\n        case Code.DATA_LOSS:\n            return true;\n        default:\n            return fail();\n    }\n}\n/**\r\n * Converts an HTTP Status Code to the equivalent error code.\r\n *\r\n * @param status - An HTTP Status Code, like 200, 404, 503, etc.\r\n * @returns The equivalent Code. Unknown status codes are mapped to\r\n *     Code.UNKNOWN.\r\n */ function mapCodeFromHttpStatus(status) {\n    if (status === undefined) {\n        logError(\"RPC_ERROR\", \"HTTP error has no status\");\n        return Code.UNKNOWN;\n    }\n    // The canonical error codes for Google APIs [1] specify mapping onto HTTP\n    // status codes but the mapping is not bijective. In each case of ambiguity\n    // this function chooses a primary error.\n    //\n    // [1]\n    // https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\n    switch(status){\n        case 200:\n            return Code.OK;\n        case 400:\n            return Code.FAILED_PRECONDITION;\n        // Other possibilities based on the forward mapping\n        // return Code.INVALID_ARGUMENT;\n        // return Code.OUT_OF_RANGE;\n        case 401:\n            return Code.UNAUTHENTICATED;\n        case 403:\n            return Code.PERMISSION_DENIED;\n        case 404:\n            return Code.NOT_FOUND;\n        case 409:\n            return Code.ABORTED;\n        // Other possibilities:\n        // return Code.ALREADY_EXISTS;\n        case 416:\n            return Code.OUT_OF_RANGE;\n        case 429:\n            return Code.RESOURCE_EXHAUSTED;\n        case 499:\n            return Code.CANCELLED;\n        case 500:\n            return Code.UNKNOWN;\n        // Other possibilities:\n        // return Code.INTERNAL;\n        // return Code.DATA_LOSS;\n        case 501:\n            return Code.UNIMPLEMENTED;\n        case 503:\n            return Code.UNAVAILABLE;\n        case 504:\n            return Code.DEADLINE_EXCEEDED;\n        default:\n            if (status >= 200 && status < 300) {\n                return Code.OK;\n            }\n            if (status >= 400 && status < 500) {\n                return Code.FAILED_PRECONDITION;\n            }\n            if (status >= 500 && status < 600) {\n                return Code.INTERNAL;\n            }\n            return Code.UNKNOWN;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A Rest-based connection that relies on the native HTTP stack\r\n * (e.g. `fetch` or a polyfill).\r\n */ class FetchConnection extends RestConnection {\n    /**\r\n     * @param databaseInfo - The connection info.\r\n     * @param fetchImpl - `fetch` or a Polyfill that implements the fetch API.\r\n     */ constructor(databaseInfo, fetchImpl){\n        super(databaseInfo);\n        this.fetchImpl = fetchImpl;\n    }\n    openStream(rpcName, token) {\n        throw new Error(\"Not supported by FetchConnection\");\n    }\n    async performRPCRequest(rpcName, url, headers, body) {\n        var _a;\n        const requestJson = JSON.stringify(body);\n        let response;\n        try {\n            response = await this.fetchImpl(url, {\n                method: \"POST\",\n                headers,\n                body: requestJson\n            });\n        } catch (e) {\n            const err = e;\n            throw new FirestoreError(mapCodeFromHttpStatus(err.status), \"Request failed with error: \" + err.statusText);\n        }\n        if (!response.ok) {\n            let errorResponse = await response.json();\n            if (Array.isArray(errorResponse)) {\n                errorResponse = errorResponse[0];\n            }\n            const errorMessage = (_a = errorResponse === null || errorResponse === void 0 ? void 0 : errorResponse.error) === null || _a === void 0 ? void 0 : _a.message;\n            throw new FirestoreError(mapCodeFromHttpStatus(response.status), `Request failed with error: ${errorMessage !== null && errorMessage !== void 0 ? errorMessage : response.statusText}`);\n        }\n        return response.json();\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** Initializes the HTTP connection for the REST API. */ function newConnection(databaseInfo) {\n    // undici is meant to be API compatible with `fetch`, but its type doesn't\n    // match 100%.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new FetchConnection(databaseInfo, undici__WEBPACK_IMPORTED_MODULE_5__.fetch);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Generates `nBytes` of random bytes.\r\n *\r\n * If `nBytes < 0` , an error will be thrown.\r\n */ function randomBytes(nBytes) {\n    return (0,crypto__WEBPACK_IMPORTED_MODULE_6__.randomBytes)(nBytes);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A utility class for generating unique alphanumeric IDs of a specified length.\r\n *\r\n * @internal\r\n * Exported internally for testing purposes.\r\n */ class AutoId {\n    static newId() {\n        // Alphanumeric characters\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n        // The largest byte value that is a multiple of `char.length`.\n        const maxMultiple = Math.floor(256 / chars.length) * chars.length;\n        let autoId = \"\";\n        const targetLength = 20;\n        while(autoId.length < targetLength){\n            const bytes = randomBytes(40);\n            for(let i = 0; i < bytes.length; ++i){\n                // Only accept values that are [0, maxMultiple), this ensures they can\n                // be evenly mapped to indices of `chars` via a modulo operation.\n                if (autoId.length < targetLength && bytes[i] < maxMultiple) {\n                    autoId += chars.charAt(bytes[i] % chars.length);\n                }\n            }\n        }\n        return autoId;\n    }\n}\nfunction primitiveComparator(left, right) {\n    if (left < right) {\n        return -1;\n    }\n    if (left > right) {\n        return 1;\n    }\n    return 0;\n}\n/** Helper to compare arrays using isEqual(). */ function arrayEquals(left, right, comparator) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    return left.every((value, index)=>comparator(value, right[index]));\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function objectSize(obj) {\n    let count = 0;\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            count++;\n        }\n    }\n    return count;\n}\nfunction forEach(obj, fn) {\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            fn(key, obj[key]);\n        }\n    }\n}\nfunction mapToArray(obj, fn) {\n    const result = [];\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            result.push(fn(obj[key], key, obj));\n        }\n    }\n    return result;\n}\nfunction isEmpty(obj) {\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns whether a variable is either undefined or null.\r\n */ function isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/** Returns whether the value represents -0. */ function isNegativeZero(value) {\n    // Detect if the value is -0.0. Based on polyfill from\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n    return value === 0 && 1 / value === 1 / -0;\n}\n/**\r\n * Returns whether a value is an integer and in the safe integer range\r\n * @param value - The value to test for being an integer and in the safe range\r\n */ function isSafeInteger(value) {\n    return typeof value === \"number\" && Number.isInteger(value) && !isNegativeZero(value) && value <= Number.MAX_SAFE_INTEGER && value >= Number.MIN_SAFE_INTEGER;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** Converts a Base64 encoded string to a binary string. */ function decodeBase64(encoded) {\n    // Note: We used to validate the base64 string here via a regular expression.\n    // This was removed to improve the performance of indexing.\n    return Buffer.from(encoded, \"base64\").toString(\"binary\");\n}\n/** Converts a binary string to a Base64 encoded string. */ function encodeBase64(raw) {\n    return Buffer.from(raw, \"binary\").toString(\"base64\");\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Immutable class that represents a \"proto\" byte string.\r\n *\r\n * Proto byte strings can either be Base64-encoded strings or Uint8Arrays when\r\n * sent on the wire. This class abstracts away this differentiation by holding\r\n * the proto byte string in a common class that must be converted into a string\r\n * before being sent as a proto.\r\n * @internal\r\n */ class ByteString {\n    constructor(binaryString){\n        this.binaryString = binaryString;\n    }\n    static fromBase64String(base64) {\n        const binaryString = decodeBase64(base64);\n        return new ByteString(binaryString);\n    }\n    static fromUint8Array(array) {\n        // TODO(indexing); Remove the copy of the byte string here as this method\n        // is frequently called during indexing.\n        const binaryString = binaryStringFromUint8Array(array);\n        return new ByteString(binaryString);\n    }\n    [Symbol.iterator]() {\n        let i = 0;\n        return {\n            next: ()=>{\n                if (i < this.binaryString.length) {\n                    return {\n                        value: this.binaryString.charCodeAt(i++),\n                        done: false\n                    };\n                } else {\n                    return {\n                        value: undefined,\n                        done: true\n                    };\n                }\n            }\n        };\n    }\n    toBase64() {\n        return encodeBase64(this.binaryString);\n    }\n    toUint8Array() {\n        return uint8ArrayFromBinaryString(this.binaryString);\n    }\n    approximateByteSize() {\n        return this.binaryString.length * 2;\n    }\n    compareTo(other) {\n        return primitiveComparator(this.binaryString, other.binaryString);\n    }\n    isEqual(other) {\n        return this.binaryString === other.binaryString;\n    }\n}\nByteString.EMPTY_BYTE_STRING = new ByteString(\"\");\n/**\r\n * Helper function to convert an Uint8array to a binary string.\r\n */ function binaryStringFromUint8Array(array) {\n    let binaryString = \"\";\n    for(let i = 0; i < array.length; ++i){\n        binaryString += String.fromCharCode(array[i]);\n    }\n    return binaryString;\n}\n/**\r\n * Helper function to convert a binary string to an Uint8Array.\r\n */ function uint8ArrayFromBinaryString(binaryString) {\n    const buffer = new Uint8Array(binaryString.length);\n    for(let i = 0; i < binaryString.length; i++){\n        buffer[i] = binaryString.charCodeAt(i);\n    }\n    return buffer;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // A RegExp matching ISO 8601 UTC timestamps with optional fraction.\nconst ISO_TIMESTAMP_REG_EXP = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\n/**\r\n * Converts the possible Proto values for a timestamp value into a \"seconds and\r\n * nanos\" representation.\r\n */ function normalizeTimestamp(date) {\n    hardAssert(!!date);\n    // The json interface (for the browser) will return an iso timestamp string,\n    // while the proto js library (for node) will return a\n    // google.protobuf.Timestamp instance.\n    if (typeof date === \"string\") {\n        // The date string can have higher precision (nanos) than the Date class\n        // (millis), so we do some custom parsing here.\n        // Parse the nanos right out of the string.\n        let nanos = 0;\n        const fraction = ISO_TIMESTAMP_REG_EXP.exec(date);\n        hardAssert(!!fraction);\n        if (fraction[1]) {\n            // Pad the fraction out to 9 digits (nanos).\n            let nanoStr = fraction[1];\n            nanoStr = (nanoStr + \"000000000\").substr(0, 9);\n            nanos = Number(nanoStr);\n        }\n        // Parse the date to get the seconds.\n        const parsedDate = new Date(date);\n        const seconds = Math.floor(parsedDate.getTime() / 1000);\n        return {\n            seconds,\n            nanos\n        };\n    } else {\n        // TODO(b/37282237): Use strings for Proto3 timestamps\n        // assert(!this.options.useProto3Json,\n        //   'The timestamp instance format requires Proto JS.');\n        const seconds = normalizeNumber(date.seconds);\n        const nanos = normalizeNumber(date.nanos);\n        return {\n            seconds,\n            nanos\n        };\n    }\n}\n/**\r\n * Converts the possible Proto types for numbers into a JavaScript number.\r\n * Returns 0 if the value is not numeric.\r\n */ function normalizeNumber(value) {\n    // TODO(bjornick): Handle int64 greater than 53 bits.\n    if (typeof value === \"number\") {\n        return value;\n    } else if (typeof value === \"string\") {\n        return Number(value);\n    } else {\n        return 0;\n    }\n}\n/** Converts the possible Proto types for Blobs into a ByteString. */ function normalizeByteString(blob) {\n    if (typeof blob === \"string\") {\n        return ByteString.fromBase64String(blob);\n    } else {\n        return ByteString.fromUint8Array(blob);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // The earliest date supported by Firestore timestamps (0001-01-01T00:00:00Z).\nconst MIN_SECONDS = -62135596800;\n// Number of nanoseconds in a millisecond.\nconst MS_TO_NANOS = 1e6;\n/**\r\n * A `Timestamp` represents a point in time independent of any time zone or\r\n * calendar, represented as seconds and fractions of seconds at nanosecond\r\n * resolution in UTC Epoch time.\r\n *\r\n * It is encoded using the Proleptic Gregorian Calendar which extends the\r\n * Gregorian calendar backwards to year one. It is encoded assuming all minutes\r\n * are 60 seconds long, i.e. leap seconds are \"smeared\" so that no leap second\r\n * table is needed for interpretation. Range is from 0001-01-01T00:00:00Z to\r\n * 9999-12-31T23:59:59.999999999Z.\r\n *\r\n * For examples and further specifications, refer to the\r\n * {@link https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto | Timestamp definition}.\r\n */ class Timestamp {\n    /**\r\n     * Creates a new timestamp.\r\n     *\r\n     * @param seconds - The number of seconds of UTC time since Unix epoch\r\n     *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\r\n     *     9999-12-31T23:59:59Z inclusive.\r\n     * @param nanoseconds - The non-negative fractions of a second at nanosecond\r\n     *     resolution. Negative second values with fractions must still have\r\n     *     non-negative nanoseconds values that count forward in time. Must be\r\n     *     from 0 to 999,999,999 inclusive.\r\n     */ constructor(/**\r\n     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\r\n     */ seconds, /**\r\n     * The fractions of a second at nanosecond resolution.*\r\n     */ nanoseconds){\n        this.seconds = seconds;\n        this.nanoseconds = nanoseconds;\n        if (nanoseconds < 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Timestamp nanoseconds out of range: \" + nanoseconds);\n        }\n        if (nanoseconds >= 1e9) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Timestamp nanoseconds out of range: \" + nanoseconds);\n        }\n        if (seconds < MIN_SECONDS) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Timestamp seconds out of range: \" + seconds);\n        }\n        // This will break in the year 10,000.\n        if (seconds >= 253402300800) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Timestamp seconds out of range: \" + seconds);\n        }\n    }\n    /**\r\n     * Creates a new timestamp with the current date, with millisecond precision.\r\n     *\r\n     * @returns a new timestamp representing the current date.\r\n     */ static now() {\n        return Timestamp.fromMillis(Date.now());\n    }\n    /**\r\n     * Creates a new timestamp from the given date.\r\n     *\r\n     * @param date - The date to initialize the `Timestamp` from.\r\n     * @returns A new `Timestamp` representing the same point in time as the given\r\n     *     date.\r\n     */ static fromDate(date) {\n        return Timestamp.fromMillis(date.getTime());\n    }\n    /**\r\n     * Creates a new timestamp from the given number of milliseconds.\r\n     *\r\n     * @param milliseconds - Number of milliseconds since Unix epoch\r\n     *     1970-01-01T00:00:00Z.\r\n     * @returns A new `Timestamp` representing the same point in time as the given\r\n     *     number of milliseconds.\r\n     */ static fromMillis(milliseconds) {\n        const seconds = Math.floor(milliseconds / 1000);\n        const nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);\n        return new Timestamp(seconds, nanos);\n    }\n    /**\r\n     * Converts a `Timestamp` to a JavaScript `Date` object. This conversion\r\n     * causes a loss of precision since `Date` objects only support millisecond\r\n     * precision.\r\n     *\r\n     * @returns JavaScript `Date` object representing the same point in time as\r\n     *     this `Timestamp`, with millisecond precision.\r\n     */ toDate() {\n        return new Date(this.toMillis());\n    }\n    /**\r\n     * Converts a `Timestamp` to a numeric timestamp (in milliseconds since\r\n     * epoch). This operation causes a loss of precision.\r\n     *\r\n     * @returns The point in time corresponding to this timestamp, represented as\r\n     *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\r\n     */ toMillis() {\n        return this.seconds * 1000 + this.nanoseconds / MS_TO_NANOS;\n    }\n    _compareTo(other) {\n        if (this.seconds === other.seconds) {\n            return primitiveComparator(this.nanoseconds, other.nanoseconds);\n        }\n        return primitiveComparator(this.seconds, other.seconds);\n    }\n    /**\r\n     * Returns true if this `Timestamp` is equal to the provided one.\r\n     *\r\n     * @param other - The `Timestamp` to compare against.\r\n     * @returns true if this `Timestamp` is equal to the provided one.\r\n     */ isEqual(other) {\n        return other.seconds === this.seconds && other.nanoseconds === this.nanoseconds;\n    }\n    /** Returns a textual representation of this `Timestamp`. */ toString() {\n        return \"Timestamp(seconds=\" + this.seconds + \", nanoseconds=\" + this.nanoseconds + \")\";\n    }\n    /** Returns a JSON-serializable representation of this `Timestamp`. */ toJSON() {\n        return {\n            seconds: this.seconds,\n            nanoseconds: this.nanoseconds\n        };\n    }\n    /**\r\n     * Converts this object to a primitive string, which allows `Timestamp` objects\r\n     * to be compared using the `>`, `<=`, `>=` and `>` operators.\r\n     */ valueOf() {\n        // This method returns a string of the form <seconds>.<nanoseconds> where\n        // <seconds> is translated to have a non-negative value and both <seconds>\n        // and <nanoseconds> are left-padded with zeroes to be a consistent length.\n        // Strings with this format then have a lexiographical ordering that matches\n        // the expected ordering. The <seconds> translation is done to avoid having\n        // a leading negative sign (i.e. a leading '-' character) in its string\n        // representation, which would affect its lexiographical ordering.\n        const adjustedSeconds = this.seconds - MIN_SECONDS;\n        // Note: Up to 12 decimal digits are required to represent all valid\n        // 'seconds' values.\n        const formattedSeconds = String(adjustedSeconds).padStart(12, \"0\");\n        const formattedNanoseconds = String(this.nanoseconds).padStart(9, \"0\");\n        return formattedSeconds + \".\" + formattedNanoseconds;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Represents a locally-applied ServerTimestamp.\r\n *\r\n * Server Timestamps are backed by MapValues that contain an internal field\r\n * `__type__` with a value of `server_timestamp`. The previous value and local\r\n * write time are stored in its `__previous_value__` and `__local_write_time__`\r\n * fields respectively.\r\n *\r\n * Notes:\r\n * - ServerTimestampValue instances are created as the result of applying a\r\n *   transform. They can only exist in the local view of a document. Therefore\r\n *   they do not need to be parsed or serialized.\r\n * - When evaluated locally (e.g. for snapshot.data()), they by default\r\n *   evaluate to `null`. This behavior can be configured by passing custom\r\n *   FieldValueOptions to value().\r\n * - With respect to other ServerTimestampValues, they sort by their\r\n *   localWriteTime.\r\n */ const SERVER_TIMESTAMP_SENTINEL = \"server_timestamp\";\nconst TYPE_KEY = \"__type__\";\nconst PREVIOUS_VALUE_KEY = \"__previous_value__\";\nconst LOCAL_WRITE_TIME_KEY = \"__local_write_time__\";\nfunction isServerTimestamp(value) {\n    var _a, _b;\n    const type = (_b = (((_a = value === null || value === void 0 ? void 0 : value.mapValue) === null || _a === void 0 ? void 0 : _a.fields) || {})[TYPE_KEY]) === null || _b === void 0 ? void 0 : _b.stringValue;\n    return type === SERVER_TIMESTAMP_SENTINEL;\n}\n/**\r\n * Returns the value of the field before this ServerTimestamp was set.\r\n *\r\n * Preserving the previous values allows the user to display the last resoled\r\n * value until the backend responds with the timestamp.\r\n */ function getPreviousValue(value) {\n    const previousValue = value.mapValue.fields[PREVIOUS_VALUE_KEY];\n    if (isServerTimestamp(previousValue)) {\n        return getPreviousValue(previousValue);\n    }\n    return previousValue;\n}\n/**\r\n * Returns the local time at which this timestamp was first set.\r\n */ function getLocalWriteTime(value) {\n    const localWriteTime = normalizeTimestamp(value.mapValue.fields[LOCAL_WRITE_TIME_KEY].timestampValue);\n    return new Timestamp(localWriteTime.seconds, localWriteTime.nanos);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const MAX_VALUE_TYPE = \"__max__\";\nconst MAX_VALUE = {\n    mapValue: {\n        fields: {\n            \"__type__\": {\n                stringValue: MAX_VALUE_TYPE\n            }\n        }\n    }\n};\n/** Extracts the backend's type order for the provided value. */ function typeOrder(value) {\n    if (\"nullValue\" in value) {\n        return 0 /* TypeOrder.NullValue */ ;\n    } else if (\"booleanValue\" in value) {\n        return 1 /* TypeOrder.BooleanValue */ ;\n    } else if (\"integerValue\" in value || \"doubleValue\" in value) {\n        return 2 /* TypeOrder.NumberValue */ ;\n    } else if (\"timestampValue\" in value) {\n        return 3 /* TypeOrder.TimestampValue */ ;\n    } else if (\"stringValue\" in value) {\n        return 5 /* TypeOrder.StringValue */ ;\n    } else if (\"bytesValue\" in value) {\n        return 6 /* TypeOrder.BlobValue */ ;\n    } else if (\"referenceValue\" in value) {\n        return 7 /* TypeOrder.RefValue */ ;\n    } else if (\"geoPointValue\" in value) {\n        return 8 /* TypeOrder.GeoPointValue */ ;\n    } else if (\"arrayValue\" in value) {\n        return 9 /* TypeOrder.ArrayValue */ ;\n    } else if (\"mapValue\" in value) {\n        if (isServerTimestamp(value)) {\n            return 4 /* TypeOrder.ServerTimestampValue */ ;\n        } else if (isMaxValue(value)) {\n            return 9007199254740991 /* TypeOrder.MaxValue */ ;\n        }\n        return 10 /* TypeOrder.ObjectValue */ ;\n    } else {\n        return fail();\n    }\n}\n/** Tests `left` and `right` for equality based on the backend semantics. */ function valueEquals(left, right) {\n    if (left === right) {\n        return true;\n    }\n    const leftType = typeOrder(left);\n    const rightType = typeOrder(right);\n    if (leftType !== rightType) {\n        return false;\n    }\n    switch(leftType){\n        case 0 /* TypeOrder.NullValue */ :\n            return true;\n        case 1 /* TypeOrder.BooleanValue */ :\n            return left.booleanValue === right.booleanValue;\n        case 4 /* TypeOrder.ServerTimestampValue */ :\n            return getLocalWriteTime(left).isEqual(getLocalWriteTime(right));\n        case 3 /* TypeOrder.TimestampValue */ :\n            return timestampEquals(left, right);\n        case 5 /* TypeOrder.StringValue */ :\n            return left.stringValue === right.stringValue;\n        case 6 /* TypeOrder.BlobValue */ :\n            return blobEquals(left, right);\n        case 7 /* TypeOrder.RefValue */ :\n            return left.referenceValue === right.referenceValue;\n        case 8 /* TypeOrder.GeoPointValue */ :\n            return geoPointEquals(left, right);\n        case 2 /* TypeOrder.NumberValue */ :\n            return numberEquals(left, right);\n        case 9 /* TypeOrder.ArrayValue */ :\n            return arrayEquals(left.arrayValue.values || [], right.arrayValue.values || [], valueEquals);\n        case 10 /* TypeOrder.ObjectValue */ :\n            return objectEquals(left, right);\n        case 9007199254740991 /* TypeOrder.MaxValue */ :\n            return true;\n        default:\n            return fail();\n    }\n}\nfunction timestampEquals(left, right) {\n    if (typeof left.timestampValue === \"string\" && typeof right.timestampValue === \"string\" && left.timestampValue.length === right.timestampValue.length) {\n        // Use string equality for ISO 8601 timestamps\n        return left.timestampValue === right.timestampValue;\n    }\n    const leftTimestamp = normalizeTimestamp(left.timestampValue);\n    const rightTimestamp = normalizeTimestamp(right.timestampValue);\n    return leftTimestamp.seconds === rightTimestamp.seconds && leftTimestamp.nanos === rightTimestamp.nanos;\n}\nfunction geoPointEquals(left, right) {\n    return normalizeNumber(left.geoPointValue.latitude) === normalizeNumber(right.geoPointValue.latitude) && normalizeNumber(left.geoPointValue.longitude) === normalizeNumber(right.geoPointValue.longitude);\n}\nfunction blobEquals(left, right) {\n    return normalizeByteString(left.bytesValue).isEqual(normalizeByteString(right.bytesValue));\n}\nfunction numberEquals(left, right) {\n    if (\"integerValue\" in left && \"integerValue\" in right) {\n        return normalizeNumber(left.integerValue) === normalizeNumber(right.integerValue);\n    } else if (\"doubleValue\" in left && \"doubleValue\" in right) {\n        const n1 = normalizeNumber(left.doubleValue);\n        const n2 = normalizeNumber(right.doubleValue);\n        if (n1 === n2) {\n            return isNegativeZero(n1) === isNegativeZero(n2);\n        } else {\n            return isNaN(n1) && isNaN(n2);\n        }\n    }\n    return false;\n}\nfunction objectEquals(left, right) {\n    const leftMap = left.mapValue.fields || {};\n    const rightMap = right.mapValue.fields || {};\n    if (objectSize(leftMap) !== objectSize(rightMap)) {\n        return false;\n    }\n    for(const key in leftMap){\n        if (leftMap.hasOwnProperty(key)) {\n            if (rightMap[key] === undefined || !valueEquals(leftMap[key], rightMap[key])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/** Returns true if the ArrayValue contains the specified element. */ function arrayValueContains(haystack, needle) {\n    return (haystack.values || []).find((v)=>valueEquals(v, needle)) !== undefined;\n}\nfunction valueCompare(left, right) {\n    if (left === right) {\n        return 0;\n    }\n    const leftType = typeOrder(left);\n    const rightType = typeOrder(right);\n    if (leftType !== rightType) {\n        return primitiveComparator(leftType, rightType);\n    }\n    switch(leftType){\n        case 0 /* TypeOrder.NullValue */ :\n        case 9007199254740991 /* TypeOrder.MaxValue */ :\n            return 0;\n        case 1 /* TypeOrder.BooleanValue */ :\n            return primitiveComparator(left.booleanValue, right.booleanValue);\n        case 2 /* TypeOrder.NumberValue */ :\n            return compareNumbers(left, right);\n        case 3 /* TypeOrder.TimestampValue */ :\n            return compareTimestamps(left.timestampValue, right.timestampValue);\n        case 4 /* TypeOrder.ServerTimestampValue */ :\n            return compareTimestamps(getLocalWriteTime(left), getLocalWriteTime(right));\n        case 5 /* TypeOrder.StringValue */ :\n            return primitiveComparator(left.stringValue, right.stringValue);\n        case 6 /* TypeOrder.BlobValue */ :\n            return compareBlobs(left.bytesValue, right.bytesValue);\n        case 7 /* TypeOrder.RefValue */ :\n            return compareReferences(left.referenceValue, right.referenceValue);\n        case 8 /* TypeOrder.GeoPointValue */ :\n            return compareGeoPoints(left.geoPointValue, right.geoPointValue);\n        case 9 /* TypeOrder.ArrayValue */ :\n            return compareArrays(left.arrayValue, right.arrayValue);\n        case 10 /* TypeOrder.ObjectValue */ :\n            return compareMaps(left.mapValue, right.mapValue);\n        default:\n            throw fail();\n    }\n}\nfunction compareNumbers(left, right) {\n    const leftNumber = normalizeNumber(left.integerValue || left.doubleValue);\n    const rightNumber = normalizeNumber(right.integerValue || right.doubleValue);\n    if (leftNumber < rightNumber) {\n        return -1;\n    } else if (leftNumber > rightNumber) {\n        return 1;\n    } else if (leftNumber === rightNumber) {\n        return 0;\n    } else {\n        // one or both are NaN.\n        if (isNaN(leftNumber)) {\n            return isNaN(rightNumber) ? 0 : -1;\n        } else {\n            return 1;\n        }\n    }\n}\nfunction compareTimestamps(left, right) {\n    if (typeof left === \"string\" && typeof right === \"string\" && left.length === right.length) {\n        return primitiveComparator(left, right);\n    }\n    const leftTimestamp = normalizeTimestamp(left);\n    const rightTimestamp = normalizeTimestamp(right);\n    const comparison = primitiveComparator(leftTimestamp.seconds, rightTimestamp.seconds);\n    if (comparison !== 0) {\n        return comparison;\n    }\n    return primitiveComparator(leftTimestamp.nanos, rightTimestamp.nanos);\n}\nfunction compareReferences(leftPath, rightPath) {\n    const leftSegments = leftPath.split(\"/\");\n    const rightSegments = rightPath.split(\"/\");\n    for(let i = 0; i < leftSegments.length && i < rightSegments.length; i++){\n        const comparison = primitiveComparator(leftSegments[i], rightSegments[i]);\n        if (comparison !== 0) {\n            return comparison;\n        }\n    }\n    return primitiveComparator(leftSegments.length, rightSegments.length);\n}\nfunction compareGeoPoints(left, right) {\n    const comparison = primitiveComparator(normalizeNumber(left.latitude), normalizeNumber(right.latitude));\n    if (comparison !== 0) {\n        return comparison;\n    }\n    return primitiveComparator(normalizeNumber(left.longitude), normalizeNumber(right.longitude));\n}\nfunction compareBlobs(left, right) {\n    const leftBytes = normalizeByteString(left);\n    const rightBytes = normalizeByteString(right);\n    return leftBytes.compareTo(rightBytes);\n}\nfunction compareArrays(left, right) {\n    const leftArray = left.values || [];\n    const rightArray = right.values || [];\n    for(let i = 0; i < leftArray.length && i < rightArray.length; ++i){\n        const compare = valueCompare(leftArray[i], rightArray[i]);\n        if (compare) {\n            return compare;\n        }\n    }\n    return primitiveComparator(leftArray.length, rightArray.length);\n}\nfunction compareMaps(left, right) {\n    if (left === MAX_VALUE.mapValue && right === MAX_VALUE.mapValue) {\n        return 0;\n    } else if (left === MAX_VALUE.mapValue) {\n        return 1;\n    } else if (right === MAX_VALUE.mapValue) {\n        return -1;\n    }\n    const leftMap = left.fields || {};\n    const leftKeys = Object.keys(leftMap);\n    const rightMap = right.fields || {};\n    const rightKeys = Object.keys(rightMap);\n    // Even though MapValues are likely sorted correctly based on their insertion\n    // order (e.g. when received from the backend), local modifications can bring\n    // elements out of order. We need to re-sort the elements to ensure that\n    // canonical IDs are independent of insertion order.\n    leftKeys.sort();\n    rightKeys.sort();\n    for(let i = 0; i < leftKeys.length && i < rightKeys.length; ++i){\n        const keyCompare = primitiveComparator(leftKeys[i], rightKeys[i]);\n        if (keyCompare !== 0) {\n            return keyCompare;\n        }\n        const compare = valueCompare(leftMap[leftKeys[i]], rightMap[rightKeys[i]]);\n        if (compare !== 0) {\n            return compare;\n        }\n    }\n    return primitiveComparator(leftKeys.length, rightKeys.length);\n}\n/** Returns a reference value for the provided database and key. */ function refValue(databaseId, key) {\n    return {\n        referenceValue: `projects/${databaseId.projectId}/databases/${databaseId.database}/documents/${key.path.canonicalString()}`\n    };\n}\n/** Returns true if `value` is an ArrayValue. */ function isArray(value) {\n    return !!value && \"arrayValue\" in value;\n}\n/** Returns true if `value` is a NullValue. */ function isNullValue(value) {\n    return !!value && \"nullValue\" in value;\n}\n/** Returns true if `value` is NaN. */ function isNanValue(value) {\n    return !!value && \"doubleValue\" in value && isNaN(Number(value.doubleValue));\n}\n/** Returns true if `value` is a MapValue. */ function isMapValue(value) {\n    return !!value && \"mapValue\" in value;\n}\n/** Creates a deep copy of `source`. */ function deepClone(source) {\n    if (source.geoPointValue) {\n        return {\n            geoPointValue: Object.assign({}, source.geoPointValue)\n        };\n    } else if (source.timestampValue && typeof source.timestampValue === \"object\") {\n        return {\n            timestampValue: Object.assign({}, source.timestampValue)\n        };\n    } else if (source.mapValue) {\n        const target = {\n            mapValue: {\n                fields: {}\n            }\n        };\n        forEach(source.mapValue.fields, (key, val)=>target.mapValue.fields[key] = deepClone(val));\n        return target;\n    } else if (source.arrayValue) {\n        const target = {\n            arrayValue: {\n                values: []\n            }\n        };\n        for(let i = 0; i < (source.arrayValue.values || []).length; ++i){\n            target.arrayValue.values[i] = deepClone(source.arrayValue.values[i]);\n        }\n        return target;\n    } else {\n        return Object.assign({}, source);\n    }\n}\n/** Returns true if the Value represents the canonical {@link #MAX_VALUE} . */ function isMaxValue(value) {\n    return (((value.mapValue || {}).fields || {})[\"__type__\"] || {}).stringValue === MAX_VALUE_TYPE;\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Represents a bound of a query.\r\n *\r\n * The bound is specified with the given components representing a position and\r\n * whether it's just before or just after the position (relative to whatever the\r\n * query order is).\r\n *\r\n * The position represents a logical index position for a query. It's a prefix\r\n * of values for the (potentially implicit) order by clauses of a query.\r\n *\r\n * Bound provides a function to determine whether a document comes before or\r\n * after a bound. This is influenced by whether the position is just before or\r\n * just after the provided values.\r\n */ class Bound {\n    constructor(position, inclusive){\n        this.position = position;\n        this.inclusive = inclusive;\n    }\n}\nfunction boundEquals(left, right) {\n    if (left === null) {\n        return right === null;\n    } else if (right === null) {\n        return false;\n    }\n    if (left.inclusive !== right.inclusive || left.position.length !== right.position.length) {\n        return false;\n    }\n    for(let i = 0; i < left.position.length; i++){\n        const leftPosition = left.position[i];\n        const rightPosition = right.position[i];\n        if (!valueEquals(leftPosition, rightPosition)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Filter {\n}\nclass FieldFilter extends Filter {\n    constructor(field, op, value){\n        super();\n        this.field = field;\n        this.op = op;\n        this.value = value;\n    }\n    /**\r\n     * Creates a filter based on the provided arguments.\r\n     */ static create(field, op, value) {\n        if (field.isKeyField()) {\n            if (op === \"in\" /* Operator.IN */  || op === \"not-in\" /* Operator.NOT_IN */ ) {\n                return this.createKeyFieldInFilter(field, op, value);\n            } else {\n                return new KeyFieldFilter(field, op, value);\n            }\n        } else if (op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ) {\n            return new ArrayContainsFilter(field, value);\n        } else if (op === \"in\" /* Operator.IN */ ) {\n            return new InFilter(field, value);\n        } else if (op === \"not-in\" /* Operator.NOT_IN */ ) {\n            return new NotInFilter(field, value);\n        } else if (op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */ ) {\n            return new ArrayContainsAnyFilter(field, value);\n        } else {\n            return new FieldFilter(field, op, value);\n        }\n    }\n    static createKeyFieldInFilter(field, op, value) {\n        return op === \"in\" /* Operator.IN */  ? new KeyFieldInFilter(field, value) : new KeyFieldNotInFilter(field, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        // Types do not have to match in NOT_EQUAL filters.\n        if (this.op === \"!=\" /* Operator.NOT_EQUAL */ ) {\n            return other !== null && this.matchesComparison(valueCompare(other, this.value));\n        }\n        // Only compare types with matching backend order (such as double and int).\n        return other !== null && typeOrder(this.value) === typeOrder(other) && this.matchesComparison(valueCompare(other, this.value));\n    }\n    matchesComparison(comparison) {\n        switch(this.op){\n            case \"<\" /* Operator.LESS_THAN */ :\n                return comparison < 0;\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */ :\n                return comparison <= 0;\n            case \"==\" /* Operator.EQUAL */ :\n                return comparison === 0;\n            case \"!=\" /* Operator.NOT_EQUAL */ :\n                return comparison !== 0;\n            case \">\" /* Operator.GREATER_THAN */ :\n                return comparison > 0;\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */ :\n                return comparison >= 0;\n            default:\n                return fail();\n        }\n    }\n    isInequality() {\n        return [\n            \"<\" /* Operator.LESS_THAN */ ,\n            \"<=\" /* Operator.LESS_THAN_OR_EQUAL */ ,\n            \">\" /* Operator.GREATER_THAN */ ,\n            \">=\" /* Operator.GREATER_THAN_OR_EQUAL */ ,\n            \"!=\" /* Operator.NOT_EQUAL */ ,\n            \"not-in\" /* Operator.NOT_IN */ \n        ].indexOf(this.op) >= 0;\n    }\n    getFlattenedFilters() {\n        return [\n            this\n        ];\n    }\n    getFilters() {\n        return [\n            this\n        ];\n    }\n}\nclass CompositeFilter extends Filter {\n    constructor(filters, op){\n        super();\n        this.filters = filters;\n        this.op = op;\n        this.memoizedFlattenedFilters = null;\n    }\n    /**\r\n     * Creates a filter based on the provided arguments.\r\n     */ static create(filters, op) {\n        return new CompositeFilter(filters, op);\n    }\n    matches(doc) {\n        if (compositeFilterIsConjunction(this)) {\n            // For conjunctions, all filters must match, so return false if any filter doesn't match.\n            return this.filters.find((filter)=>!filter.matches(doc)) === undefined;\n        } else {\n            // For disjunctions, at least one filter should match.\n            return this.filters.find((filter)=>filter.matches(doc)) !== undefined;\n        }\n    }\n    getFlattenedFilters() {\n        if (this.memoizedFlattenedFilters !== null) {\n            return this.memoizedFlattenedFilters;\n        }\n        this.memoizedFlattenedFilters = this.filters.reduce((result, subfilter)=>{\n            return result.concat(subfilter.getFlattenedFilters());\n        }, []);\n        return this.memoizedFlattenedFilters;\n    }\n    // Returns a mutable copy of `this.filters`\n    getFilters() {\n        return Object.assign([], this.filters);\n    }\n}\nfunction compositeFilterIsConjunction(compositeFilter) {\n    return compositeFilter.op === \"and\" /* CompositeOperator.AND */ ;\n}\nfunction filterEquals(f1, f2) {\n    if (f1 instanceof FieldFilter) {\n        return fieldFilterEquals(f1, f2);\n    } else if (f1 instanceof CompositeFilter) {\n        return compositeFilterEquals(f1, f2);\n    } else {\n        fail();\n    }\n}\nfunction fieldFilterEquals(f1, f2) {\n    return f2 instanceof FieldFilter && f1.op === f2.op && f1.field.isEqual(f2.field) && valueEquals(f1.value, f2.value);\n}\nfunction compositeFilterEquals(f1, f2) {\n    if (f2 instanceof CompositeFilter && f1.op === f2.op && f1.filters.length === f2.filters.length) {\n        const subFiltersMatch = f1.filters.reduce((result, f1Filter, index)=>result && filterEquals(f1Filter, f2.filters[index]), true);\n        return subFiltersMatch;\n    }\n    return false;\n}\n/** Filter that matches on key fields (i.e. '__name__'). */ class KeyFieldFilter extends FieldFilter {\n    constructor(field, op, value){\n        super(field, op, value);\n        this.key = DocumentKey.fromName(value.referenceValue);\n    }\n    matches(doc) {\n        const comparison = DocumentKey.comparator(doc.key, this.key);\n        return this.matchesComparison(comparison);\n    }\n}\n/** Filter that matches on key fields within an array. */ class KeyFieldInFilter extends FieldFilter {\n    constructor(field, value){\n        super(field, \"in\" /* Operator.IN */ , value);\n        this.keys = extractDocumentKeysFromArrayValue(\"in\" /* Operator.IN */ , value);\n    }\n    matches(doc) {\n        return this.keys.some((key)=>key.isEqual(doc.key));\n    }\n}\n/** Filter that matches on key fields not present within an array. */ class KeyFieldNotInFilter extends FieldFilter {\n    constructor(field, value){\n        super(field, \"not-in\" /* Operator.NOT_IN */ , value);\n        this.keys = extractDocumentKeysFromArrayValue(\"not-in\" /* Operator.NOT_IN */ , value);\n    }\n    matches(doc) {\n        return !this.keys.some((key)=>key.isEqual(doc.key));\n    }\n}\nfunction extractDocumentKeysFromArrayValue(op, value) {\n    var _a;\n    return (((_a = value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) || []).map((v)=>{\n        return DocumentKey.fromName(v.referenceValue);\n    });\n}\n/** A Filter that implements the array-contains operator. */ class ArrayContainsFilter extends FieldFilter {\n    constructor(field, value){\n        super(field, \"array-contains\" /* Operator.ARRAY_CONTAINS */ , value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        return isArray(other) && arrayValueContains(other.arrayValue, this.value);\n    }\n}\n/** A Filter that implements the IN operator. */ class InFilter extends FieldFilter {\n    constructor(field, value){\n        super(field, \"in\" /* Operator.IN */ , value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        return other !== null && arrayValueContains(this.value.arrayValue, other);\n    }\n}\n/** A Filter that implements the not-in operator. */ class NotInFilter extends FieldFilter {\n    constructor(field, value){\n        super(field, \"not-in\" /* Operator.NOT_IN */ , value);\n    }\n    matches(doc) {\n        if (arrayValueContains(this.value.arrayValue, {\n            nullValue: \"NULL_VALUE\"\n        })) {\n            return false;\n        }\n        const other = doc.data.field(this.field);\n        return other !== null && !arrayValueContains(this.value.arrayValue, other);\n    }\n}\n/** A Filter that implements the array-contains-any operator. */ class ArrayContainsAnyFilter extends FieldFilter {\n    constructor(field, value){\n        super(field, \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */ , value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        if (!isArray(other) || !other.arrayValue.values) {\n            return false;\n        }\n        return other.arrayValue.values.some((val)=>arrayValueContains(this.value.arrayValue, val));\n    }\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\r\n */ class OrderBy {\n    constructor(field, dir = \"asc\" /* Direction.ASCENDING */ ){\n        this.field = field;\n        this.dir = dir;\n    }\n}\nfunction orderByEquals(left, right) {\n    return left.dir === right.dir && left.field.isEqual(right.field);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A version of a document in Firestore. This corresponds to the version\r\n * timestamp, such as update_time or read_time.\r\n */ class SnapshotVersion {\n    constructor(timestamp){\n        this.timestamp = timestamp;\n    }\n    static fromTimestamp(value) {\n        return new SnapshotVersion(value);\n    }\n    static min() {\n        return new SnapshotVersion(new Timestamp(0, 0));\n    }\n    static max() {\n        return new SnapshotVersion(new Timestamp(253402300799, 1e9 - 1));\n    }\n    compareTo(other) {\n        return this.timestamp._compareTo(other.timestamp);\n    }\n    isEqual(other) {\n        return this.timestamp.isEqual(other.timestamp);\n    }\n    /** Returns a number representation of the version for use in spec tests. */ toMicroseconds() {\n        // Convert to microseconds.\n        return this.timestamp.seconds * 1e6 + this.timestamp.nanoseconds / 1000;\n    }\n    toString() {\n        return \"SnapshotVersion(\" + this.timestamp.toString() + \")\";\n    }\n    toTimestamp() {\n        return this.timestamp;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // An immutable sorted map implementation, based on a Left-leaning Red-Black\n// tree.\nclass SortedMap {\n    constructor(comparator, root){\n        this.comparator = comparator;\n        this.root = root ? root : LLRBNode.EMPTY;\n    }\n    // Returns a copy of the map, with the specified key/value added or replaced.\n    insert(key, value) {\n        return new SortedMap(this.comparator, this.root.insert(key, value, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));\n    }\n    // Returns a copy of the map, with the specified key removed.\n    remove(key) {\n        return new SortedMap(this.comparator, this.root.remove(key, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));\n    }\n    // Returns the value of the node with the given key, or null.\n    get(key) {\n        let node = this.root;\n        while(!node.isEmpty()){\n            const cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return node.value;\n            } else if (cmp < 0) {\n                node = node.left;\n            } else if (cmp > 0) {\n                node = node.right;\n            }\n        }\n        return null;\n    }\n    // Returns the index of the element in this sorted map, or -1 if it doesn't\n    // exist.\n    indexOf(key) {\n        // Number of nodes that were pruned when descending right\n        let prunedNodes = 0;\n        let node = this.root;\n        while(!node.isEmpty()){\n            const cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return prunedNodes + node.left.size;\n            } else if (cmp < 0) {\n                node = node.left;\n            } else {\n                // Count all nodes left of the node plus the node itself\n                prunedNodes += node.left.size + 1;\n                node = node.right;\n            }\n        }\n        // Node not found\n        return -1;\n    }\n    isEmpty() {\n        return this.root.isEmpty();\n    }\n    // Returns the total number of nodes in the map.\n    get size() {\n        return this.root.size;\n    }\n    // Returns the minimum key in the map.\n    minKey() {\n        return this.root.minKey();\n    }\n    // Returns the maximum key in the map.\n    maxKey() {\n        return this.root.maxKey();\n    }\n    // Traverses the map in key order and calls the specified action function\n    // for each key/value pair. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    inorderTraversal(action) {\n        return this.root.inorderTraversal(action);\n    }\n    forEach(fn) {\n        this.inorderTraversal((k, v)=>{\n            fn(k, v);\n            return false;\n        });\n    }\n    toString() {\n        const descriptions = [];\n        this.inorderTraversal((k, v)=>{\n            descriptions.push(`${k}:${v}`);\n            return false;\n        });\n        return `{${descriptions.join(\", \")}}`;\n    }\n    // Traverses the map in reverse key order and calls the specified action\n    // function for each key/value pair. If action returns true, traversal is\n    // aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    reverseTraversal(action) {\n        return this.root.reverseTraversal(action);\n    }\n    // Returns an iterator over the SortedMap.\n    getIterator() {\n        return new SortedMapIterator(this.root, null, this.comparator, false);\n    }\n    getIteratorFrom(key) {\n        return new SortedMapIterator(this.root, key, this.comparator, false);\n    }\n    getReverseIterator() {\n        return new SortedMapIterator(this.root, null, this.comparator, true);\n    }\n    getReverseIteratorFrom(key) {\n        return new SortedMapIterator(this.root, key, this.comparator, true);\n    }\n} // end SortedMap\n// An iterator over an LLRBNode.\nclass SortedMapIterator {\n    constructor(node, startKey, comparator, isReverse){\n        this.isReverse = isReverse;\n        this.nodeStack = [];\n        let cmp = 1;\n        while(!node.isEmpty()){\n            cmp = startKey ? comparator(node.key, startKey) : 1;\n            // flip the comparison if we're going in reverse\n            if (startKey && isReverse) {\n                cmp *= -1;\n            }\n            if (cmp < 0) {\n                // This node is less than our start key. ignore it\n                if (this.isReverse) {\n                    node = node.left;\n                } else {\n                    node = node.right;\n                }\n            } else if (cmp === 0) {\n                // This node is exactly equal to our start key. Push it on the stack,\n                // but stop iterating;\n                this.nodeStack.push(node);\n                break;\n            } else {\n                // This node is greater than our start key, add it to the stack and move\n                // to the next one\n                this.nodeStack.push(node);\n                if (this.isReverse) {\n                    node = node.right;\n                } else {\n                    node = node.left;\n                }\n            }\n        }\n    }\n    getNext() {\n        let node = this.nodeStack.pop();\n        const result = {\n            key: node.key,\n            value: node.value\n        };\n        if (this.isReverse) {\n            node = node.left;\n            while(!node.isEmpty()){\n                this.nodeStack.push(node);\n                node = node.right;\n            }\n        } else {\n            node = node.right;\n            while(!node.isEmpty()){\n                this.nodeStack.push(node);\n                node = node.left;\n            }\n        }\n        return result;\n    }\n    hasNext() {\n        return this.nodeStack.length > 0;\n    }\n    peek() {\n        if (this.nodeStack.length === 0) {\n            return null;\n        }\n        const node = this.nodeStack[this.nodeStack.length - 1];\n        return {\n            key: node.key,\n            value: node.value\n        };\n    }\n} // end SortedMapIterator\n// Represents a node in a Left-leaning Red-Black tree.\nclass LLRBNode {\n    constructor(key, value, color, left, right){\n        this.key = key;\n        this.value = value;\n        this.color = color != null ? color : LLRBNode.RED;\n        this.left = left != null ? left : LLRBNode.EMPTY;\n        this.right = right != null ? right : LLRBNode.EMPTY;\n        this.size = this.left.size + 1 + this.right.size;\n    }\n    // Returns a copy of the current node, optionally replacing pieces of it.\n    copy(key, value, color, left, right) {\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\n    }\n    isEmpty() {\n        return false;\n    }\n    // Traverses the tree in key order and calls the specified action function\n    // for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    inorderTraversal(action) {\n        return this.left.inorderTraversal(action) || action(this.key, this.value) || this.right.inorderTraversal(action);\n    }\n    // Traverses the tree in reverse key order and calls the specified action\n    // function for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    reverseTraversal(action) {\n        return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);\n    }\n    // Returns the minimum node in the tree.\n    min() {\n        if (this.left.isEmpty()) {\n            return this;\n        } else {\n            return this.left.min();\n        }\n    }\n    // Returns the maximum key in the tree.\n    minKey() {\n        return this.min().key;\n    }\n    // Returns the maximum key in the tree.\n    maxKey() {\n        if (this.right.isEmpty()) {\n            return this.key;\n        } else {\n            return this.right.maxKey();\n        }\n    }\n    // Returns new tree, with the key/value added.\n    insert(key, value, comparator) {\n        let n = this;\n        const cmp = comparator(key, n.key);\n        if (cmp < 0) {\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n        } else if (cmp === 0) {\n            n = n.copy(null, value, null, null, null);\n        } else {\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\n        }\n        return n.fixUp();\n    }\n    removeMin() {\n        if (this.left.isEmpty()) {\n            return LLRBNode.EMPTY;\n        }\n        let n = this;\n        if (!n.left.isRed() && !n.left.left.isRed()) {\n            n = n.moveRedLeft();\n        }\n        n = n.copy(null, null, null, n.left.removeMin(), null);\n        return n.fixUp();\n    }\n    // Returns new tree, with the specified item removed.\n    remove(key, comparator) {\n        let smallest;\n        let n = this;\n        if (comparator(key, n.key) < 0) {\n            if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\n                n = n.moveRedLeft();\n            }\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n        } else {\n            if (n.left.isRed()) {\n                n = n.rotateRight();\n            }\n            if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\n                n = n.moveRedRight();\n            }\n            if (comparator(key, n.key) === 0) {\n                if (n.right.isEmpty()) {\n                    return LLRBNode.EMPTY;\n                } else {\n                    smallest = n.right.min();\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());\n                }\n            }\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n        }\n        return n.fixUp();\n    }\n    isRed() {\n        return this.color;\n    }\n    // Returns new tree after performing any needed rotations.\n    fixUp() {\n        let n = this;\n        if (n.right.isRed() && !n.left.isRed()) {\n            n = n.rotateLeft();\n        }\n        if (n.left.isRed() && n.left.left.isRed()) {\n            n = n.rotateRight();\n        }\n        if (n.left.isRed() && n.right.isRed()) {\n            n = n.colorFlip();\n        }\n        return n;\n    }\n    moveRedLeft() {\n        let n = this.colorFlip();\n        if (n.right.left.isRed()) {\n            n = n.copy(null, null, null, null, n.right.rotateRight());\n            n = n.rotateLeft();\n            n = n.colorFlip();\n        }\n        return n;\n    }\n    moveRedRight() {\n        let n = this.colorFlip();\n        if (n.left.left.isRed()) {\n            n = n.rotateRight();\n            n = n.colorFlip();\n        }\n        return n;\n    }\n    rotateLeft() {\n        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n        return this.right.copy(null, null, this.color, nl, null);\n    }\n    rotateRight() {\n        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n        return this.left.copy(null, null, this.color, null, nr);\n    }\n    colorFlip() {\n        const left = this.left.copy(null, null, !this.left.color, null, null);\n        const right = this.right.copy(null, null, !this.right.color, null, null);\n        return this.copy(null, null, !this.color, left, right);\n    }\n    // For testing.\n    checkMaxDepth() {\n        const blackDepth = this.check();\n        if (Math.pow(2.0, blackDepth) <= this.size + 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // In a balanced RB tree, the black-depth (number of black nodes) from root to\n    // leaves is equal on both sides.  This function verifies that or asserts.\n    check() {\n        if (this.isRed() && this.left.isRed()) {\n            throw fail();\n        }\n        if (this.right.isRed()) {\n            throw fail();\n        }\n        const blackDepth = this.left.check();\n        if (blackDepth !== this.right.check()) {\n            throw fail();\n        } else {\n            return blackDepth + (this.isRed() ? 0 : 1);\n        }\n    }\n} // end LLRBNode\n// Empty node is shared between all LLRB trees.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nLLRBNode.EMPTY = null;\nLLRBNode.RED = true;\nLLRBNode.BLACK = false;\n// Represents an empty node (a leaf node in the Red-Black Tree).\nclass LLRBEmptyNode {\n    constructor(){\n        this.size = 0;\n    }\n    get key() {\n        throw fail();\n    }\n    get value() {\n        throw fail();\n    }\n    get color() {\n        throw fail();\n    }\n    get left() {\n        throw fail();\n    }\n    get right() {\n        throw fail();\n    }\n    // Returns a copy of the current node.\n    copy(key, value, color, left, right) {\n        return this;\n    }\n    // Returns a copy of the tree, with the specified key/value added.\n    insert(key, value, comparator) {\n        return new LLRBNode(key, value);\n    }\n    // Returns a copy of the tree, with the specified key removed.\n    remove(key, comparator) {\n        return this;\n    }\n    isEmpty() {\n        return true;\n    }\n    inorderTraversal(action) {\n        return false;\n    }\n    reverseTraversal(action) {\n        return false;\n    }\n    minKey() {\n        return null;\n    }\n    maxKey() {\n        return null;\n    }\n    isRed() {\n        return false;\n    }\n    // For testing.\n    checkMaxDepth() {\n        return true;\n    }\n    check() {\n        return 0;\n    }\n} // end LLRBEmptyNode\nLLRBNode.EMPTY = new LLRBEmptyNode();\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * SortedSet is an immutable (copy-on-write) collection that holds elements\r\n * in order specified by the provided comparator.\r\n *\r\n * NOTE: if provided comparator returns 0 for two elements, we consider them to\r\n * be equal!\r\n */ class SortedSet {\n    constructor(comparator){\n        this.comparator = comparator;\n        this.data = new SortedMap(this.comparator);\n    }\n    has(elem) {\n        return this.data.get(elem) !== null;\n    }\n    first() {\n        return this.data.minKey();\n    }\n    last() {\n        return this.data.maxKey();\n    }\n    get size() {\n        return this.data.size;\n    }\n    indexOf(elem) {\n        return this.data.indexOf(elem);\n    }\n    /** Iterates elements in order defined by \"comparator\" */ forEach(cb) {\n        this.data.inorderTraversal((k, v)=>{\n            cb(k);\n            return false;\n        });\n    }\n    /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */ forEachInRange(range, cb) {\n        const iter = this.data.getIteratorFrom(range[0]);\n        while(iter.hasNext()){\n            const elem = iter.getNext();\n            if (this.comparator(elem.key, range[1]) >= 0) {\n                return;\n            }\n            cb(elem.key);\n        }\n    }\n    /**\r\n     * Iterates over `elem`s such that: start &lt;= elem until false is returned.\r\n     */ forEachWhile(cb, start) {\n        let iter;\n        if (start !== undefined) {\n            iter = this.data.getIteratorFrom(start);\n        } else {\n            iter = this.data.getIterator();\n        }\n        while(iter.hasNext()){\n            const elem = iter.getNext();\n            const result = cb(elem.key);\n            if (!result) {\n                return;\n            }\n        }\n    }\n    /** Finds the least element greater than or equal to `elem`. */ firstAfterOrEqual(elem) {\n        const iter = this.data.getIteratorFrom(elem);\n        return iter.hasNext() ? iter.getNext().key : null;\n    }\n    getIterator() {\n        return new SortedSetIterator(this.data.getIterator());\n    }\n    getIteratorFrom(key) {\n        return new SortedSetIterator(this.data.getIteratorFrom(key));\n    }\n    /** Inserts or updates an element */ add(elem) {\n        return this.copy(this.data.remove(elem).insert(elem, true));\n    }\n    /** Deletes an element */ delete(elem) {\n        if (!this.has(elem)) {\n            return this;\n        }\n        return this.copy(this.data.remove(elem));\n    }\n    isEmpty() {\n        return this.data.isEmpty();\n    }\n    unionWith(other) {\n        let result = this;\n        // Make sure `result` always refers to the larger one of the two sets.\n        if (result.size < other.size) {\n            result = other;\n            other = this;\n        }\n        other.forEach((elem)=>{\n            result = result.add(elem);\n        });\n        return result;\n    }\n    isEqual(other) {\n        if (!(other instanceof SortedSet)) {\n            return false;\n        }\n        if (this.size !== other.size) {\n            return false;\n        }\n        const thisIt = this.data.getIterator();\n        const otherIt = other.data.getIterator();\n        while(thisIt.hasNext()){\n            const thisElem = thisIt.getNext().key;\n            const otherElem = otherIt.getNext().key;\n            if (this.comparator(thisElem, otherElem) !== 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    toArray() {\n        const res = [];\n        this.forEach((targetId)=>{\n            res.push(targetId);\n        });\n        return res;\n    }\n    toString() {\n        const result = [];\n        this.forEach((elem)=>result.push(elem));\n        return \"SortedSet(\" + result.toString() + \")\";\n    }\n    copy(data) {\n        const result = new SortedSet(this.comparator);\n        result.data = data;\n        return result;\n    }\n}\nclass SortedSetIterator {\n    constructor(iter){\n        this.iter = iter;\n    }\n    getNext() {\n        return this.iter.getNext().key;\n    }\n    hasNext() {\n        return this.iter.hasNext();\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provides a set of fields that can be used to partially patch a document.\r\n * FieldMask is used in conjunction with ObjectValue.\r\n * Examples:\r\n *   foo - Overwrites foo entirely with the provided value. If foo is not\r\n *         present in the companion ObjectValue, the field is deleted.\r\n *   foo.bar - Overwrites only the field bar of the object foo.\r\n *             If foo is not an object, foo is replaced with an object\r\n *             containing foo\r\n */ class FieldMask {\n    constructor(fields){\n        this.fields = fields;\n        // TODO(dimond): validation of FieldMask\n        // Sort the field mask to support `FieldMask.isEqual()` and assert below.\n        fields.sort(FieldPath$1.comparator);\n    }\n    static empty() {\n        return new FieldMask([]);\n    }\n    /**\r\n     * Returns a new FieldMask object that is the result of adding all the given\r\n     * fields paths to this field mask.\r\n     */ unionWith(extraFields) {\n        let mergedMaskSet = new SortedSet(FieldPath$1.comparator);\n        for (const fieldPath of this.fields){\n            mergedMaskSet = mergedMaskSet.add(fieldPath);\n        }\n        for (const fieldPath of extraFields){\n            mergedMaskSet = mergedMaskSet.add(fieldPath);\n        }\n        return new FieldMask(mergedMaskSet.toArray());\n    }\n    /**\r\n     * Verifies that `fieldPath` is included by at least one field in this field\r\n     * mask.\r\n     *\r\n     * This is an O(n) operation, where `n` is the size of the field mask.\r\n     */ covers(fieldPath) {\n        for (const fieldMaskPath of this.fields){\n            if (fieldMaskPath.isPrefixOf(fieldPath)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isEqual(other) {\n        return arrayEquals(this.fields, other.fields, (l, r)=>l.isEqual(r));\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An ObjectValue represents a MapValue in the Firestore Proto and offers the\r\n * ability to add and remove fields (via the ObjectValueBuilder).\r\n */ class ObjectValue {\n    constructor(value){\n        this.value = value;\n    }\n    static empty() {\n        return new ObjectValue({\n            mapValue: {}\n        });\n    }\n    /**\r\n     * Returns the value at the given path or null.\r\n     *\r\n     * @param path - the path to search\r\n     * @returns The value at the path or null if the path is not set.\r\n     */ field(path) {\n        if (path.isEmpty()) {\n            return this.value;\n        } else {\n            let currentLevel = this.value;\n            for(let i = 0; i < path.length - 1; ++i){\n                currentLevel = (currentLevel.mapValue.fields || {})[path.get(i)];\n                if (!isMapValue(currentLevel)) {\n                    return null;\n                }\n            }\n            currentLevel = (currentLevel.mapValue.fields || {})[path.lastSegment()];\n            return currentLevel || null;\n        }\n    }\n    /**\r\n     * Sets the field to the provided value.\r\n     *\r\n     * @param path - The field path to set.\r\n     * @param value - The value to set.\r\n     */ set(path, value) {\n        const fieldsMap = this.getFieldsMap(path.popLast());\n        fieldsMap[path.lastSegment()] = deepClone(value);\n    }\n    /**\r\n     * Sets the provided fields to the provided values.\r\n     *\r\n     * @param data - A map of fields to values (or null for deletes).\r\n     */ setAll(data) {\n        let parent = FieldPath$1.emptyPath();\n        let upserts = {};\n        let deletes = [];\n        data.forEach((value, path)=>{\n            if (!parent.isImmediateParentOf(path)) {\n                // Insert the accumulated changes at this parent location\n                const fieldsMap = this.getFieldsMap(parent);\n                this.applyChanges(fieldsMap, upserts, deletes);\n                upserts = {};\n                deletes = [];\n                parent = path.popLast();\n            }\n            if (value) {\n                upserts[path.lastSegment()] = deepClone(value);\n            } else {\n                deletes.push(path.lastSegment());\n            }\n        });\n        const fieldsMap = this.getFieldsMap(parent);\n        this.applyChanges(fieldsMap, upserts, deletes);\n    }\n    /**\r\n     * Removes the field at the specified path. If there is no field at the\r\n     * specified path, nothing is changed.\r\n     *\r\n     * @param path - The field path to remove.\r\n     */ delete(path) {\n        const nestedValue = this.field(path.popLast());\n        if (isMapValue(nestedValue) && nestedValue.mapValue.fields) {\n            delete nestedValue.mapValue.fields[path.lastSegment()];\n        }\n    }\n    isEqual(other) {\n        return valueEquals(this.value, other.value);\n    }\n    /**\r\n     * Returns the map that contains the leaf element of `path`. If the parent\r\n     * entry does not yet exist, or if it is not a map, a new map will be created.\r\n     */ getFieldsMap(path) {\n        let current = this.value;\n        if (!current.mapValue.fields) {\n            current.mapValue = {\n                fields: {}\n            };\n        }\n        for(let i = 0; i < path.length; ++i){\n            let next = current.mapValue.fields[path.get(i)];\n            if (!isMapValue(next) || !next.mapValue.fields) {\n                next = {\n                    mapValue: {\n                        fields: {}\n                    }\n                };\n                current.mapValue.fields[path.get(i)] = next;\n            }\n            current = next;\n        }\n        return current.mapValue.fields;\n    }\n    /**\r\n     * Modifies `fieldsMap` by adding, replacing or deleting the specified\r\n     * entries.\r\n     */ applyChanges(fieldsMap, inserts, deletes) {\n        forEach(inserts, (key, val)=>fieldsMap[key] = val);\n        for (const field of deletes){\n            delete fieldsMap[field];\n        }\n    }\n    clone() {\n        return new ObjectValue(deepClone(this.value));\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Represents a document in Firestore with a key, version, data and whether it\r\n * has local mutations applied to it.\r\n *\r\n * Documents can transition between states via `convertToFoundDocument()`,\r\n * `convertToNoDocument()` and `convertToUnknownDocument()`. If a document does\r\n * not transition to one of these states even after all mutations have been\r\n * applied, `isValidDocument()` returns false and the document should be removed\r\n * from all views.\r\n */ class MutableDocument {\n    constructor(key, documentType, version, readTime, createTime, data, documentState){\n        this.key = key;\n        this.documentType = documentType;\n        this.version = version;\n        this.readTime = readTime;\n        this.createTime = createTime;\n        this.data = data;\n        this.documentState = documentState;\n    }\n    /**\r\n     * Creates a document with no known version or data, but which can serve as\r\n     * base document for mutations.\r\n     */ static newInvalidDocument(documentKey) {\n        return new MutableDocument(documentKey, 0 /* DocumentType.INVALID */ , /* version */ SnapshotVersion.min(), /* readTime */ SnapshotVersion.min(), /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 0 /* DocumentState.SYNCED */ );\n    }\n    /**\r\n     * Creates a new document that is known to exist with the given data at the\r\n     * given version.\r\n     */ static newFoundDocument(documentKey, version, createTime, value) {\n        return new MutableDocument(documentKey, 1 /* DocumentType.FOUND_DOCUMENT */ , /* version */ version, /* readTime */ SnapshotVersion.min(), /* createTime */ createTime, value, 0 /* DocumentState.SYNCED */ );\n    }\n    /** Creates a new document that is known to not exist at the given version. */ static newNoDocument(documentKey, version) {\n        return new MutableDocument(documentKey, 2 /* DocumentType.NO_DOCUMENT */ , /* version */ version, /* readTime */ SnapshotVersion.min(), /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 0 /* DocumentState.SYNCED */ );\n    }\n    /**\r\n     * Creates a new document that is known to exist at the given version but\r\n     * whose data is not known (e.g. a document that was updated without a known\r\n     * base document).\r\n     */ static newUnknownDocument(documentKey, version) {\n        return new MutableDocument(documentKey, 3 /* DocumentType.UNKNOWN_DOCUMENT */ , /* version */ version, /* readTime */ SnapshotVersion.min(), /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */ );\n    }\n    /**\r\n     * Changes the document type to indicate that it exists and that its version\r\n     * and data are known.\r\n     */ convertToFoundDocument(version, value) {\n        // If a document is switching state from being an invalid or deleted\n        // document to a valid (FOUND_DOCUMENT) document, either due to receiving an\n        // update from Watch or due to applying a local set mutation on top\n        // of a deleted document, our best guess about its createTime would be the\n        // version at which the document transitioned to a FOUND_DOCUMENT.\n        if (this.createTime.isEqual(SnapshotVersion.min()) && (this.documentType === 2 /* DocumentType.NO_DOCUMENT */  || this.documentType === 0 /* DocumentType.INVALID */ )) {\n            this.createTime = version;\n        }\n        this.version = version;\n        this.documentType = 1 /* DocumentType.FOUND_DOCUMENT */ ;\n        this.data = value;\n        this.documentState = 0 /* DocumentState.SYNCED */ ;\n        return this;\n    }\n    /**\r\n     * Changes the document type to indicate that it doesn't exist at the given\r\n     * version.\r\n     */ convertToNoDocument(version) {\n        this.version = version;\n        this.documentType = 2 /* DocumentType.NO_DOCUMENT */ ;\n        this.data = ObjectValue.empty();\n        this.documentState = 0 /* DocumentState.SYNCED */ ;\n        return this;\n    }\n    /**\r\n     * Changes the document type to indicate that it exists at a given version but\r\n     * that its data is not known (e.g. a document that was updated without a known\r\n     * base document).\r\n     */ convertToUnknownDocument(version) {\n        this.version = version;\n        this.documentType = 3 /* DocumentType.UNKNOWN_DOCUMENT */ ;\n        this.data = ObjectValue.empty();\n        this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */ ;\n        return this;\n    }\n    setHasCommittedMutations() {\n        this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */ ;\n        return this;\n    }\n    setHasLocalMutations() {\n        this.documentState = 1 /* DocumentState.HAS_LOCAL_MUTATIONS */ ;\n        this.version = SnapshotVersion.min();\n        return this;\n    }\n    setReadTime(readTime) {\n        this.readTime = readTime;\n        return this;\n    }\n    get hasLocalMutations() {\n        return this.documentState === 1 /* DocumentState.HAS_LOCAL_MUTATIONS */ ;\n    }\n    get hasCommittedMutations() {\n        return this.documentState === 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */ ;\n    }\n    get hasPendingWrites() {\n        return this.hasLocalMutations || this.hasCommittedMutations;\n    }\n    isValidDocument() {\n        return this.documentType !== 0 /* DocumentType.INVALID */ ;\n    }\n    isFoundDocument() {\n        return this.documentType === 1 /* DocumentType.FOUND_DOCUMENT */ ;\n    }\n    isNoDocument() {\n        return this.documentType === 2 /* DocumentType.NO_DOCUMENT */ ;\n    }\n    isUnknownDocument() {\n        return this.documentType === 3 /* DocumentType.UNKNOWN_DOCUMENT */ ;\n    }\n    isEqual(other) {\n        return other instanceof MutableDocument && this.key.isEqual(other.key) && this.version.isEqual(other.version) && this.documentType === other.documentType && this.documentState === other.documentState && this.data.isEqual(other.data);\n    }\n    mutableCopy() {\n        return new MutableDocument(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);\n    }\n    toString() {\n        return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, ` + `{createTime: ${this.createTime}}), ` + `{documentType: ${this.documentType}}), ` + `{documentState: ${this.documentState}})`;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Visible for testing\nclass TargetImpl {\n    constructor(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null){\n        this.path = path;\n        this.collectionGroup = collectionGroup;\n        this.orderBy = orderBy;\n        this.filters = filters;\n        this.limit = limit;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.memoizedCanonicalId = null;\n    }\n}\n/**\r\n * Initializes a Target with a path and optional additional query constraints.\r\n * Path must currently be empty if this is a collection group query.\r\n *\r\n * NOTE: you should always construct `Target` from `Query.toTarget` instead of\r\n * using this factory method, because `Query` provides an implicit `orderBy`\r\n * property.\r\n */ function newTarget(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) {\n    return new TargetImpl(path, collectionGroup, orderBy, filters, limit, startAt, endAt);\n}\nfunction targetEquals(left, right) {\n    if (left.limit !== right.limit) {\n        return false;\n    }\n    if (left.orderBy.length !== right.orderBy.length) {\n        return false;\n    }\n    for(let i = 0; i < left.orderBy.length; i++){\n        if (!orderByEquals(left.orderBy[i], right.orderBy[i])) {\n            return false;\n        }\n    }\n    if (left.filters.length !== right.filters.length) {\n        return false;\n    }\n    for(let i = 0; i < left.filters.length; i++){\n        if (!filterEquals(left.filters[i], right.filters[i])) {\n            return false;\n        }\n    }\n    if (left.collectionGroup !== right.collectionGroup) {\n        return false;\n    }\n    if (!left.path.isEqual(right.path)) {\n        return false;\n    }\n    if (!boundEquals(left.startAt, right.startAt)) {\n        return false;\n    }\n    return boundEquals(left.endAt, right.endAt);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Query encapsulates all the query attributes we support in the SDK. It can\r\n * be run against the LocalStore, as well as be converted to a `Target` to\r\n * query the RemoteStore results.\r\n *\r\n * Visible for testing.\r\n */ class QueryImpl {\n    /**\r\n     * Initializes a Query with a path and optional additional query constraints.\r\n     * Path must currently be empty if this is a collection group query.\r\n     */ constructor(path, collectionGroup = null, explicitOrderBy = [], filters = [], limit = null, limitType = \"F\" /* LimitType.First */ , startAt = null, endAt = null){\n        this.path = path;\n        this.collectionGroup = collectionGroup;\n        this.explicitOrderBy = explicitOrderBy;\n        this.filters = filters;\n        this.limit = limit;\n        this.limitType = limitType;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.memoizedNormalizedOrderBy = null;\n        // The corresponding `Target` of this `Query` instance, for use with\n        // non-aggregate queries.\n        this.memoizedTarget = null;\n        // The corresponding `Target` of this `Query` instance, for use with\n        // aggregate queries. Unlike targets for non-aggregate queries,\n        // aggregate query targets do not contain normalized order-bys, they only\n        // contain explicit order-bys.\n        this.memoizedAggregateTarget = null;\n        if (this.startAt) ;\n        if (this.endAt) ;\n    }\n}\n/** Creates a new Query for a query that matches all documents at `path` */ function newQueryForPath(path) {\n    return new QueryImpl(path);\n}\n// Returns the sorted set of inequality filter fields used in this query.\nfunction getInequalityFilterFields(query) {\n    let result = new SortedSet(FieldPath$1.comparator);\n    query.filters.forEach((filter)=>{\n        const subFilters = filter.getFlattenedFilters();\n        subFilters.forEach((filter)=>{\n            if (filter.isInequality()) {\n                result = result.add(filter.field);\n            }\n        });\n    });\n    return result;\n}\n/**\r\n * Creates a new Query for a collection group query that matches all documents\r\n * within the provided collection group.\r\n */ function newQueryForCollectionGroup(collectionId) {\n    return new QueryImpl(ResourcePath.emptyPath(), collectionId);\n}\n/**\r\n * Returns whether the query matches a collection group rather than a specific\r\n * collection.\r\n */ function isCollectionGroupQuery(query) {\n    return query.collectionGroup !== null;\n}\n/**\r\n * Returns the normalized order-by constraint that is used to execute the Query,\r\n * which can be different from the order-by constraints the user provided (e.g.\r\n * the SDK and backend always orders by `__name__`). The normalized order-by\r\n * includes implicit order-bys in addition to the explicit user provided\r\n * order-bys.\r\n */ function queryNormalizedOrderBy(query) {\n    const queryImpl = debugCast(query);\n    if (queryImpl.memoizedNormalizedOrderBy === null) {\n        queryImpl.memoizedNormalizedOrderBy = [];\n        const fieldsNormalized = new Set();\n        // Any explicit order by fields should be added as is.\n        for (const orderBy of queryImpl.explicitOrderBy){\n            queryImpl.memoizedNormalizedOrderBy.push(orderBy);\n            fieldsNormalized.add(orderBy.field.canonicalString());\n        }\n        // The order of the implicit ordering always matches the last explicit order by.\n        const lastDirection = queryImpl.explicitOrderBy.length > 0 ? queryImpl.explicitOrderBy[queryImpl.explicitOrderBy.length - 1].dir : \"asc\" /* Direction.ASCENDING */ ;\n        // Any inequality fields not explicitly ordered should be implicitly ordered in a lexicographical\n        // order. When there are multiple inequality filters on the same field, the field should be added\n        // only once.\n        // Note: `SortedSet<FieldPath>` sorts the key field before other fields. However, we want the key\n        // field to be sorted last.\n        const inequalityFields = getInequalityFilterFields(queryImpl);\n        inequalityFields.forEach((field)=>{\n            if (!fieldsNormalized.has(field.canonicalString()) && !field.isKeyField()) {\n                queryImpl.memoizedNormalizedOrderBy.push(new OrderBy(field, lastDirection));\n            }\n        });\n        // Add the document key field to the last if it is not explicitly ordered.\n        if (!fieldsNormalized.has(FieldPath$1.keyField().canonicalString())) {\n            queryImpl.memoizedNormalizedOrderBy.push(new OrderBy(FieldPath$1.keyField(), lastDirection));\n        }\n    }\n    return queryImpl.memoizedNormalizedOrderBy;\n}\n/**\r\n * Converts this `Query` instance to its corresponding `Target` representation.\r\n */ function queryToTarget(query) {\n    const queryImpl = debugCast(query);\n    if (!queryImpl.memoizedTarget) {\n        queryImpl.memoizedTarget = _queryToTarget(queryImpl, queryNormalizedOrderBy(query));\n    }\n    return queryImpl.memoizedTarget;\n}\n/**\r\n * Converts this `Query` instance to its corresponding `Target` representation,\r\n * for use within an aggregate query. Unlike targets for non-aggregate queries,\r\n * aggregate query targets do not contain normalized order-bys, they only\r\n * contain explicit order-bys.\r\n */ function queryToAggregateTarget(query) {\n    const queryImpl = debugCast(query);\n    if (!queryImpl.memoizedAggregateTarget) {\n        // Do not include implicit order-bys for aggregate queries.\n        queryImpl.memoizedAggregateTarget = _queryToTarget(queryImpl, query.explicitOrderBy);\n    }\n    return queryImpl.memoizedAggregateTarget;\n}\nfunction _queryToTarget(queryImpl, orderBys) {\n    if (queryImpl.limitType === \"F\" /* LimitType.First */ ) {\n        return newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, queryImpl.startAt, queryImpl.endAt);\n    } else {\n        // Flip the orderBy directions since we want the last results\n        orderBys = orderBys.map((orderBy)=>{\n            const dir = orderBy.dir === \"desc\" /* Direction.DESCENDING */  ? \"asc\" /* Direction.ASCENDING */  : \"desc\" /* Direction.DESCENDING */ ;\n            return new OrderBy(orderBy.field, dir);\n        });\n        // We need to swap the cursors to match the now-flipped query ordering.\n        const startAt = queryImpl.endAt ? new Bound(queryImpl.endAt.position, queryImpl.endAt.inclusive) : null;\n        const endAt = queryImpl.startAt ? new Bound(queryImpl.startAt.position, queryImpl.startAt.inclusive) : null;\n        // Now return as a LimitType.First query.\n        return newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, startAt, endAt);\n    }\n}\nfunction queryWithAddedFilter(query, filter) {\n    const newFilters = query.filters.concat([\n        filter\n    ]);\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), newFilters, query.limit, query.limitType, query.startAt, query.endAt);\n}\nfunction queryWithAddedOrderBy(query, orderBy) {\n    // TODO(dimond): validate that orderBy does not list the same key twice.\n    const newOrderBy = query.explicitOrderBy.concat([\n        orderBy\n    ]);\n    return new QueryImpl(query.path, query.collectionGroup, newOrderBy, query.filters.slice(), query.limit, query.limitType, query.startAt, query.endAt);\n}\nfunction queryWithLimit(query, limit, limitType) {\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), limit, limitType, query.startAt, query.endAt);\n}\nfunction queryWithStartAt(query, bound) {\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, bound, query.endAt);\n}\nfunction queryWithEndAt(query, bound) {\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, query.startAt, bound);\n}\nfunction queryEquals(left, right) {\n    return targetEquals(queryToTarget(left), queryToTarget(right)) && left.limitType === right.limitType;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns an DoubleValue for `value` that is encoded based the serializer's\r\n * `useProto3Json` setting.\r\n */ function toDouble(serializer, value) {\n    if (serializer.useProto3Json) {\n        if (isNaN(value)) {\n            return {\n                doubleValue: \"NaN\"\n            };\n        } else if (value === Infinity) {\n            return {\n                doubleValue: \"Infinity\"\n            };\n        } else if (value === -Infinity) {\n            return {\n                doubleValue: \"-Infinity\"\n            };\n        }\n    }\n    return {\n        doubleValue: isNegativeZero(value) ? \"-0\" : value\n    };\n}\n/**\r\n * Returns an IntegerValue for `value`.\r\n */ function toInteger(value) {\n    return {\n        integerValue: \"\" + value\n    };\n}\n/**\r\n * Returns a value for a number that's appropriate to put into a proto.\r\n * The return value is an IntegerValue if it can safely represent the value,\r\n * otherwise a DoubleValue is returned.\r\n */ function toNumber(serializer, value) {\n    return isSafeInteger(value) ? toInteger(value) : toDouble(serializer, value);\n}\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** Used to represent a field transform on a mutation. */ class TransformOperation {\n    constructor(){\n        // Make sure that the structural type of `TransformOperation` is unique.\n        // See https://github.com/microsoft/TypeScript/issues/5451\n        this._ = undefined;\n    }\n}\n/** Transforms a value into a server-generated timestamp. */ class ServerTimestampTransform extends TransformOperation {\n}\n/** Transforms an array value via a union operation. */ class ArrayUnionTransformOperation extends TransformOperation {\n    constructor(elements){\n        super();\n        this.elements = elements;\n    }\n}\n/** Transforms an array value via a remove operation. */ class ArrayRemoveTransformOperation extends TransformOperation {\n    constructor(elements){\n        super();\n        this.elements = elements;\n    }\n}\n/**\r\n * Implements the backend semantics for locally computed NUMERIC_ADD (increment)\r\n * transforms. Converts all field values to integers or doubles, but unlike the\r\n * backend does not cap integer values at 2^63. Instead, JavaScript number\r\n * arithmetic is used and precision loss can occur for values greater than 2^53.\r\n */ class NumericIncrementTransformOperation extends TransformOperation {\n    constructor(serializer, operand){\n        super();\n        this.serializer = serializer;\n        this.operand = operand;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** A field path and the TransformOperation to perform upon it. */ class FieldTransform {\n    constructor(field, transform){\n        this.field = field;\n        this.transform = transform;\n    }\n}\n/**\r\n * Encodes a precondition for a mutation. This follows the model that the\r\n * backend accepts with the special case of an explicit \"empty\" precondition\r\n * (meaning no precondition).\r\n */ class Precondition {\n    constructor(updateTime, exists){\n        this.updateTime = updateTime;\n        this.exists = exists;\n    }\n    /** Creates a new empty Precondition. */ static none() {\n        return new Precondition();\n    }\n    /** Creates a new Precondition with an exists flag. */ static exists(exists) {\n        return new Precondition(undefined, exists);\n    }\n    /** Creates a new Precondition based on a version a document exists at. */ static updateTime(version) {\n        return new Precondition(version);\n    }\n    /** Returns whether this Precondition is empty. */ get isNone() {\n        return this.updateTime === undefined && this.exists === undefined;\n    }\n    isEqual(other) {\n        return this.exists === other.exists && (this.updateTime ? !!other.updateTime && this.updateTime.isEqual(other.updateTime) : !other.updateTime);\n    }\n}\n/**\r\n * A mutation describes a self-contained change to a document. Mutations can\r\n * create, replace, delete, and update subsets of documents.\r\n *\r\n * Mutations not only act on the value of the document but also its version.\r\n *\r\n * For local mutations (mutations that haven't been committed yet), we preserve\r\n * the existing version for Set and Patch mutations. For Delete mutations, we\r\n * reset the version to 0.\r\n *\r\n * Here's the expected transition table.\r\n *\r\n * MUTATION           APPLIED TO            RESULTS IN\r\n *\r\n * SetMutation        Document(v3)          Document(v3)\r\n * SetMutation        NoDocument(v3)        Document(v0)\r\n * SetMutation        InvalidDocument(v0)   Document(v0)\r\n * PatchMutation      Document(v3)          Document(v3)\r\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\r\n * PatchMutation      InvalidDocument(v0)   UnknownDocument(v3)\r\n * DeleteMutation     Document(v3)          NoDocument(v0)\r\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\r\n * DeleteMutation     InvalidDocument(v0)   NoDocument(v0)\r\n *\r\n * For acknowledged mutations, we use the updateTime of the WriteResponse as\r\n * the resulting version for Set and Patch mutations. As deletes have no\r\n * explicit update time, we use the commitTime of the WriteResponse for\r\n * Delete mutations.\r\n *\r\n * If a mutation is acknowledged by the backend but fails the precondition check\r\n * locally, we transition to an `UnknownDocument` and rely on Watch to send us\r\n * the updated version.\r\n *\r\n * Field transforms are used only with Patch and Set Mutations. We use the\r\n * `updateTransforms` message to store transforms, rather than the `transforms`s\r\n * messages.\r\n *\r\n * ## Subclassing Notes\r\n *\r\n * Every type of mutation needs to implement its own applyToRemoteDocument() and\r\n * applyToLocalView() to implement the actual behavior of applying the mutation\r\n * to some source document (see `setMutationApplyToRemoteDocument()` for an\r\n * example).\r\n */ class Mutation {\n}\n/**\r\n * A mutation that creates or replaces the document at the given key with the\r\n * object value contents.\r\n */ class SetMutation extends Mutation {\n    constructor(key, value, precondition, fieldTransforms = []){\n        super();\n        this.key = key;\n        this.value = value;\n        this.precondition = precondition;\n        this.fieldTransforms = fieldTransforms;\n        this.type = 0 /* MutationType.Set */ ;\n    }\n    getFieldMask() {\n        return null;\n    }\n}\n/**\r\n * A mutation that modifies fields of the document at the given key with the\r\n * given values. The values are applied through a field mask:\r\n *\r\n *  * When a field is in both the mask and the values, the corresponding field\r\n *    is updated.\r\n *  * When a field is in neither the mask nor the values, the corresponding\r\n *    field is unmodified.\r\n *  * When a field is in the mask but not in the values, the corresponding field\r\n *    is deleted.\r\n *  * When a field is not in the mask but is in the values, the values map is\r\n *    ignored.\r\n */ class PatchMutation extends Mutation {\n    constructor(key, data, fieldMask, precondition, fieldTransforms = []){\n        super();\n        this.key = key;\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.precondition = precondition;\n        this.fieldTransforms = fieldTransforms;\n        this.type = 1 /* MutationType.Patch */ ;\n    }\n    getFieldMask() {\n        return this.fieldMask;\n    }\n}\n/** A mutation that deletes the document at the given key. */ class DeleteMutation extends Mutation {\n    constructor(key, precondition){\n        super();\n        this.key = key;\n        this.precondition = precondition;\n        this.type = 2 /* MutationType.Delete */ ;\n        this.fieldTransforms = [];\n    }\n    getFieldMask() {\n        return null;\n    }\n}\n/**\r\n * A mutation that verifies the existence of the document at the given key with\r\n * the provided precondition.\r\n *\r\n * The `verify` operation is only used in Transactions, and this class serves\r\n * primarily to facilitate serialization into protos.\r\n */ class VerifyMutation extends Mutation {\n    constructor(key, precondition){\n        super();\n        this.key = key;\n        this.precondition = precondition;\n        this.type = 3 /* MutationType.Verify */ ;\n        this.fieldTransforms = [];\n    }\n    getFieldMask() {\n        return null;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DIRECTIONS = (()=>{\n    const dirs = {};\n    dirs[\"asc\" /* Direction.ASCENDING */ ] = \"ASCENDING\";\n    dirs[\"desc\" /* Direction.DESCENDING */ ] = \"DESCENDING\";\n    return dirs;\n})();\nconst OPERATORS = (()=>{\n    const ops = {};\n    ops[\"<\" /* Operator.LESS_THAN */ ] = \"LESS_THAN\";\n    ops[\"<=\" /* Operator.LESS_THAN_OR_EQUAL */ ] = \"LESS_THAN_OR_EQUAL\";\n    ops[\">\" /* Operator.GREATER_THAN */ ] = \"GREATER_THAN\";\n    ops[\">=\" /* Operator.GREATER_THAN_OR_EQUAL */ ] = \"GREATER_THAN_OR_EQUAL\";\n    ops[\"==\" /* Operator.EQUAL */ ] = \"EQUAL\";\n    ops[\"!=\" /* Operator.NOT_EQUAL */ ] = \"NOT_EQUAL\";\n    ops[\"array-contains\" /* Operator.ARRAY_CONTAINS */ ] = \"ARRAY_CONTAINS\";\n    ops[\"in\" /* Operator.IN */ ] = \"IN\";\n    ops[\"not-in\" /* Operator.NOT_IN */ ] = \"NOT_IN\";\n    ops[\"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */ ] = \"ARRAY_CONTAINS_ANY\";\n    return ops;\n})();\nconst COMPOSITE_OPERATORS = (()=>{\n    const ops = {};\n    ops[\"and\" /* CompositeOperator.AND */ ] = \"AND\";\n    ops[\"or\" /* CompositeOperator.OR */ ] = \"OR\";\n    return ops;\n})();\nfunction assertPresent(value, description) {}\n/**\r\n * This class generates JsonObject values for the Datastore API suitable for\r\n * sending to either GRPC stub methods or via the JSON/HTTP REST API.\r\n *\r\n * The serializer supports both Protobuf.js and Proto3 JSON formats. By\r\n * setting `useProto3Json` to true, the serializer will use the Proto3 JSON\r\n * format.\r\n *\r\n * For a description of the Proto3 JSON format check\r\n * https://developers.google.com/protocol-buffers/docs/proto3#json\r\n *\r\n * TODO(klimt): We can remove the databaseId argument if we keep the full\r\n * resource name in documents.\r\n */ class JsonProtoSerializer {\n    constructor(databaseId, useProto3Json){\n        this.databaseId = databaseId;\n        this.useProto3Json = useProto3Json;\n    }\n}\n/**\r\n * Returns a value for a number (or null) that's appropriate to put into\r\n * a google.protobuf.Int32Value proto.\r\n * DO NOT USE THIS FOR ANYTHING ELSE.\r\n * This method cheats. It's typed as returning \"number\" because that's what\r\n * our generated proto interfaces say Int32Value must be. But GRPC actually\r\n * expects a { value: <number> } struct.\r\n */ function toInt32Proto(serializer, val) {\n    if (serializer.useProto3Json || isNullOrUndefined(val)) {\n        return val;\n    } else {\n        return {\n            value: val\n        };\n    }\n}\n/**\r\n * Returns a value for a Date that's appropriate to put into a proto.\r\n */ function toTimestamp(serializer, timestamp) {\n    if (serializer.useProto3Json) {\n        // Serialize to ISO-8601 date format, but with full nano resolution.\n        // Since JS Date has only millis, let's only use it for the seconds and\n        // then manually add the fractions to the end.\n        const jsDateStr = new Date(timestamp.seconds * 1000).toISOString();\n        // Remove .xxx frac part and Z in the end.\n        const strUntilSeconds = jsDateStr.replace(/\\.\\d*/, \"\").replace(\"Z\", \"\");\n        // Pad the fraction out to 9 digits (nanos).\n        const nanoStr = (\"000000000\" + timestamp.nanoseconds).slice(-9);\n        return `${strUntilSeconds}.${nanoStr}Z`;\n    } else {\n        return {\n            seconds: \"\" + timestamp.seconds,\n            nanos: timestamp.nanoseconds\n        };\n    }\n}\nfunction fromTimestamp(date) {\n    const timestamp = normalizeTimestamp(date);\n    return new Timestamp(timestamp.seconds, timestamp.nanos);\n}\n/**\r\n * Returns a value for bytes that's appropriate to put in a proto.\r\n *\r\n * Visible for testing.\r\n */ function toBytes(serializer, bytes) {\n    if (serializer.useProto3Json) {\n        return bytes.toBase64();\n    } else {\n        return bytes.toUint8Array();\n    }\n}\nfunction toVersion(serializer, version) {\n    return toTimestamp(serializer, version.toTimestamp());\n}\nfunction fromVersion(version) {\n    hardAssert(!!version);\n    return SnapshotVersion.fromTimestamp(fromTimestamp(version));\n}\nfunction toResourceName(databaseId, path) {\n    return toResourcePath(databaseId, path).canonicalString();\n}\nfunction toResourcePath(databaseId, path) {\n    const resourcePath = fullyQualifiedPrefixPath(databaseId).child(\"documents\");\n    return path === undefined ? resourcePath : resourcePath.child(path);\n}\nfunction fromResourceName(name) {\n    const resource = ResourcePath.fromString(name);\n    hardAssert(isValidResourceName(resource));\n    return resource;\n}\nfunction toName(serializer, key) {\n    return toResourceName(serializer.databaseId, key.path);\n}\nfunction fromName(serializer, name) {\n    const resource = fromResourceName(name);\n    if (resource.get(1) !== serializer.databaseId.projectId) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Tried to deserialize key from different project: \" + resource.get(1) + \" vs \" + serializer.databaseId.projectId);\n    }\n    if (resource.get(3) !== serializer.databaseId.database) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Tried to deserialize key from different database: \" + resource.get(3) + \" vs \" + serializer.databaseId.database);\n    }\n    return new DocumentKey(extractLocalPathFromResourceName(resource));\n}\nfunction toQueryPath(serializer, path) {\n    return toResourceName(serializer.databaseId, path);\n}\nfunction fullyQualifiedPrefixPath(databaseId) {\n    return new ResourcePath([\n        \"projects\",\n        databaseId.projectId,\n        \"databases\",\n        databaseId.database\n    ]);\n}\nfunction extractLocalPathFromResourceName(resourceName) {\n    hardAssert(resourceName.length > 4 && resourceName.get(4) === \"documents\");\n    return resourceName.popFirst(5);\n}\n/** Creates a Document proto from key and fields (but no create/update time) */ function toMutationDocument(serializer, key, fields) {\n    return {\n        name: toName(serializer, key),\n        fields: fields.value.mapValue.fields\n    };\n}\nfunction fromDocument(serializer, document, hasCommittedMutations) {\n    const key = fromName(serializer, document.name);\n    const version = fromVersion(document.updateTime);\n    // If we read a document from persistence that is missing createTime, it's due\n    // to older SDK versions not storing this information. In such cases, we'll\n    // set the createTime to zero. This can be removed in the long term.\n    const createTime = document.createTime ? fromVersion(document.createTime) : SnapshotVersion.min();\n    const data = new ObjectValue({\n        mapValue: {\n            fields: document.fields\n        }\n    });\n    const result = MutableDocument.newFoundDocument(key, version, createTime, data);\n    if (hasCommittedMutations) {\n        result.setHasCommittedMutations();\n    }\n    return hasCommittedMutations ? result.setHasCommittedMutations() : result;\n}\nfunction fromFound(serializer, doc) {\n    hardAssert(!!doc.found);\n    assertPresent(doc.found.name);\n    assertPresent(doc.found.updateTime);\n    const key = fromName(serializer, doc.found.name);\n    const version = fromVersion(doc.found.updateTime);\n    const createTime = doc.found.createTime ? fromVersion(doc.found.createTime) : SnapshotVersion.min();\n    const data = new ObjectValue({\n        mapValue: {\n            fields: doc.found.fields\n        }\n    });\n    return MutableDocument.newFoundDocument(key, version, createTime, data);\n}\nfunction fromMissing(serializer, result) {\n    hardAssert(!!result.missing);\n    hardAssert(!!result.readTime);\n    const key = fromName(serializer, result.missing);\n    const version = fromVersion(result.readTime);\n    return MutableDocument.newNoDocument(key, version);\n}\nfunction fromBatchGetDocumentsResponse(serializer, result) {\n    if (\"found\" in result) {\n        return fromFound(serializer, result);\n    } else if (\"missing\" in result) {\n        return fromMissing(serializer, result);\n    }\n    return fail();\n}\nfunction toMutation(serializer, mutation) {\n    let result;\n    if (mutation instanceof SetMutation) {\n        result = {\n            update: toMutationDocument(serializer, mutation.key, mutation.value)\n        };\n    } else if (mutation instanceof DeleteMutation) {\n        result = {\n            delete: toName(serializer, mutation.key)\n        };\n    } else if (mutation instanceof PatchMutation) {\n        result = {\n            update: toMutationDocument(serializer, mutation.key, mutation.data),\n            updateMask: toDocumentMask(mutation.fieldMask)\n        };\n    } else if (mutation instanceof VerifyMutation) {\n        result = {\n            verify: toName(serializer, mutation.key)\n        };\n    } else {\n        return fail();\n    }\n    if (mutation.fieldTransforms.length > 0) {\n        result.updateTransforms = mutation.fieldTransforms.map((transform)=>toFieldTransform(serializer, transform));\n    }\n    if (!mutation.precondition.isNone) {\n        result.currentDocument = toPrecondition(serializer, mutation.precondition);\n    }\n    return result;\n}\nfunction toPrecondition(serializer, precondition) {\n    if (precondition.updateTime !== undefined) {\n        return {\n            updateTime: toVersion(serializer, precondition.updateTime)\n        };\n    } else if (precondition.exists !== undefined) {\n        return {\n            exists: precondition.exists\n        };\n    } else {\n        return fail();\n    }\n}\nfunction toFieldTransform(serializer, fieldTransform) {\n    const transform = fieldTransform.transform;\n    if (transform instanceof ServerTimestampTransform) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            setToServerValue: \"REQUEST_TIME\"\n        };\n    } else if (transform instanceof ArrayUnionTransformOperation) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            appendMissingElements: {\n                values: transform.elements\n            }\n        };\n    } else if (transform instanceof ArrayRemoveTransformOperation) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            removeAllFromArray: {\n                values: transform.elements\n            }\n        };\n    } else if (transform instanceof NumericIncrementTransformOperation) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            increment: transform.operand\n        };\n    } else {\n        throw fail();\n    }\n}\nfunction toQueryTarget(serializer, target) {\n    // Dissect the path into parent, collectionId, and optional key filter.\n    const queryTarget = {\n        structuredQuery: {}\n    };\n    const path = target.path;\n    let parent;\n    if (target.collectionGroup !== null) {\n        parent = path;\n        queryTarget.structuredQuery.from = [\n            {\n                collectionId: target.collectionGroup,\n                allDescendants: true\n            }\n        ];\n    } else {\n        parent = path.popLast();\n        queryTarget.structuredQuery.from = [\n            {\n                collectionId: path.lastSegment()\n            }\n        ];\n    }\n    queryTarget.parent = toQueryPath(serializer, parent);\n    const where = toFilters(target.filters);\n    if (where) {\n        queryTarget.structuredQuery.where = where;\n    }\n    const orderBy = toOrder(target.orderBy);\n    if (orderBy) {\n        queryTarget.structuredQuery.orderBy = orderBy;\n    }\n    const limit = toInt32Proto(serializer, target.limit);\n    if (limit !== null) {\n        queryTarget.structuredQuery.limit = limit;\n    }\n    if (target.startAt) {\n        queryTarget.structuredQuery.startAt = toStartAtCursor(target.startAt);\n    }\n    if (target.endAt) {\n        queryTarget.structuredQuery.endAt = toEndAtCursor(target.endAt);\n    }\n    return {\n        queryTarget,\n        parent\n    };\n}\nfunction toRunAggregationQueryRequest(serializer, target, aggregates) {\n    const { queryTarget, parent } = toQueryTarget(serializer, target);\n    const aliasMap = {};\n    const aggregations = [];\n    let aggregationNum = 0;\n    aggregates.forEach((aggregate)=>{\n        // Map all client-side aliases to a unique short-form\n        // alias. This avoids issues with client-side aliases that\n        // exceed the 1500-byte string size limit.\n        const serverAlias = `aggregate_${aggregationNum++}`;\n        aliasMap[serverAlias] = aggregate.alias;\n        if (aggregate.aggregateType === \"count\") {\n            aggregations.push({\n                alias: serverAlias,\n                count: {}\n            });\n        } else if (aggregate.aggregateType === \"avg\") {\n            aggregations.push({\n                alias: serverAlias,\n                avg: {\n                    field: toFieldPathReference(aggregate.fieldPath)\n                }\n            });\n        } else if (aggregate.aggregateType === \"sum\") {\n            aggregations.push({\n                alias: serverAlias,\n                sum: {\n                    field: toFieldPathReference(aggregate.fieldPath)\n                }\n            });\n        }\n    });\n    return {\n        request: {\n            structuredAggregationQuery: {\n                aggregations,\n                structuredQuery: queryTarget.structuredQuery\n            },\n            parent: queryTarget.parent\n        },\n        aliasMap,\n        parent\n    };\n}\nfunction toFilters(filters) {\n    if (filters.length === 0) {\n        return;\n    }\n    return toFilter(CompositeFilter.create(filters, \"and\" /* CompositeOperator.AND */ ));\n}\nfunction toOrder(orderBys) {\n    if (orderBys.length === 0) {\n        return;\n    }\n    return orderBys.map((order)=>toPropertyOrder(order));\n}\nfunction toStartAtCursor(cursor) {\n    return {\n        before: cursor.inclusive,\n        values: cursor.position\n    };\n}\nfunction toEndAtCursor(cursor) {\n    return {\n        before: !cursor.inclusive,\n        values: cursor.position\n    };\n}\n// visible for testing\nfunction toDirection(dir) {\n    return DIRECTIONS[dir];\n}\n// visible for testing\nfunction toOperatorName(op) {\n    return OPERATORS[op];\n}\nfunction toCompositeOperatorName(op) {\n    return COMPOSITE_OPERATORS[op];\n}\nfunction toFieldPathReference(path) {\n    return {\n        fieldPath: path.canonicalString()\n    };\n}\n// visible for testing\nfunction toPropertyOrder(orderBy) {\n    return {\n        field: toFieldPathReference(orderBy.field),\n        direction: toDirection(orderBy.dir)\n    };\n}\n// visible for testing\nfunction toFilter(filter) {\n    if (filter instanceof FieldFilter) {\n        return toUnaryOrFieldFilter(filter);\n    } else if (filter instanceof CompositeFilter) {\n        return toCompositeFilter(filter);\n    } else {\n        return fail();\n    }\n}\nfunction toCompositeFilter(filter) {\n    const protos = filter.getFilters().map((filter)=>toFilter(filter));\n    if (protos.length === 1) {\n        return protos[0];\n    }\n    return {\n        compositeFilter: {\n            op: toCompositeOperatorName(filter.op),\n            filters: protos\n        }\n    };\n}\nfunction toUnaryOrFieldFilter(filter) {\n    if (filter.op === \"==\" /* Operator.EQUAL */ ) {\n        if (isNanValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: \"IS_NAN\"\n                }\n            };\n        } else if (isNullValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: \"IS_NULL\"\n                }\n            };\n        }\n    } else if (filter.op === \"!=\" /* Operator.NOT_EQUAL */ ) {\n        if (isNanValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: \"IS_NOT_NAN\"\n                }\n            };\n        } else if (isNullValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: \"IS_NOT_NULL\"\n                }\n            };\n        }\n    }\n    return {\n        fieldFilter: {\n            field: toFieldPathReference(filter.field),\n            op: toOperatorName(filter.op),\n            value: filter.value\n        }\n    };\n}\nfunction toDocumentMask(fieldMask) {\n    const canonicalFields = [];\n    fieldMask.fields.forEach((field)=>canonicalFields.push(field.canonicalString()));\n    return {\n        fieldPaths: canonicalFields\n    };\n}\nfunction isValidResourceName(path) {\n    // Resource names have at least 4 components (project ID, database ID)\n    return path.length >= 4 && path.get(0) === \"projects\" && path.get(2) === \"databases\";\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function newSerializer(databaseId) {\n    return new JsonProtoSerializer(databaseId, /* useProto3Json= */ true);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const LOG_TAG$2 = \"ExponentialBackoff\";\n/**\r\n * Initial backoff time in milliseconds after an error.\r\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\r\n */ const DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\nconst DEFAULT_BACKOFF_FACTOR = 1.5;\n/** Maximum backoff time in milliseconds */ const DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;\n/**\r\n * A helper for running delayed tasks following an exponential backoff curve\r\n * between attempts.\r\n *\r\n * Each delay is made up of a \"base\" delay which follows the exponential\r\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\r\n * base delay. This prevents clients from accidentally synchronizing their\r\n * delays causing spikes of load to the backend.\r\n */ class ExponentialBackoff {\n    constructor(/**\r\n     * The AsyncQueue to run backoff operations on.\r\n     */ queue, /**\r\n     * The ID to use when scheduling backoff operations on the AsyncQueue.\r\n     */ timerId, /**\r\n     * The initial delay (used as the base delay on the first retry attempt).\r\n     * Note that jitter will still be applied, so the actual delay could be as\r\n     * little as 0.5*initialDelayMs.\r\n     */ initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS, /**\r\n     * The multiplier to use to determine the extended base delay after each\r\n     * attempt.\r\n     */ backoffFactor = DEFAULT_BACKOFF_FACTOR, /**\r\n     * The maximum base delay after which no further backoff is performed.\r\n     * Note that jitter will still be applied, so the actual delay could be as\r\n     * much as 1.5*maxDelayMs.\r\n     */ maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS){\n        this.queue = queue;\n        this.timerId = timerId;\n        this.initialDelayMs = initialDelayMs;\n        this.backoffFactor = backoffFactor;\n        this.maxDelayMs = maxDelayMs;\n        this.currentBaseMs = 0;\n        this.timerPromise = null;\n        /** The last backoff attempt, as epoch milliseconds. */ this.lastAttemptTime = Date.now();\n        this.reset();\n    }\n    /**\r\n     * Resets the backoff delay.\r\n     *\r\n     * The very next backoffAndWait() will have no delay. If it is called again\r\n     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\r\n     * subsequent ones will increase according to the backoffFactor.\r\n     */ reset() {\n        this.currentBaseMs = 0;\n    }\n    /**\r\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\r\n     * RESOURCE_EXHAUSTED error).\r\n     */ resetToMax() {\n        this.currentBaseMs = this.maxDelayMs;\n    }\n    /**\r\n     * Returns a promise that resolves after currentDelayMs, and increases the\r\n     * delay for any subsequent attempts. If there was a pending backoff operation\r\n     * already, it will be canceled.\r\n     */ backoffAndRun(op) {\n        // Cancel any pending backoff operation.\n        this.cancel();\n        // First schedule using the current base (which may be 0 and should be\n        // honored as such).\n        const desiredDelayWithJitterMs = Math.floor(this.currentBaseMs + this.jitterDelayMs());\n        // Guard against lastAttemptTime being in the future due to a clock change.\n        const delaySoFarMs = Math.max(0, Date.now() - this.lastAttemptTime);\n        // Guard against the backoff delay already being past.\n        const remainingDelayMs = Math.max(0, desiredDelayWithJitterMs - delaySoFarMs);\n        if (remainingDelayMs > 0) {\n            logDebug(LOG_TAG$2, `Backing off for ${remainingDelayMs} ms ` + `(base delay: ${this.currentBaseMs} ms, ` + `delay with jitter: ${desiredDelayWithJitterMs} ms, ` + `last attempt: ${delaySoFarMs} ms ago)`);\n        }\n        this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, remainingDelayMs, ()=>{\n            this.lastAttemptTime = Date.now();\n            return op();\n        });\n        // Apply backoff factor to determine next delay and ensure it is within\n        // bounds.\n        this.currentBaseMs *= this.backoffFactor;\n        if (this.currentBaseMs < this.initialDelayMs) {\n            this.currentBaseMs = this.initialDelayMs;\n        }\n        if (this.currentBaseMs > this.maxDelayMs) {\n            this.currentBaseMs = this.maxDelayMs;\n        }\n    }\n    skipBackoff() {\n        if (this.timerPromise !== null) {\n            this.timerPromise.skipDelay();\n            this.timerPromise = null;\n        }\n    }\n    cancel() {\n        if (this.timerPromise !== null) {\n            this.timerPromise.cancel();\n            this.timerPromise = null;\n        }\n    }\n    /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */ jitterDelayMs() {\n        return (Math.random() - 0.5) * this.currentBaseMs;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Datastore and its related methods are a wrapper around the external Google\r\n * Cloud Datastore grpc API, which provides an interface that is more convenient\r\n * for the rest of the client SDK architecture to consume.\r\n */ class Datastore {\n}\n/**\r\n * An implementation of Datastore that exposes additional state for internal\r\n * consumption.\r\n */ class DatastoreImpl extends Datastore {\n    constructor(authCredentials, appCheckCredentials, connection, serializer){\n        super();\n        this.authCredentials = authCredentials;\n        this.appCheckCredentials = appCheckCredentials;\n        this.connection = connection;\n        this.serializer = serializer;\n        this.terminated = false;\n    }\n    verifyInitialized() {\n        if (this.terminated) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, \"The client has already been terminated.\");\n        }\n    }\n    /** Invokes the provided RPC with auth and AppCheck tokens. */ invokeRPC(rpcName, databaseId, resourcePath, request) {\n        this.verifyInitialized();\n        return Promise.all([\n            this.authCredentials.getToken(),\n            this.appCheckCredentials.getToken()\n        ]).then(([authToken, appCheckToken])=>{\n            return this.connection.invokeRPC(rpcName, toResourcePath(databaseId, resourcePath), request, authToken, appCheckToken);\n        }).catch((error)=>{\n            if (error.name === \"FirebaseError\") {\n                if (error.code === Code.UNAUTHENTICATED) {\n                    this.authCredentials.invalidateToken();\n                    this.appCheckCredentials.invalidateToken();\n                }\n                throw error;\n            } else {\n                throw new FirestoreError(Code.UNKNOWN, error.toString());\n            }\n        });\n    }\n    /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */ invokeStreamingRPC(rpcName, databaseId, resourcePath, request, expectedResponseCount) {\n        this.verifyInitialized();\n        return Promise.all([\n            this.authCredentials.getToken(),\n            this.appCheckCredentials.getToken()\n        ]).then(([authToken, appCheckToken])=>{\n            return this.connection.invokeStreamingRPC(rpcName, toResourcePath(databaseId, resourcePath), request, authToken, appCheckToken, expectedResponseCount);\n        }).catch((error)=>{\n            if (error.name === \"FirebaseError\") {\n                if (error.code === Code.UNAUTHENTICATED) {\n                    this.authCredentials.invalidateToken();\n                    this.appCheckCredentials.invalidateToken();\n                }\n                throw error;\n            } else {\n                throw new FirestoreError(Code.UNKNOWN, error.toString());\n            }\n        });\n    }\n    terminate() {\n        this.terminated = true;\n        this.connection.terminate();\n    }\n}\n// TODO(firestorexp): Make sure there is only one Datastore instance per\n// firestore-exp client.\nfunction newDatastore(authCredentials, appCheckCredentials, connection, serializer) {\n    return new DatastoreImpl(authCredentials, appCheckCredentials, connection, serializer);\n}\nasync function invokeCommitRpc(datastore, mutations) {\n    const datastoreImpl = debugCast(datastore);\n    const request = {\n        writes: mutations.map((m)=>toMutation(datastoreImpl.serializer, m))\n    };\n    await datastoreImpl.invokeRPC(\"Commit\", datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), request);\n}\nasync function invokeBatchGetDocumentsRpc(datastore, keys) {\n    const datastoreImpl = debugCast(datastore);\n    const request = {\n        documents: keys.map((k)=>toName(datastoreImpl.serializer, k))\n    };\n    const response = await datastoreImpl.invokeStreamingRPC(\"BatchGetDocuments\", datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), request, keys.length);\n    const docs = new Map();\n    response.forEach((proto)=>{\n        const doc = fromBatchGetDocumentsResponse(datastoreImpl.serializer, proto);\n        docs.set(doc.key.toString(), doc);\n    });\n    const result = [];\n    keys.forEach((key)=>{\n        const doc = docs.get(key.toString());\n        hardAssert(!!doc);\n        result.push(doc);\n    });\n    return result;\n}\nasync function invokeRunQueryRpc(datastore, query) {\n    const datastoreImpl = debugCast(datastore);\n    const { queryTarget, parent } = toQueryTarget(datastoreImpl.serializer, queryToTarget(query));\n    const response = await datastoreImpl.invokeStreamingRPC(\"RunQuery\", datastoreImpl.serializer.databaseId, parent, {\n        structuredQuery: queryTarget.structuredQuery\n    });\n    return response// Omit RunQueryResponses that only contain readTimes.\n    .filter((proto)=>!!proto.document).map((proto)=>fromDocument(datastoreImpl.serializer, proto.document, undefined));\n}\nasync function invokeRunAggregationQueryRpc(datastore, query, aggregates) {\n    var _a;\n    const datastoreImpl = debugCast(datastore);\n    const { request, aliasMap, parent } = toRunAggregationQueryRequest(datastoreImpl.serializer, queryToAggregateTarget(query), aggregates);\n    if (!datastoreImpl.connection.shouldResourcePathBeIncludedInRequest) {\n        delete request.parent;\n    }\n    const response = await datastoreImpl.invokeStreamingRPC(\"RunAggregationQuery\", datastoreImpl.serializer.databaseId, parent, request, /*expectedResponseCount=*/ 1);\n    // Omit RunAggregationQueryResponse that only contain readTimes.\n    const filteredResult = response.filter((proto)=>!!proto.result);\n    hardAssert(filteredResult.length === 1);\n    // Remap the short-form aliases that were sent to the server\n    // to the client-side aliases. Users will access the results\n    // using the client-side alias.\n    const unmappedAggregateFields = (_a = filteredResult[0].result) === null || _a === void 0 ? void 0 : _a.aggregateFields;\n    const remappedFields = Object.keys(unmappedAggregateFields).reduce((accumulator, key)=>{\n        accumulator[aliasMap[key]] = unmappedAggregateFields[key];\n        return accumulator;\n    }, {});\n    return remappedFields;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const LOG_TAG$1 = \"ComponentProvider\";\n/**\r\n * An instance map that ensures only one Datastore exists per Firestore\r\n * instance.\r\n */ const datastoreInstances = new Map();\n/**\r\n * Returns an initialized and started Datastore for the given Firestore\r\n * instance. Callers must invoke removeComponents() when the Firestore\r\n * instance is terminated.\r\n */ function getDatastore(firestore) {\n    if (firestore._terminated) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, \"The client has already been terminated.\");\n    }\n    if (!datastoreInstances.has(firestore)) {\n        logDebug(LOG_TAG$1, \"Initializing Datastore\");\n        const databaseInfo = makeDatabaseInfo(firestore._databaseId, firestore.app.options.appId || \"\", firestore._persistenceKey, firestore._freezeSettings());\n        const connection = newConnection(databaseInfo);\n        const serializer = newSerializer(firestore._databaseId);\n        const datastore = newDatastore(firestore._authCredentials, firestore._appCheckCredentials, connection, serializer);\n        datastoreInstances.set(firestore, datastore);\n    }\n    return datastoreInstances.get(firestore);\n}\n/**\r\n * Removes all components associated with the provided instance. Must be called\r\n * when the `Firestore` instance is terminated.\r\n */ function removeComponents(firestore) {\n    const datastore = datastoreInstances.get(firestore);\n    if (datastore) {\n        logDebug(LOG_TAG$1, \"Removing Datastore\");\n        datastoreInstances.delete(firestore);\n        datastore.terminate();\n    }\n}\nfunction makeDatabaseInfo(databaseId, appId, persistenceKey, settings) {\n    return new DatabaseInfo(databaseId, appId, persistenceKey, settings.host, settings.ssl, settings.experimentalForceLongPolling, settings.experimentalAutoDetectLongPolling, cloneLongPollingOptions(settings.experimentalLongPollingOptions), settings.useFetchStreams);\n}\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const LRU_COLLECTION_DISABLED = -1;\nconst LRU_DEFAULT_CACHE_SIZE_BYTES = 40 * 1024 * 1024;\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** Verifies whether `e` is an IndexedDbTransactionError. */ function isIndexedDbTransactionError(e) {\n    // Use name equality, as instanceof checks on errors don't work with errors\n    // that wrap other errors.\n    return e.name === \"IndexedDbTransactionError\";\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const LRU_MINIMUM_CACHE_SIZE_BYTES = 1 * 1024 * 1024;\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // settings() defaults:\nconst DEFAULT_HOST = \"firestore.googleapis.com\";\nconst DEFAULT_SSL = true;\n// The minimum long-polling timeout is hardcoded on the server. The value here\n// should be kept in sync with the value used by the server, as the server will\n// silently ignore a value below the minimum and fall back to the default.\n// Googlers see b/266868871 for relevant discussion.\nconst MIN_LONG_POLLING_TIMEOUT_SECONDS = 5;\n// No maximum long-polling timeout is configured in the server, and defaults to\n// 30 seconds, which is what Watch appears to use.\n// Googlers see b/266868871 for relevant discussion.\nconst MAX_LONG_POLLING_TIMEOUT_SECONDS = 30;\n// Whether long-polling auto-detected is enabled by default.\nconst DEFAULT_AUTO_DETECT_LONG_POLLING = true;\n/**\r\n * A concrete type describing all the values that can be applied via a\r\n * user-supplied `FirestoreSettings` object. This is a separate type so that\r\n * defaults can be supplied and the value can be checked for equality.\r\n */ class FirestoreSettingsImpl {\n    constructor(settings){\n        var _a, _b;\n        if (settings.host === undefined) {\n            if (settings.ssl !== undefined) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\n            }\n            this.host = DEFAULT_HOST;\n            this.ssl = DEFAULT_SSL;\n        } else {\n            this.host = settings.host;\n            this.ssl = (_a = settings.ssl) !== null && _a !== void 0 ? _a : DEFAULT_SSL;\n        }\n        this.credentials = settings.credentials;\n        this.ignoreUndefinedProperties = !!settings.ignoreUndefinedProperties;\n        this.localCache = settings.localCache;\n        if (settings.cacheSizeBytes === undefined) {\n            this.cacheSizeBytes = LRU_DEFAULT_CACHE_SIZE_BYTES;\n        } else {\n            if (settings.cacheSizeBytes !== LRU_COLLECTION_DISABLED && settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);\n            } else {\n                this.cacheSizeBytes = settings.cacheSizeBytes;\n            }\n        }\n        validateIsNotUsedTogether(\"experimentalForceLongPolling\", settings.experimentalForceLongPolling, \"experimentalAutoDetectLongPolling\", settings.experimentalAutoDetectLongPolling);\n        this.experimentalForceLongPolling = !!settings.experimentalForceLongPolling;\n        if (this.experimentalForceLongPolling) {\n            this.experimentalAutoDetectLongPolling = false;\n        } else if (settings.experimentalAutoDetectLongPolling === undefined) {\n            this.experimentalAutoDetectLongPolling = DEFAULT_AUTO_DETECT_LONG_POLLING;\n        } else {\n            // For backwards compatibility, coerce the value to boolean even though\n            // the TypeScript compiler has narrowed the type to boolean already.\n            // noinspection PointlessBooleanExpressionJS\n            this.experimentalAutoDetectLongPolling = !!settings.experimentalAutoDetectLongPolling;\n        }\n        this.experimentalLongPollingOptions = cloneLongPollingOptions((_b = settings.experimentalLongPollingOptions) !== null && _b !== void 0 ? _b : {});\n        validateLongPollingOptions(this.experimentalLongPollingOptions);\n        this.useFetchStreams = !!settings.useFetchStreams;\n    }\n    isEqual(other) {\n        return this.host === other.host && this.ssl === other.ssl && this.credentials === other.credentials && this.cacheSizeBytes === other.cacheSizeBytes && this.experimentalForceLongPolling === other.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === other.experimentalAutoDetectLongPolling && longPollingOptionsEqual(this.experimentalLongPollingOptions, other.experimentalLongPollingOptions) && this.ignoreUndefinedProperties === other.ignoreUndefinedProperties && this.useFetchStreams === other.useFetchStreams;\n    }\n}\nfunction validateLongPollingOptions(options) {\n    if (options.timeoutSeconds !== undefined) {\n        if (isNaN(options.timeoutSeconds)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ` + `${options.timeoutSeconds} (must not be NaN)`);\n        }\n        if (options.timeoutSeconds < MIN_LONG_POLLING_TIMEOUT_SECONDS) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} ` + `(minimum allowed value is ${MIN_LONG_POLLING_TIMEOUT_SECONDS})`);\n        }\n        if (options.timeoutSeconds > MAX_LONG_POLLING_TIMEOUT_SECONDS) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} ` + `(maximum allowed value is ${MAX_LONG_POLLING_TIMEOUT_SECONDS})`);\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The Cloud Firestore service interface.\r\n *\r\n * Do not call this constructor directly. Instead, use {@link (getFirestore:1)}.\r\n */ class Firestore {\n    /** @hideconstructor */ constructor(_authCredentials, _appCheckCredentials, _databaseId, _app){\n        this._authCredentials = _authCredentials;\n        this._appCheckCredentials = _appCheckCredentials;\n        this._databaseId = _databaseId;\n        this._app = _app;\n        /**\r\n         * Whether it's a Firestore or Firestore Lite instance.\r\n         */ this.type = \"firestore-lite\";\n        this._persistenceKey = \"(lite)\";\n        this._settings = new FirestoreSettingsImpl({});\n        this._settingsFrozen = false;\n    }\n    /**\r\n     * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service\r\n     * instance.\r\n     */ get app() {\n        if (!this._app) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is \" + \"not available\");\n        }\n        return this._app;\n    }\n    get _initialized() {\n        return this._settingsFrozen;\n    }\n    get _terminated() {\n        return this._terminateTask !== undefined;\n    }\n    _setSettings(settings) {\n        if (this._settingsFrozen) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, \"Firestore has already been started and its settings can no longer \" + \"be changed. You can only modify settings before calling any other \" + \"methods on a Firestore object.\");\n        }\n        this._settings = new FirestoreSettingsImpl(settings);\n        if (settings.credentials !== undefined) {\n            this._authCredentials = makeAuthCredentialsProvider(settings.credentials);\n        }\n    }\n    _getSettings() {\n        return this._settings;\n    }\n    _freezeSettings() {\n        this._settingsFrozen = true;\n        return this._settings;\n    }\n    _delete() {\n        if (!this._terminateTask) {\n            this._terminateTask = this._terminate();\n        }\n        return this._terminateTask;\n    }\n    /** Returns a JSON-serializable representation of this `Firestore` instance. */ toJSON() {\n        return {\n            app: this._app,\n            databaseId: this._databaseId,\n            settings: this._settings\n        };\n    }\n    /**\r\n     * Terminates all components used by this client. Subclasses can override\r\n     * this method to clean up their own dependencies, but must also call this\r\n     * method.\r\n     *\r\n     * Only ever called once.\r\n     */ _terminate() {\n        removeComponents(this);\n        return Promise.resolve();\n    }\n}\nfunction initializeFirestore(app, settings, databaseId) {\n    if (!databaseId) {\n        databaseId = DEFAULT_DATABASE_NAME;\n    }\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, \"firestore/lite\");\n    if (provider.isInitialized(databaseId)) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, \"Firestore can only be initialized once per app.\");\n    }\n    return provider.initialize({\n        options: settings,\n        instanceIdentifier: databaseId\n    });\n}\nfunction getFirestore(appOrDatabaseId, optionalDatabaseId) {\n    const app = typeof appOrDatabaseId === \"object\" ? appOrDatabaseId : (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)();\n    const databaseId = typeof appOrDatabaseId === \"string\" ? appOrDatabaseId : optionalDatabaseId || \"(default)\";\n    const db = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, \"firestore/lite\").getImmediate({\n        identifier: databaseId\n    });\n    if (!db._initialized) {\n        const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getDefaultEmulatorHostnameAndPort)(\"firestore\");\n        if (emulator) {\n            connectFirestoreEmulator(db, ...emulator);\n        }\n    }\n    return db;\n}\n/**\r\n * Modify this instance to communicate with the Cloud Firestore emulator.\r\n *\r\n * Note: This must be called before this instance has been used to do any\r\n * operations.\r\n *\r\n * @param firestore - The `Firestore` instance to configure to connect to the\r\n * emulator.\r\n * @param host - the emulator host (ex: localhost).\r\n * @param port - the emulator port (ex: 9000).\r\n * @param options.mockUserToken - the mock auth token to use for unit testing\r\n * Security Rules.\r\n */ function connectFirestoreEmulator(firestore, host, port, options = {}) {\n    var _a;\n    firestore = cast(firestore, Firestore);\n    const settings = firestore._getSettings();\n    const newHostSetting = `${host}:${port}`;\n    if (settings.host !== DEFAULT_HOST && settings.host !== newHostSetting) {\n        logWarn(\"Host has been set in both settings() and connectFirestoreEmulator(), emulator host \" + \"will be used.\");\n    }\n    firestore._setSettings(Object.assign(Object.assign({}, settings), {\n        host: newHostSetting,\n        ssl: false\n    }));\n    if (options.mockUserToken) {\n        let token;\n        let user;\n        if (typeof options.mockUserToken === \"string\") {\n            token = options.mockUserToken;\n            user = User.MOCK_USER;\n        } else {\n            // Let createMockUserToken validate first (catches common mistakes like\n            // invalid field \"uid\" and missing field \"sub\" / \"user_id\".)\n            token = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.createMockUserToken)(options.mockUserToken, (_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.projectId);\n            const uid = options.mockUserToken.sub || options.mockUserToken.user_id;\n            if (!uid) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"mockUserToken must contain 'sub' or 'user_id' field!\");\n            }\n            user = new User(uid);\n        }\n        firestore._authCredentials = new EmulatorAuthCredentialsProvider(new OAuthToken(token, user));\n    }\n}\n/**\r\n * Terminates the provided `Firestore` instance.\r\n *\r\n * After calling `terminate()` only the `clearIndexedDbPersistence()` functions\r\n * may be used. Any other function will throw a `FirestoreError`. Termination\r\n * does not cancel any pending writes, and any promises that are awaiting a\r\n * response from the server will not be resolved.\r\n *\r\n * To restart after termination, create a new instance of `Firestore` with\r\n * {@link (getFirestore:1)}.\r\n *\r\n * Note: Under normal circumstances, calling `terminate()` is not required. This\r\n * function is useful only when you want to force this instance to release all of\r\n * its resources or in combination with {@link clearIndexedDbPersistence} to\r\n * ensure that all local state is destroyed between test runs.\r\n *\r\n * @param firestore - The `Firestore` instance to terminate.\r\n * @returns A `Promise` that is resolved when the instance has been successfully\r\n * terminated.\r\n */ function terminate(firestore) {\n    firestore = cast(firestore, Firestore);\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._removeServiceInstance)(firestore.app, \"firestore/lite\");\n    return firestore._delete();\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function registerFirestore() {\n    setSDKVersion(`${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}_lite`);\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component(\"firestore/lite\", (container, { instanceIdentifier: databaseId, options: settings })=>{\n        const app = container.getProvider(\"app\").getImmediate();\n        const firestoreInstance = new Firestore(new LiteAuthCredentialsProvider(container.getProvider(\"auth-internal\")), new LiteAppCheckTokenProvider(container.getProvider(\"app-check-internal\")), databaseIdFromApp(app, databaseId), app);\n        if (settings) {\n            firestoreInstance._setSettings(settings);\n        }\n        return firestoreInstance;\n    }, \"PUBLIC\").setMultipleInstances(true));\n    // RUNTIME_ENV and BUILD_TARGET are replaced by real values during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(\"firestore-lite\", version$1, \"node\");\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(\"firestore-lite\", version$1, \"esm2017\");\n}\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Concrete implementation of the Aggregate type.\r\n */ class AggregateImpl {\n    constructor(alias, aggregateType, fieldPath){\n        this.alias = alias;\n        this.aggregateType = aggregateType;\n        this.fieldPath = fieldPath;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Represents an aggregation that can be performed by Firestore.\r\n */ // eslint-disable-next-line @typescript-eslint/no-unused-vars\nclass AggregateField {\n    /**\r\n     * Create a new AggregateField<T>\r\n     * @param aggregateType Specifies the type of aggregation operation to perform.\r\n     * @param _internalFieldPath Optionally specifies the field that is aggregated.\r\n     * @internal\r\n     */ constructor(aggregateType = \"count\", _internalFieldPath){\n        this._internalFieldPath = _internalFieldPath;\n        /** A type string to uniquely identify instances of this class. */ this.type = \"AggregateField\";\n        this.aggregateType = aggregateType;\n    }\n}\n/**\r\n * The results of executing an aggregation query.\r\n */ class AggregateQuerySnapshot {\n    /** @hideconstructor */ constructor(query, _userDataWriter, _data){\n        this._userDataWriter = _userDataWriter;\n        this._data = _data;\n        /** A type string to uniquely identify instances of this class. */ this.type = \"AggregateQuerySnapshot\";\n        this.query = query;\n    }\n    /**\r\n     * Returns the results of the aggregations performed over the underlying\r\n     * query.\r\n     *\r\n     * The keys of the returned object will be the same as those of the\r\n     * `AggregateSpec` object specified to the aggregation method, and the values\r\n     * will be the corresponding aggregation result.\r\n     *\r\n     * @returns The results of the aggregations performed over the underlying\r\n     * query.\r\n     */ data() {\n        return this._userDataWriter.convertObjectMap(this._data);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A `Query` refers to a query which you can read or listen to. You can also\r\n * construct refined `Query` objects by adding filters and ordering.\r\n */ class Query {\n    // This is the lite version of the Query class in the main SDK.\n    /** @hideconstructor protected */ constructor(firestore, /**\r\n     * If provided, the `FirestoreDataConverter` associated with this instance.\r\n     */ converter, _query){\n        this.converter = converter;\n        this._query = _query;\n        /** The type of this Firestore reference. */ this.type = \"query\";\n        this.firestore = firestore;\n    }\n    withConverter(converter) {\n        return new Query(this.firestore, converter, this._query);\n    }\n}\n/**\r\n * A `DocumentReference` refers to a document location in a Firestore database\r\n * and can be used to write, read, or listen to the location. The document at\r\n * the referenced location may or may not exist.\r\n */ class DocumentReference {\n    /** @hideconstructor */ constructor(firestore, /**\r\n     * If provided, the `FirestoreDataConverter` associated with this instance.\r\n     */ converter, _key){\n        this.converter = converter;\n        this._key = _key;\n        /** The type of this Firestore reference. */ this.type = \"document\";\n        this.firestore = firestore;\n    }\n    get _path() {\n        return this._key.path;\n    }\n    /**\r\n     * The document's identifier within its collection.\r\n     */ get id() {\n        return this._key.path.lastSegment();\n    }\n    /**\r\n     * A string representing the path of the referenced document (relative\r\n     * to the root of the database).\r\n     */ get path() {\n        return this._key.path.canonicalString();\n    }\n    /**\r\n     * The collection this `DocumentReference` belongs to.\r\n     */ get parent() {\n        return new CollectionReference(this.firestore, this.converter, this._key.path.popLast());\n    }\n    withConverter(converter) {\n        return new DocumentReference(this.firestore, converter, this._key);\n    }\n}\n/**\r\n * A `CollectionReference` object can be used for adding documents, getting\r\n * document references, and querying for documents (using {@link (query:1)}).\r\n */ class CollectionReference extends Query {\n    /** @hideconstructor */ constructor(firestore, converter, _path){\n        super(firestore, converter, newQueryForPath(_path));\n        this._path = _path;\n        /** The type of this Firestore reference. */ this.type = \"collection\";\n    }\n    /** The collection's identifier. */ get id() {\n        return this._query.path.lastSegment();\n    }\n    /**\r\n     * A string representing the path of the referenced collection (relative\r\n     * to the root of the database).\r\n     */ get path() {\n        return this._query.path.canonicalString();\n    }\n    /**\r\n     * A reference to the containing `DocumentReference` if this is a\r\n     * subcollection. If this isn't a subcollection, the reference is null.\r\n     */ get parent() {\n        const parentPath = this._path.popLast();\n        if (parentPath.isEmpty()) {\n            return null;\n        } else {\n            return new DocumentReference(this.firestore, /* converter= */ null, new DocumentKey(parentPath));\n        }\n    }\n    withConverter(converter) {\n        return new CollectionReference(this.firestore, converter, this._path);\n    }\n}\nfunction collection(parent, path, ...pathSegments) {\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(parent);\n    validateNonEmptyArgument(\"collection\", \"path\", path);\n    if (parent instanceof Firestore) {\n        const absolutePath = ResourcePath.fromString(path, ...pathSegments);\n        validateCollectionPath(absolutePath);\n        return new CollectionReference(parent, /* converter= */ null, absolutePath);\n    } else {\n        if (!(parent instanceof DocumentReference) && !(parent instanceof CollectionReference)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Expected first argument to collection() to be a CollectionReference, \" + \"a DocumentReference or FirebaseFirestore\");\n        }\n        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));\n        validateCollectionPath(absolutePath);\n        return new CollectionReference(parent.firestore, /* converter= */ null, absolutePath);\n    }\n}\n// TODO(firestorelite): Consider using ErrorFactory -\n// https://github.com/firebase/firebase-js-sdk/blob/0131e1f/packages/util/src/errors.ts#L106\n/**\r\n * Creates and returns a new `Query` instance that includes all documents in the\r\n * database that are contained in a collection or subcollection with the\r\n * given `collectionId`.\r\n *\r\n * @param firestore - A reference to the root `Firestore` instance.\r\n * @param collectionId - Identifies the collections to query over. Every\r\n * collection or subcollection with this ID as the last segment of its path\r\n * will be included. Cannot contain a slash.\r\n * @returns The created `Query`.\r\n */ function collectionGroup(firestore, collectionId) {\n    firestore = cast(firestore, Firestore);\n    validateNonEmptyArgument(\"collectionGroup\", \"collection id\", collectionId);\n    if (collectionId.indexOf(\"/\") >= 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection ID '${collectionId}' passed to function ` + `collectionGroup(). Collection IDs must not contain '/'.`);\n    }\n    return new Query(firestore, /* converter= */ null, newQueryForCollectionGroup(collectionId));\n}\nfunction doc(parent, path, ...pathSegments) {\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(parent);\n    // We allow omission of 'pathString' but explicitly prohibit passing in both\n    // 'undefined' and 'null'.\n    if (arguments.length === 1) {\n        path = AutoId.newId();\n    }\n    validateNonEmptyArgument(\"doc\", \"path\", path);\n    if (parent instanceof Firestore) {\n        const absolutePath = ResourcePath.fromString(path, ...pathSegments);\n        validateDocumentPath(absolutePath);\n        return new DocumentReference(parent, /* converter= */ null, new DocumentKey(absolutePath));\n    } else {\n        if (!(parent instanceof DocumentReference) && !(parent instanceof CollectionReference)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Expected first argument to collection() to be a CollectionReference, \" + \"a DocumentReference or FirebaseFirestore\");\n        }\n        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));\n        validateDocumentPath(absolutePath);\n        return new DocumentReference(parent.firestore, parent instanceof CollectionReference ? parent.converter : null, new DocumentKey(absolutePath));\n    }\n}\n/**\r\n * Returns true if the provided references are equal.\r\n *\r\n * @param left - A reference to compare.\r\n * @param right - A reference to compare.\r\n * @returns true if the references point to the same location in the same\r\n * Firestore database.\r\n */ function refEqual(left, right) {\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(left);\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(right);\n    if ((left instanceof DocumentReference || left instanceof CollectionReference) && (right instanceof DocumentReference || right instanceof CollectionReference)) {\n        return left.firestore === right.firestore && left.path === right.path && left.converter === right.converter;\n    }\n    return false;\n}\n/**\r\n * Returns true if the provided queries point to the same collection and apply\r\n * the same constraints.\r\n *\r\n * @param left - A `Query` to compare.\r\n * @param right - A `Query` to compare.\r\n * @returns true if the references point to the same location in the same\r\n * Firestore database.\r\n */ function queryEqual(left, right) {\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(left);\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(right);\n    if (left instanceof Query && right instanceof Query) {\n        return left.firestore === right.firestore && queryEquals(left._query, right._query) && left.converter === right.converter;\n    }\n    return false;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An immutable object representing an array of bytes.\r\n */ class Bytes {\n    /** @hideconstructor */ constructor(byteString){\n        this._byteString = byteString;\n    }\n    /**\r\n     * Creates a new `Bytes` object from the given Base64 string, converting it to\r\n     * bytes.\r\n     *\r\n     * @param base64 - The Base64 string used to create the `Bytes` object.\r\n     */ static fromBase64String(base64) {\n        try {\n            return new Bytes(ByteString.fromBase64String(base64));\n        } catch (e) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Failed to construct data from Base64 string: \" + e);\n        }\n    }\n    /**\r\n     * Creates a new `Bytes` object from the given Uint8Array.\r\n     *\r\n     * @param array - The Uint8Array used to create the `Bytes` object.\r\n     */ static fromUint8Array(array) {\n        return new Bytes(ByteString.fromUint8Array(array));\n    }\n    /**\r\n     * Returns the underlying bytes as a Base64-encoded string.\r\n     *\r\n     * @returns The Base64-encoded string created from the `Bytes` object.\r\n     */ toBase64() {\n        return this._byteString.toBase64();\n    }\n    /**\r\n     * Returns the underlying bytes in a new `Uint8Array`.\r\n     *\r\n     * @returns The Uint8Array created from the `Bytes` object.\r\n     */ toUint8Array() {\n        return this._byteString.toUint8Array();\n    }\n    /**\r\n     * Returns a string representation of the `Bytes` object.\r\n     *\r\n     * @returns A string representation of the `Bytes` object.\r\n     */ toString() {\n        return \"Bytes(base64: \" + this.toBase64() + \")\";\n    }\n    /**\r\n     * Returns true if this `Bytes` object is equal to the provided one.\r\n     *\r\n     * @param other - The `Bytes` object to compare against.\r\n     * @returns true if this `Bytes` object is equal to the provided one.\r\n     */ isEqual(other) {\n        return this._byteString.isEqual(other._byteString);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A `FieldPath` refers to a field in a document. The path may consist of a\r\n * single field name (referring to a top-level field in the document), or a\r\n * list of field names (referring to a nested field in the document).\r\n *\r\n * Create a `FieldPath` by providing field names. If more than one field\r\n * name is provided, the path will point to a nested field in a document.\r\n */ class FieldPath {\n    /**\r\n     * Creates a `FieldPath` from the provided field names. If more than one field\r\n     * name is provided, the path will point to a nested field in a document.\r\n     *\r\n     * @param fieldNames - A list of field names.\r\n     */ constructor(...fieldNames){\n        for(let i = 0; i < fieldNames.length; ++i){\n            if (fieldNames[i].length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field name at argument $(i + 1). ` + \"Field names must not be empty.\");\n            }\n        }\n        this._internalPath = new FieldPath$1(fieldNames);\n    }\n    /**\r\n     * Returns true if this `FieldPath` is equal to the provided one.\r\n     *\r\n     * @param other - The `FieldPath` to compare against.\r\n     * @returns true if this `FieldPath` is equal to the provided one.\r\n     */ isEqual(other) {\n        return this._internalPath.isEqual(other._internalPath);\n    }\n}\n/**\r\n * Returns a special sentinel `FieldPath` to refer to the ID of a document.\r\n * It can be used in queries to sort or filter by the document ID.\r\n */ function documentId() {\n    return new FieldPath(DOCUMENT_KEY_NAME);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Sentinel values that can be used when writing document fields with `set()`\r\n * or `update()`.\r\n */ class FieldValue {\n    /**\r\n     * @param _methodName - The public API endpoint that returns this class.\r\n     * @hideconstructor\r\n     */ constructor(_methodName){\n        this._methodName = _methodName;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An immutable object representing a geographic location in Firestore. The\r\n * location is represented as latitude/longitude pair.\r\n *\r\n * Latitude values are in the range of [-90, 90].\r\n * Longitude values are in the range of [-180, 180].\r\n */ class GeoPoint {\n    /**\r\n     * Creates a new immutable `GeoPoint` object with the provided latitude and\r\n     * longitude values.\r\n     * @param latitude - The latitude as number between -90 and 90.\r\n     * @param longitude - The longitude as number between -180 and 180.\r\n     */ constructor(latitude, longitude){\n        if (!isFinite(latitude) || latitude < -90 || latitude > 90) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Latitude must be a number between -90 and 90, but was: \" + latitude);\n        }\n        if (!isFinite(longitude) || longitude < -180 || longitude > 180) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Longitude must be a number between -180 and 180, but was: \" + longitude);\n        }\n        this._lat = latitude;\n        this._long = longitude;\n    }\n    /**\r\n     * The latitude of this `GeoPoint` instance.\r\n     */ get latitude() {\n        return this._lat;\n    }\n    /**\r\n     * The longitude of this `GeoPoint` instance.\r\n     */ get longitude() {\n        return this._long;\n    }\n    /**\r\n     * Returns true if this `GeoPoint` is equal to the provided one.\r\n     *\r\n     * @param other - The `GeoPoint` to compare against.\r\n     * @returns true if this `GeoPoint` is equal to the provided one.\r\n     */ isEqual(other) {\n        return this._lat === other._lat && this._long === other._long;\n    }\n    /** Returns a JSON-serializable representation of this GeoPoint. */ toJSON() {\n        return {\n            latitude: this._lat,\n            longitude: this._long\n        };\n    }\n    /**\r\n     * Actually private to JS consumers of our API, so this function is prefixed\r\n     * with an underscore.\r\n     */ _compareTo(other) {\n        return primitiveComparator(this._lat, other._lat) || primitiveComparator(this._long, other._long);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const RESERVED_FIELD_REGEX = /^__.*__$/;\n/** The result of parsing document data (e.g. for a setData call). */ class ParsedSetData {\n    constructor(data, fieldMask, fieldTransforms){\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    toMutation(key, precondition) {\n        if (this.fieldMask !== null) {\n            return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);\n        } else {\n            return new SetMutation(key, this.data, precondition, this.fieldTransforms);\n        }\n    }\n}\n/** The result of parsing \"update\" data (i.e. for an updateData call). */ class ParsedUpdateData {\n    constructor(data, // The fieldMask does not include document transforms.\n    fieldMask, fieldTransforms){\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    toMutation(key, precondition) {\n        return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);\n    }\n}\nfunction isWrite(dataSource) {\n    switch(dataSource){\n        case 0 /* UserDataSource.Set */ :\n        case 2 /* UserDataSource.MergeSet */ :\n        case 1 /* UserDataSource.Update */ :\n            return true;\n        case 3 /* UserDataSource.Argument */ :\n        case 4 /* UserDataSource.ArrayArgument */ :\n            return false;\n        default:\n            throw fail();\n    }\n}\n/** A \"context\" object passed around while parsing user data. */ class ParseContextImpl {\n    /**\r\n     * Initializes a ParseContext with the given source and path.\r\n     *\r\n     * @param settings - The settings for the parser.\r\n     * @param databaseId - The database ID of the Firestore instance.\r\n     * @param serializer - The serializer to use to generate the Value proto.\r\n     * @param ignoreUndefinedProperties - Whether to ignore undefined properties\r\n     * rather than throw.\r\n     * @param fieldTransforms - A mutable list of field transforms encountered\r\n     * while parsing the data.\r\n     * @param fieldMask - A mutable list of field paths encountered while parsing\r\n     * the data.\r\n     *\r\n     * TODO(b/34871131): We don't support array paths right now, so path can be\r\n     * null to indicate the context represents any location within an array (in\r\n     * which case certain features will not work and errors will be somewhat\r\n     * compromised).\r\n     */ constructor(settings, databaseId, serializer, ignoreUndefinedProperties, fieldTransforms, fieldMask){\n        this.settings = settings;\n        this.databaseId = databaseId;\n        this.serializer = serializer;\n        this.ignoreUndefinedProperties = ignoreUndefinedProperties;\n        // Minor hack: If fieldTransforms is undefined, we assume this is an\n        // external call and we need to validate the entire path.\n        if (fieldTransforms === undefined) {\n            this.validatePath();\n        }\n        this.fieldTransforms = fieldTransforms || [];\n        this.fieldMask = fieldMask || [];\n    }\n    get path() {\n        return this.settings.path;\n    }\n    get dataSource() {\n        return this.settings.dataSource;\n    }\n    /** Returns a new context with the specified settings overwritten. */ contextWith(configuration) {\n        return new ParseContextImpl(Object.assign(Object.assign({}, this.settings), configuration), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);\n    }\n    childContextForField(field) {\n        var _a;\n        const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);\n        const context = this.contextWith({\n            path: childPath,\n            arrayElement: false\n        });\n        context.validatePathSegment(field);\n        return context;\n    }\n    childContextForFieldPath(field) {\n        var _a;\n        const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);\n        const context = this.contextWith({\n            path: childPath,\n            arrayElement: false\n        });\n        context.validatePath();\n        return context;\n    }\n    childContextForArray(index) {\n        // TODO(b/34871131): We don't support array paths right now; so make path\n        // undefined.\n        return this.contextWith({\n            path: undefined,\n            arrayElement: true\n        });\n    }\n    createError(reason) {\n        return createError(reason, this.settings.methodName, this.settings.hasConverter || false, this.path, this.settings.targetDoc);\n    }\n    /** Returns 'true' if 'fieldPath' was traversed when creating this context. */ contains(fieldPath) {\n        return this.fieldMask.find((field)=>fieldPath.isPrefixOf(field)) !== undefined || this.fieldTransforms.find((transform)=>fieldPath.isPrefixOf(transform.field)) !== undefined;\n    }\n    validatePath() {\n        // TODO(b/34871131): Remove null check once we have proper paths for fields\n        // within arrays.\n        if (!this.path) {\n            return;\n        }\n        for(let i = 0; i < this.path.length; i++){\n            this.validatePathSegment(this.path.get(i));\n        }\n    }\n    validatePathSegment(segment) {\n        if (segment.length === 0) {\n            throw this.createError(\"Document fields must not be empty\");\n        }\n        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {\n            throw this.createError('Document fields cannot begin and end with \"__\"');\n        }\n    }\n}\n/**\r\n * Helper for parsing raw user input (provided via the API) into internal model\r\n * classes.\r\n */ class UserDataReader {\n    constructor(databaseId, ignoreUndefinedProperties, serializer){\n        this.databaseId = databaseId;\n        this.ignoreUndefinedProperties = ignoreUndefinedProperties;\n        this.serializer = serializer || newSerializer(databaseId);\n    }\n    /** Creates a new top-level parse context. */ createContext(dataSource, methodName, targetDoc, hasConverter = false) {\n        return new ParseContextImpl({\n            dataSource,\n            methodName,\n            targetDoc,\n            path: FieldPath$1.emptyPath(),\n            arrayElement: false,\n            hasConverter\n        }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);\n    }\n}\nfunction newUserDataReader(firestore) {\n    const settings = firestore._freezeSettings();\n    const serializer = newSerializer(firestore._databaseId);\n    return new UserDataReader(firestore._databaseId, !!settings.ignoreUndefinedProperties, serializer);\n}\n/** Parse document data from a set() call. */ function parseSetData(userDataReader, methodName, targetDoc, input, hasConverter, options = {}) {\n    const context = userDataReader.createContext(options.merge || options.mergeFields ? 2 /* UserDataSource.MergeSet */  : 0 /* UserDataSource.Set */ , methodName, targetDoc, hasConverter);\n    validatePlainObject(\"Data must be an object, but it was:\", context, input);\n    const updateData = parseObject(input, context);\n    let fieldMask;\n    let fieldTransforms;\n    if (options.merge) {\n        fieldMask = new FieldMask(context.fieldMask);\n        fieldTransforms = context.fieldTransforms;\n    } else if (options.mergeFields) {\n        const validatedFieldPaths = [];\n        for (const stringOrFieldPath of options.mergeFields){\n            const fieldPath = fieldPathFromArgument$1(methodName, stringOrFieldPath, targetDoc);\n            if (!context.contains(fieldPath)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Field '${fieldPath}' is specified in your field mask but missing from your input data.`);\n            }\n            if (!fieldMaskContains(validatedFieldPaths, fieldPath)) {\n                validatedFieldPaths.push(fieldPath);\n            }\n        }\n        fieldMask = new FieldMask(validatedFieldPaths);\n        fieldTransforms = context.fieldTransforms.filter((transform)=>fieldMask.covers(transform.field));\n    } else {\n        fieldMask = null;\n        fieldTransforms = context.fieldTransforms;\n    }\n    return new ParsedSetData(new ObjectValue(updateData), fieldMask, fieldTransforms);\n}\nclass DeleteFieldValueImpl extends FieldValue {\n    _toFieldTransform(context) {\n        if (context.dataSource === 2 /* UserDataSource.MergeSet */ ) {\n            // No transform to add for a delete, but we need to add it to our\n            // fieldMask so it gets deleted.\n            context.fieldMask.push(context.path);\n        } else if (context.dataSource === 1 /* UserDataSource.Update */ ) {\n            throw context.createError(`${this._methodName}() can only appear at the top level ` + \"of your update data\");\n        } else {\n            // We shouldn't encounter delete sentinels for queries or non-merge set() calls.\n            throw context.createError(`${this._methodName}() cannot be used with set() unless you pass ` + \"{merge:true}\");\n        }\n        return null;\n    }\n    isEqual(other) {\n        return other instanceof DeleteFieldValueImpl;\n    }\n}\n/**\r\n * Creates a child context for parsing SerializableFieldValues.\r\n *\r\n * This is different than calling `ParseContext.contextWith` because it keeps\r\n * the fieldTransforms and fieldMask separate.\r\n *\r\n * The created context has its `dataSource` set to `UserDataSource.Argument`.\r\n * Although these values are used with writes, any elements in these FieldValues\r\n * are not considered writes since they cannot contain any FieldValue sentinels,\r\n * etc.\r\n *\r\n * @param fieldValue - The sentinel FieldValue for which to create a child\r\n *     context.\r\n * @param context - The parent context.\r\n * @param arrayElement - Whether or not the FieldValue has an array.\r\n */ function createSentinelChildContext(fieldValue, context, arrayElement) {\n    return new ParseContextImpl({\n        dataSource: 3 /* UserDataSource.Argument */ ,\n        targetDoc: context.settings.targetDoc,\n        methodName: fieldValue._methodName,\n        arrayElement\n    }, context.databaseId, context.serializer, context.ignoreUndefinedProperties);\n}\nclass ServerTimestampFieldValueImpl extends FieldValue {\n    _toFieldTransform(context) {\n        return new FieldTransform(context.path, new ServerTimestampTransform());\n    }\n    isEqual(other) {\n        return other instanceof ServerTimestampFieldValueImpl;\n    }\n}\nclass ArrayUnionFieldValueImpl extends FieldValue {\n    constructor(methodName, _elements){\n        super(methodName);\n        this._elements = _elements;\n    }\n    _toFieldTransform(context) {\n        const parseContext = createSentinelChildContext(this, context, /*array=*/ true);\n        const parsedElements = this._elements.map((element)=>parseData(element, parseContext));\n        const arrayUnion = new ArrayUnionTransformOperation(parsedElements);\n        return new FieldTransform(context.path, arrayUnion);\n    }\n    isEqual(other) {\n        return other instanceof ArrayUnionFieldValueImpl && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(this._elements, other._elements);\n    }\n}\nclass ArrayRemoveFieldValueImpl extends FieldValue {\n    constructor(methodName, _elements){\n        super(methodName);\n        this._elements = _elements;\n    }\n    _toFieldTransform(context) {\n        const parseContext = createSentinelChildContext(this, context, /*array=*/ true);\n        const parsedElements = this._elements.map((element)=>parseData(element, parseContext));\n        const arrayUnion = new ArrayRemoveTransformOperation(parsedElements);\n        return new FieldTransform(context.path, arrayUnion);\n    }\n    isEqual(other) {\n        return other instanceof ArrayRemoveFieldValueImpl && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(this._elements, other._elements);\n    }\n}\nclass NumericIncrementFieldValueImpl extends FieldValue {\n    constructor(methodName, _operand){\n        super(methodName);\n        this._operand = _operand;\n    }\n    _toFieldTransform(context) {\n        const numericIncrement = new NumericIncrementTransformOperation(context.serializer, toNumber(context.serializer, this._operand));\n        return new FieldTransform(context.path, numericIncrement);\n    }\n    isEqual(other) {\n        return other instanceof NumericIncrementFieldValueImpl && this._operand === other._operand;\n    }\n}\n/** Parse update data from an update() call. */ function parseUpdateData(userDataReader, methodName, targetDoc, input) {\n    const context = userDataReader.createContext(1 /* UserDataSource.Update */ , methodName, targetDoc);\n    validatePlainObject(\"Data must be an object, but it was:\", context, input);\n    const fieldMaskPaths = [];\n    const updateData = ObjectValue.empty();\n    forEach(input, (key, value)=>{\n        const path = fieldPathFromDotSeparatedString(methodName, key, targetDoc);\n        // For Compat types, we have to \"extract\" the underlying types before\n        // performing validation.\n        value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\n        const childContext = context.childContextForFieldPath(path);\n        if (value instanceof DeleteFieldValueImpl) {\n            // Add it to the field mask, but don't add anything to updateData.\n            fieldMaskPaths.push(path);\n        } else {\n            const parsedValue = parseData(value, childContext);\n            if (parsedValue != null) {\n                fieldMaskPaths.push(path);\n                updateData.set(path, parsedValue);\n            }\n        }\n    });\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n}\n/** Parse update data from a list of field/value arguments. */ function parseUpdateVarargs(userDataReader, methodName, targetDoc, field, value, moreFieldsAndValues) {\n    const context = userDataReader.createContext(1 /* UserDataSource.Update */ , methodName, targetDoc);\n    const keys = [\n        fieldPathFromArgument$1(methodName, field, targetDoc)\n    ];\n    const values = [\n        value\n    ];\n    if (moreFieldsAndValues.length % 2 !== 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${methodName}() needs to be called with an even number ` + \"of arguments that alternate between field names and values.\");\n    }\n    for(let i = 0; i < moreFieldsAndValues.length; i += 2){\n        keys.push(fieldPathFromArgument$1(methodName, moreFieldsAndValues[i]));\n        values.push(moreFieldsAndValues[i + 1]);\n    }\n    const fieldMaskPaths = [];\n    const updateData = ObjectValue.empty();\n    // We iterate in reverse order to pick the last value for a field if the\n    // user specified the field multiple times.\n    for(let i = keys.length - 1; i >= 0; --i){\n        if (!fieldMaskContains(fieldMaskPaths, keys[i])) {\n            const path = keys[i];\n            let value = values[i];\n            // For Compat types, we have to \"extract\" the underlying types before\n            // performing validation.\n            value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\n            const childContext = context.childContextForFieldPath(path);\n            if (value instanceof DeleteFieldValueImpl) {\n                // Add it to the field mask, but don't add anything to updateData.\n                fieldMaskPaths.push(path);\n            } else {\n                const parsedValue = parseData(value, childContext);\n                if (parsedValue != null) {\n                    fieldMaskPaths.push(path);\n                    updateData.set(path, parsedValue);\n                }\n            }\n        }\n    }\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n}\n/**\r\n * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\r\n * bound).\r\n *\r\n * @param allowArrays - Whether the query value is an array that may directly\r\n * contain additional arrays (e.g. the operand of an `in` query).\r\n */ function parseQueryValue(userDataReader, methodName, input, allowArrays = false) {\n    const context = userDataReader.createContext(allowArrays ? 4 /* UserDataSource.ArrayArgument */  : 3 /* UserDataSource.Argument */ , methodName);\n    const parsed = parseData(input, context);\n    return parsed;\n}\n/**\r\n * Parses user data to Protobuf Values.\r\n *\r\n * @param input - Data to be parsed.\r\n * @param context - A context object representing the current path being parsed,\r\n * the source of the data being parsed, etc.\r\n * @returns The parsed value, or null if the value was a FieldValue sentinel\r\n * that should not be included in the resulting parsed data.\r\n */ function parseData(input, context) {\n    // Unwrap the API type from the Compat SDK. This will return the API type\n    // from firestore-exp.\n    input = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(input);\n    if (looksLikeJsonObject(input)) {\n        validatePlainObject(\"Unsupported field value:\", context, input);\n        return parseObject(input, context);\n    } else if (input instanceof FieldValue) {\n        // FieldValues usually parse into transforms (except deleteField())\n        // in which case we do not want to include this field in our parsed data\n        // (as doing so will overwrite the field directly prior to the transform\n        // trying to transform it). So we don't add this location to\n        // context.fieldMask and we return null as our parsing result.\n        parseSentinelFieldValue(input, context);\n        return null;\n    } else if (input === undefined && context.ignoreUndefinedProperties) {\n        // If the input is undefined it can never participate in the fieldMask, so\n        // don't handle this below. If `ignoreUndefinedProperties` is false,\n        // `parseScalarValue` will reject an undefined value.\n        return null;\n    } else {\n        // If context.path is null we are inside an array and we don't support\n        // field mask paths more granular than the top-level array.\n        if (context.path) {\n            context.fieldMask.push(context.path);\n        }\n        if (input instanceof Array) {\n            // TODO(b/34871131): Include the path containing the array in the error\n            // message.\n            // In the case of IN queries, the parsed data is an array (representing\n            // the set of values to be included for the IN query) that may directly\n            // contain additional arrays (each representing an individual field\n            // value), so we disable this validation.\n            if (context.settings.arrayElement && context.dataSource !== 4 /* UserDataSource.ArrayArgument */ ) {\n                throw context.createError(\"Nested arrays are not supported\");\n            }\n            return parseArray(input, context);\n        } else {\n            return parseScalarValue(input, context);\n        }\n    }\n}\nfunction parseObject(obj, context) {\n    const fields = {};\n    if (isEmpty(obj)) {\n        // If we encounter an empty object, we explicitly add it to the update\n        // mask to ensure that the server creates a map entry.\n        if (context.path && context.path.length > 0) {\n            context.fieldMask.push(context.path);\n        }\n    } else {\n        forEach(obj, (key, val)=>{\n            const parsedValue = parseData(val, context.childContextForField(key));\n            if (parsedValue != null) {\n                fields[key] = parsedValue;\n            }\n        });\n    }\n    return {\n        mapValue: {\n            fields\n        }\n    };\n}\nfunction parseArray(array, context) {\n    const values = [];\n    let entryIndex = 0;\n    for (const entry of array){\n        let parsedEntry = parseData(entry, context.childContextForArray(entryIndex));\n        if (parsedEntry == null) {\n            // Just include nulls in the array for fields being replaced with a\n            // sentinel.\n            parsedEntry = {\n                nullValue: \"NULL_VALUE\"\n            };\n        }\n        values.push(parsedEntry);\n        entryIndex++;\n    }\n    return {\n        arrayValue: {\n            values\n        }\n    };\n}\n/**\r\n * \"Parses\" the provided FieldValueImpl, adding any necessary transforms to\r\n * context.fieldTransforms.\r\n */ function parseSentinelFieldValue(value, context) {\n    // Sentinels are only supported with writes, and not within arrays.\n    if (!isWrite(context.dataSource)) {\n        throw context.createError(`${value._methodName}() can only be used with update() and set()`);\n    }\n    if (!context.path) {\n        throw context.createError(`${value._methodName}() is not currently supported inside arrays`);\n    }\n    const fieldTransform = value._toFieldTransform(context);\n    if (fieldTransform) {\n        context.fieldTransforms.push(fieldTransform);\n    }\n}\n/**\r\n * Helper to parse a scalar value (i.e. not an Object, Array, or FieldValue)\r\n *\r\n * @returns The parsed value\r\n */ function parseScalarValue(value, context) {\n    value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\n    if (value === null) {\n        return {\n            nullValue: \"NULL_VALUE\"\n        };\n    } else if (typeof value === \"number\") {\n        return toNumber(context.serializer, value);\n    } else if (typeof value === \"boolean\") {\n        return {\n            booleanValue: value\n        };\n    } else if (typeof value === \"string\") {\n        return {\n            stringValue: value\n        };\n    } else if (value instanceof Date) {\n        const timestamp = Timestamp.fromDate(value);\n        return {\n            timestampValue: toTimestamp(context.serializer, timestamp)\n        };\n    } else if (value instanceof Timestamp) {\n        // Firestore backend truncates precision down to microseconds. To ensure\n        // offline mode works the same with regards to truncation, perform the\n        // truncation immediately without waiting for the backend to do that.\n        const timestamp = new Timestamp(value.seconds, Math.floor(value.nanoseconds / 1000) * 1000);\n        return {\n            timestampValue: toTimestamp(context.serializer, timestamp)\n        };\n    } else if (value instanceof GeoPoint) {\n        return {\n            geoPointValue: {\n                latitude: value.latitude,\n                longitude: value.longitude\n            }\n        };\n    } else if (value instanceof Bytes) {\n        return {\n            bytesValue: toBytes(context.serializer, value._byteString)\n        };\n    } else if (value instanceof DocumentReference) {\n        const thisDb = context.databaseId;\n        const otherDb = value.firestore._databaseId;\n        if (!otherDb.isEqual(thisDb)) {\n            throw context.createError(\"Document reference is for database \" + `${otherDb.projectId}/${otherDb.database} but should be ` + `for database ${thisDb.projectId}/${thisDb.database}`);\n        }\n        return {\n            referenceValue: toResourceName(value.firestore._databaseId || context.databaseId, value._key.path)\n        };\n    } else {\n        throw context.createError(`Unsupported field value: ${valueDescription(value)}`);\n    }\n}\n/**\r\n * Checks whether an object looks like a JSON object that should be converted\r\n * into a struct. Normal class/prototype instances are considered to look like\r\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\r\n * GeoPoints, etc. are not considered to look like JSON objects since they map\r\n * to specific FieldValue types other than ObjectValue.\r\n */ function looksLikeJsonObject(input) {\n    return typeof input === \"object\" && input !== null && !(input instanceof Array) && !(input instanceof Date) && !(input instanceof Timestamp) && !(input instanceof GeoPoint) && !(input instanceof Bytes) && !(input instanceof DocumentReference) && !(input instanceof FieldValue);\n}\nfunction validatePlainObject(message, context, input) {\n    if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\n        const description = valueDescription(input);\n        if (description === \"an object\") {\n            // Massage the error if it was an object.\n            throw context.createError(message + \" a custom object\");\n        } else {\n            throw context.createError(message + \" \" + description);\n        }\n    }\n}\n/**\r\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\r\n */ function fieldPathFromArgument$1(methodName, path, targetDoc) {\n    // If required, replace the FieldPath Compat class with with the firestore-exp\n    // FieldPath.\n    path = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(path);\n    if (path instanceof FieldPath) {\n        return path._internalPath;\n    } else if (typeof path === \"string\") {\n        return fieldPathFromDotSeparatedString(methodName, path);\n    } else {\n        const message = \"Field path arguments must be of type string or \";\n        throw createError(message, methodName, /* hasConverter= */ false, /* path= */ undefined, targetDoc);\n    }\n}\n/**\r\n * Matches any characters in a field path string that are reserved.\r\n */ const FIELD_PATH_RESERVED = new RegExp(\"[~\\\\*/\\\\[\\\\]]\");\n/**\r\n * Wraps fromDotSeparatedString with an error message about the method that\r\n * was thrown.\r\n * @param methodName - The publicly visible method name\r\n * @param path - The dot-separated string form of a field path which will be\r\n * split on dots.\r\n * @param targetDoc - The document against which the field path will be\r\n * evaluated.\r\n */ function fieldPathFromDotSeparatedString(methodName, path, targetDoc) {\n    const found = path.search(FIELD_PATH_RESERVED);\n    if (found >= 0) {\n        throw createError(`Invalid field path (${path}). Paths must not contain ` + `'~', '*', '/', '[', or ']'`, methodName, /* hasConverter= */ false, /* path= */ undefined, targetDoc);\n    }\n    try {\n        return new FieldPath(...path.split(\".\"))._internalPath;\n    } catch (e) {\n        throw createError(`Invalid field path (${path}). Paths must not be empty, ` + `begin with '.', end with '.', or contain '..'`, methodName, /* hasConverter= */ false, /* path= */ undefined, targetDoc);\n    }\n}\nfunction createError(reason, methodName, hasConverter, path, targetDoc) {\n    const hasPath = path && !path.isEmpty();\n    const hasDocument = targetDoc !== undefined;\n    let message = `Function ${methodName}() called with invalid data`;\n    if (hasConverter) {\n        message += \" (via `toFirestore()`)\";\n    }\n    message += \". \";\n    let description = \"\";\n    if (hasPath || hasDocument) {\n        description += \" (found\";\n        if (hasPath) {\n            description += ` in field ${path}`;\n        }\n        if (hasDocument) {\n            description += ` in document ${targetDoc}`;\n        }\n        description += \")\";\n    }\n    return new FirestoreError(Code.INVALID_ARGUMENT, message + reason + description);\n}\n/** Checks `haystack` if FieldPath `needle` is present. Runs in O(n). */ function fieldMaskContains(haystack, needle) {\n    return haystack.some((v)=>v.isEqual(needle));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A `DocumentSnapshot` contains data read from a document in your Firestore\r\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\r\n * get a specific field.\r\n *\r\n * For a `DocumentSnapshot` that points to a non-existing document, any data\r\n * access will return 'undefined'. You can use the `exists()` method to\r\n * explicitly verify a document's existence.\r\n */ class DocumentSnapshot {\n    // Note: This class is stripped down version of the DocumentSnapshot in\n    // the legacy SDK. The changes are:\n    // - No support for SnapshotMetadata.\n    // - No support for SnapshotOptions.\n    /** @hideconstructor protected */ constructor(_firestore, _userDataWriter, _key, _document, _converter){\n        this._firestore = _firestore;\n        this._userDataWriter = _userDataWriter;\n        this._key = _key;\n        this._document = _document;\n        this._converter = _converter;\n    }\n    /** Property of the `DocumentSnapshot` that provides the document's ID. */ get id() {\n        return this._key.path.lastSegment();\n    }\n    /**\r\n     * The `DocumentReference` for the document included in the `DocumentSnapshot`.\r\n     */ get ref() {\n        return new DocumentReference(this._firestore, this._converter, this._key);\n    }\n    /**\r\n     * Signals whether or not the document at the snapshot's location exists.\r\n     *\r\n     * @returns true if the document exists.\r\n     */ exists() {\n        return this._document !== null;\n    }\n    /**\r\n     * Retrieves all fields in the document as an `Object`. Returns `undefined` if\r\n     * the document doesn't exist.\r\n     *\r\n     * @returns An `Object` containing all fields in the document or `undefined`\r\n     * if the document doesn't exist.\r\n     */ data() {\n        if (!this._document) {\n            return undefined;\n        } else if (this._converter) {\n            // We only want to use the converter and create a new DocumentSnapshot\n            // if a converter has been provided.\n            const snapshot = new QueryDocumentSnapshot(this._firestore, this._userDataWriter, this._key, this._document, /* converter= */ null);\n            return this._converter.fromFirestore(snapshot);\n        } else {\n            return this._userDataWriter.convertValue(this._document.data.value);\n        }\n    }\n    /**\r\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\r\n     * document or field doesn't exist.\r\n     *\r\n     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\r\n     * field.\r\n     * @returns The data at the specified field location or undefined if no such\r\n     * field exists in the document.\r\n     */ // We are using `any` here to avoid an explicit cast by our users.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(fieldPath) {\n        if (this._document) {\n            const value = this._document.data.field(fieldPathFromArgument(\"DocumentSnapshot.get\", fieldPath));\n            if (value !== null) {\n                return this._userDataWriter.convertValue(value);\n            }\n        }\n        return undefined;\n    }\n}\n/**\r\n * A `QueryDocumentSnapshot` contains data read from a document in your\r\n * Firestore database as part of a query. The document is guaranteed to exist\r\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\r\n * specific field.\r\n *\r\n * A `QueryDocumentSnapshot` offers the same API surface as a\r\n * `DocumentSnapshot`. Since query results contain only existing documents, the\r\n * `exists` property will always be true and `data()` will never return\r\n * 'undefined'.\r\n */ class QueryDocumentSnapshot extends DocumentSnapshot {\n    /**\r\n     * Retrieves all fields in the document as an `Object`.\r\n     *\r\n     * @override\r\n     * @returns An `Object` containing all fields in the document.\r\n     */ data() {\n        return super.data();\n    }\n}\n/**\r\n * A `QuerySnapshot` contains zero or more `DocumentSnapshot` objects\r\n * representing the results of a query. The documents can be accessed as an\r\n * array via the `docs` property or enumerated using the `forEach` method. The\r\n * number of documents can be determined via the `empty` and `size`\r\n * properties.\r\n */ class QuerySnapshot {\n    /** @hideconstructor */ constructor(_query, _docs){\n        this._docs = _docs;\n        this.query = _query;\n    }\n    /** An array of all the documents in the `QuerySnapshot`. */ get docs() {\n        return [\n            ...this._docs\n        ];\n    }\n    /** The number of documents in the `QuerySnapshot`. */ get size() {\n        return this.docs.length;\n    }\n    /** True if there are no documents in the `QuerySnapshot`. */ get empty() {\n        return this.docs.length === 0;\n    }\n    /**\r\n     * Enumerates all of the documents in the `QuerySnapshot`.\r\n     *\r\n     * @param callback - A callback to be called with a `QueryDocumentSnapshot` for\r\n     * each document in the snapshot.\r\n     * @param thisArg - The `this` binding for the callback.\r\n     */ forEach(callback, thisArg) {\n        this._docs.forEach(callback, thisArg);\n    }\n}\n/**\r\n * Returns true if the provided snapshots are equal.\r\n *\r\n * @param left - A snapshot to compare.\r\n * @param right - A snapshot to compare.\r\n * @returns true if the snapshots are equal.\r\n */ function snapshotEqual(left, right) {\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(left);\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(right);\n    if (left instanceof DocumentSnapshot && right instanceof DocumentSnapshot) {\n        return left._firestore === right._firestore && left._key.isEqual(right._key) && (left._document === null ? right._document === null : left._document.isEqual(right._document)) && left._converter === right._converter;\n    } else if (left instanceof QuerySnapshot && right instanceof QuerySnapshot) {\n        return queryEqual(left.query, right.query) && arrayEquals(left.docs, right.docs, snapshotEqual);\n    }\n    return false;\n}\n/**\r\n * Helper that calls `fromDotSeparatedString()` but wraps any error thrown.\r\n */ function fieldPathFromArgument(methodName, arg) {\n    if (typeof arg === \"string\") {\n        return fieldPathFromDotSeparatedString(methodName, arg);\n    } else if (arg instanceof FieldPath) {\n        return arg._internalPath;\n    } else {\n        return arg._delegate._internalPath;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function validateHasExplicitOrderByForLimitToLast(query) {\n    if (query.limitType === \"L\" /* LimitType.Last */  && query.explicitOrderBy.length === 0) {\n        throw new FirestoreError(Code.UNIMPLEMENTED, \"limitToLast() queries require specifying at least one orderBy() clause\");\n    }\n}\n/**\r\n * An `AppliableConstraint` is an abstraction of a constraint that can be applied\r\n * to a Firestore query.\r\n */ class AppliableConstraint {\n}\n/**\r\n * A `QueryConstraint` is used to narrow the set of documents returned by a\r\n * Firestore query. `QueryConstraint`s are created by invoking {@link where},\r\n * {@link orderBy}, {@link (startAt:1)}, {@link (startAfter:1)}, {@link\r\n * (endBefore:1)}, {@link (endAt:1)}, {@link limit}, {@link limitToLast} and\r\n * can then be passed to {@link (query:1)} to create a new query instance that\r\n * also contains this `QueryConstraint`.\r\n */ class QueryConstraint extends AppliableConstraint {\n}\nfunction query(query1, queryConstraint, ...additionalQueryConstraints) {\n    let queryConstraints = [];\n    if (queryConstraint instanceof AppliableConstraint) {\n        queryConstraints.push(queryConstraint);\n    }\n    queryConstraints = queryConstraints.concat(additionalQueryConstraints);\n    validateQueryConstraintArray(queryConstraints);\n    for (const constraint of queryConstraints){\n        query1 = constraint._apply(query1);\n    }\n    return query1;\n}\n/**\r\n * A `QueryFieldFilterConstraint` is used to narrow the set of documents returned by\r\n * a Firestore query by filtering on one or more document fields.\r\n * `QueryFieldFilterConstraint`s are created by invoking {@link where} and can then\r\n * be passed to {@link (query:1)} to create a new query instance that also contains\r\n * this `QueryFieldFilterConstraint`.\r\n */ class QueryFieldFilterConstraint extends QueryConstraint {\n    /**\r\n     * @internal\r\n     */ constructor(_field, _op, _value){\n        super();\n        this._field = _field;\n        this._op = _op;\n        this._value = _value;\n        /** The type of this query constraint */ this.type = \"where\";\n    }\n    static _create(_field, _op, _value) {\n        return new QueryFieldFilterConstraint(_field, _op, _value);\n    }\n    _apply(query) {\n        const filter = this._parse(query);\n        validateNewFieldFilter(query._query, filter);\n        return new Query(query.firestore, query.converter, queryWithAddedFilter(query._query, filter));\n    }\n    _parse(query) {\n        const reader = newUserDataReader(query.firestore);\n        const filter = newQueryFilter(query._query, \"where\", reader, query.firestore._databaseId, this._field, this._op, this._value);\n        return filter;\n    }\n}\n/**\r\n * Creates a {@link QueryFieldFilterConstraint} that enforces that documents\r\n * must contain the specified field and that the value should satisfy the\r\n * relation constraint provided.\r\n *\r\n * @param fieldPath - The path to compare\r\n * @param opStr - The operation string (e.g \"&lt;\", \"&lt;=\", \"==\", \"&lt;\",\r\n *   \"&lt;=\", \"!=\").\r\n * @param value - The value for comparison\r\n * @returns The created {@link QueryFieldFilterConstraint}.\r\n */ function where(fieldPath, opStr, value) {\n    const op = opStr;\n    const field = fieldPathFromArgument(\"where\", fieldPath);\n    return QueryFieldFilterConstraint._create(field, op, value);\n}\n/**\r\n * A `QueryCompositeFilterConstraint` is used to narrow the set of documents\r\n * returned by a Firestore query by performing the logical OR or AND of multiple\r\n * {@link QueryFieldFilterConstraint}s or {@link QueryCompositeFilterConstraint}s.\r\n * `QueryCompositeFilterConstraint`s are created by invoking {@link or} or\r\n * {@link and} and can then be passed to {@link (query:1)} to create a new query\r\n * instance that also contains the `QueryCompositeFilterConstraint`.\r\n */ class QueryCompositeFilterConstraint extends AppliableConstraint {\n    /**\r\n     * @internal\r\n     */ constructor(/** The type of this query constraint */ type, _queryConstraints){\n        super();\n        this.type = type;\n        this._queryConstraints = _queryConstraints;\n    }\n    static _create(type, _queryConstraints) {\n        return new QueryCompositeFilterConstraint(type, _queryConstraints);\n    }\n    _parse(query) {\n        const parsedFilters = this._queryConstraints.map((queryConstraint)=>{\n            return queryConstraint._parse(query);\n        }).filter((parsedFilter)=>parsedFilter.getFilters().length > 0);\n        if (parsedFilters.length === 1) {\n            return parsedFilters[0];\n        }\n        return CompositeFilter.create(parsedFilters, this._getOperator());\n    }\n    _apply(query) {\n        const parsedFilter = this._parse(query);\n        if (parsedFilter.getFilters().length === 0) {\n            // Return the existing query if not adding any more filters (e.g. an empty\n            // composite filter).\n            return query;\n        }\n        validateNewFilter(query._query, parsedFilter);\n        return new Query(query.firestore, query.converter, queryWithAddedFilter(query._query, parsedFilter));\n    }\n    _getQueryConstraints() {\n        return this._queryConstraints;\n    }\n    _getOperator() {\n        return this.type === \"and\" ? \"and\" /* CompositeOperator.AND */  : \"or\" /* CompositeOperator.OR */ ;\n    }\n}\n/**\r\n * Creates a new {@link QueryCompositeFilterConstraint} that is a disjunction of\r\n * the given filter constraints. A disjunction filter includes a document if it\r\n * satisfies any of the given filters.\r\n *\r\n * @param queryConstraints - Optional. The list of\r\n * {@link QueryFilterConstraint}s to perform a disjunction for. These must be\r\n * created with calls to {@link where}, {@link or}, or {@link and}.\r\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\r\n */ function or(...queryConstraints) {\n    // Only support QueryFilterConstraints\n    queryConstraints.forEach((queryConstraint)=>validateQueryFilterConstraint(\"or\", queryConstraint));\n    return QueryCompositeFilterConstraint._create(\"or\" /* CompositeOperator.OR */ , queryConstraints);\n}\n/**\r\n * Creates a new {@link QueryCompositeFilterConstraint} that is a conjunction of\r\n * the given filter constraints. A conjunction filter includes a document if it\r\n * satisfies all of the given filters.\r\n *\r\n * @param queryConstraints - Optional. The list of\r\n * {@link QueryFilterConstraint}s to perform a conjunction for. These must be\r\n * created with calls to {@link where}, {@link or}, or {@link and}.\r\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\r\n */ function and(...queryConstraints) {\n    // Only support QueryFilterConstraints\n    queryConstraints.forEach((queryConstraint)=>validateQueryFilterConstraint(\"and\", queryConstraint));\n    return QueryCompositeFilterConstraint._create(\"and\" /* CompositeOperator.AND */ , queryConstraints);\n}\n/**\r\n * A `QueryOrderByConstraint` is used to sort the set of documents returned by a\r\n * Firestore query. `QueryOrderByConstraint`s are created by invoking\r\n * {@link orderBy} and can then be passed to {@link (query:1)} to create a new query\r\n * instance that also contains this `QueryOrderByConstraint`.\r\n *\r\n * Note: Documents that do not contain the orderBy field will not be present in\r\n * the query result.\r\n */ class QueryOrderByConstraint extends QueryConstraint {\n    /**\r\n     * @internal\r\n     */ constructor(_field, _direction){\n        super();\n        this._field = _field;\n        this._direction = _direction;\n        /** The type of this query constraint */ this.type = \"orderBy\";\n    }\n    static _create(_field, _direction) {\n        return new QueryOrderByConstraint(_field, _direction);\n    }\n    _apply(query) {\n        const orderBy = newQueryOrderBy(query._query, this._field, this._direction);\n        return new Query(query.firestore, query.converter, queryWithAddedOrderBy(query._query, orderBy));\n    }\n}\n/**\r\n * Creates a {@link QueryOrderByConstraint} that sorts the query result by the\r\n * specified field, optionally in descending order instead of ascending.\r\n *\r\n * Note: Documents that do not contain the specified field will not be present\r\n * in the query result.\r\n *\r\n * @param fieldPath - The field to sort by.\r\n * @param directionStr - Optional direction to sort by ('asc' or 'desc'). If\r\n * not specified, order will be ascending.\r\n * @returns The created {@link QueryOrderByConstraint}.\r\n */ function orderBy(fieldPath, directionStr = \"asc\") {\n    const direction = directionStr;\n    const path = fieldPathFromArgument(\"orderBy\", fieldPath);\n    return QueryOrderByConstraint._create(path, direction);\n}\n/**\r\n * A `QueryLimitConstraint` is used to limit the number of documents returned by\r\n * a Firestore query.\r\n * `QueryLimitConstraint`s are created by invoking {@link limit} or\r\n * {@link limitToLast} and can then be passed to {@link (query:1)} to create a new\r\n * query instance that also contains this `QueryLimitConstraint`.\r\n */ class QueryLimitConstraint extends QueryConstraint {\n    /**\r\n     * @internal\r\n     */ constructor(/** The type of this query constraint */ type, _limit, _limitType){\n        super();\n        this.type = type;\n        this._limit = _limit;\n        this._limitType = _limitType;\n    }\n    static _create(type, _limit, _limitType) {\n        return new QueryLimitConstraint(type, _limit, _limitType);\n    }\n    _apply(query) {\n        return new Query(query.firestore, query.converter, queryWithLimit(query._query, this._limit, this._limitType));\n    }\n}\n/**\r\n * Creates a {@link QueryLimitConstraint} that only returns the first matching\r\n * documents.\r\n *\r\n * @param limit - The maximum number of items to return.\r\n * @returns The created {@link QueryLimitConstraint}.\r\n */ function limit(limit) {\n    validatePositiveNumber(\"limit\", limit);\n    return QueryLimitConstraint._create(\"limit\", limit, \"F\" /* LimitType.First */ );\n}\n/**\r\n * Creates a {@link QueryLimitConstraint} that only returns the last matching\r\n * documents.\r\n *\r\n * You must specify at least one `orderBy` clause for `limitToLast` queries,\r\n * otherwise an exception will be thrown during execution.\r\n *\r\n * @param limit - The maximum number of items to return.\r\n * @returns The created {@link QueryLimitConstraint}.\r\n */ function limitToLast(limit) {\n    validatePositiveNumber(\"limitToLast\", limit);\n    return QueryLimitConstraint._create(\"limitToLast\", limit, \"L\" /* LimitType.Last */ );\n}\n/**\r\n * A `QueryStartAtConstraint` is used to exclude documents from the start of a\r\n * result set returned by a Firestore query.\r\n * `QueryStartAtConstraint`s are created by invoking {@link (startAt:1)} or\r\n * {@link (startAfter:1)} and can then be passed to {@link (query:1)} to create a\r\n * new query instance that also contains this `QueryStartAtConstraint`.\r\n */ class QueryStartAtConstraint extends QueryConstraint {\n    /**\r\n     * @internal\r\n     */ constructor(/** The type of this query constraint */ type, _docOrFields, _inclusive){\n        super();\n        this.type = type;\n        this._docOrFields = _docOrFields;\n        this._inclusive = _inclusive;\n    }\n    static _create(type, _docOrFields, _inclusive) {\n        return new QueryStartAtConstraint(type, _docOrFields, _inclusive);\n    }\n    _apply(query) {\n        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);\n        return new Query(query.firestore, query.converter, queryWithStartAt(query._query, bound));\n    }\n}\nfunction startAt(...docOrFields) {\n    return QueryStartAtConstraint._create(\"startAt\", docOrFields, /*inclusive=*/ true);\n}\nfunction startAfter(...docOrFields) {\n    return QueryStartAtConstraint._create(\"startAfter\", docOrFields, /*inclusive=*/ false);\n}\n/**\r\n * A `QueryEndAtConstraint` is used to exclude documents from the end of a\r\n * result set returned by a Firestore query.\r\n * `QueryEndAtConstraint`s are created by invoking {@link (endAt:1)} or\r\n * {@link (endBefore:1)} and can then be passed to {@link (query:1)} to create a new\r\n * query instance that also contains this `QueryEndAtConstraint`.\r\n */ class QueryEndAtConstraint extends QueryConstraint {\n    /**\r\n     * @internal\r\n     */ constructor(/** The type of this query constraint */ type, _docOrFields, _inclusive){\n        super();\n        this.type = type;\n        this._docOrFields = _docOrFields;\n        this._inclusive = _inclusive;\n    }\n    static _create(type, _docOrFields, _inclusive) {\n        return new QueryEndAtConstraint(type, _docOrFields, _inclusive);\n    }\n    _apply(query) {\n        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);\n        return new Query(query.firestore, query.converter, queryWithEndAt(query._query, bound));\n    }\n}\nfunction endBefore(...docOrFields) {\n    return QueryEndAtConstraint._create(\"endBefore\", docOrFields, /*inclusive=*/ false);\n}\nfunction endAt(...docOrFields) {\n    return QueryEndAtConstraint._create(\"endAt\", docOrFields, /*inclusive=*/ true);\n}\n/** Helper function to create a bound from a document or fields */ function newQueryBoundFromDocOrFields(query, methodName, docOrFields, inclusive) {\n    docOrFields[0] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(docOrFields[0]);\n    if (docOrFields[0] instanceof DocumentSnapshot) {\n        return newQueryBoundFromDocument(query._query, query.firestore._databaseId, methodName, docOrFields[0]._document, inclusive);\n    } else {\n        const reader = newUserDataReader(query.firestore);\n        return newQueryBoundFromFields(query._query, query.firestore._databaseId, reader, methodName, docOrFields, inclusive);\n    }\n}\nfunction newQueryFilter(query, methodName, dataReader, databaseId, fieldPath, op, value) {\n    let fieldValue;\n    if (fieldPath.isKeyField()) {\n        if (op === \"array-contains\" /* Operator.ARRAY_CONTAINS */  || op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */ ) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid Query. You can't perform '${op}' queries on documentId().`);\n        } else if (op === \"in\" /* Operator.IN */  || op === \"not-in\" /* Operator.NOT_IN */ ) {\n            validateDisjunctiveFilterElements(value, op);\n            const referenceList = [];\n            for (const arrayValue of value){\n                referenceList.push(parseDocumentIdValue(databaseId, query, arrayValue));\n            }\n            fieldValue = {\n                arrayValue: {\n                    values: referenceList\n                }\n            };\n        } else {\n            fieldValue = parseDocumentIdValue(databaseId, query, value);\n        }\n    } else {\n        if (op === \"in\" /* Operator.IN */  || op === \"not-in\" /* Operator.NOT_IN */  || op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */ ) {\n            validateDisjunctiveFilterElements(value, op);\n        }\n        fieldValue = parseQueryValue(dataReader, methodName, value, /* allowArrays= */ op === \"in\" /* Operator.IN */  || op === \"not-in\" /* Operator.NOT_IN */ );\n    }\n    const filter = FieldFilter.create(fieldPath, op, fieldValue);\n    return filter;\n}\nfunction newQueryOrderBy(query, fieldPath, direction) {\n    if (query.startAt !== null) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. You must not call startAt() or startAfter() before \" + \"calling orderBy().\");\n    }\n    if (query.endAt !== null) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. You must not call endAt() or endBefore() before \" + \"calling orderBy().\");\n    }\n    const orderBy = new OrderBy(fieldPath, direction);\n    return orderBy;\n}\n/**\r\n * Create a `Bound` from a query and a document.\r\n *\r\n * Note that the `Bound` will always include the key of the document\r\n * and so only the provided document will compare equal to the returned\r\n * position.\r\n *\r\n * Will throw if the document does not contain all fields of the order by\r\n * of the query or if any of the fields in the order by are an uncommitted\r\n * server timestamp.\r\n */ function newQueryBoundFromDocument(query, databaseId, methodName, doc, inclusive) {\n    if (!doc) {\n        throw new FirestoreError(Code.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ` + `${methodName}().`);\n    }\n    const components = [];\n    // Because people expect to continue/end a query at the exact document\n    // provided, we need to use the implicit sort order rather than the explicit\n    // sort order, because it's guaranteed to contain the document key. That way\n    // the position becomes unambiguous and the query continues/ends exactly at\n    // the provided document. Without the key (by using the explicit sort\n    // orders), multiple documents could match the position, yielding duplicate\n    // results.\n    for (const orderBy of queryNormalizedOrderBy(query)){\n        if (orderBy.field.isKeyField()) {\n            components.push(refValue(databaseId, doc.key));\n        } else {\n            const value = doc.data.field(orderBy.field);\n            if (isServerTimestamp(value)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. You are trying to start or end a query using a \" + 'document for which the field \"' + orderBy.field + '\" is an uncommitted server timestamp. (Since the value of ' + \"this field is unknown, you cannot start/end a query with it.)\");\n            } else if (value !== null) {\n                components.push(value);\n            } else {\n                const field = orderBy.field.canonicalString();\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a ` + `document for which the field '${field}' (used as the ` + `orderBy) does not exist.`);\n            }\n        }\n    }\n    return new Bound(components, inclusive);\n}\n/**\r\n * Converts a list of field values to a `Bound` for the given query.\r\n */ function newQueryBoundFromFields(query, databaseId, dataReader, methodName, values, inclusive) {\n    // Use explicit order by's because it has to match the query the user made\n    const orderBy = query.explicitOrderBy;\n    if (values.length > orderBy.length) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Too many arguments provided to ${methodName}(). ` + `The number of arguments must be less than or equal to the ` + `number of orderBy() clauses`);\n    }\n    const components = [];\n    for(let i = 0; i < values.length; i++){\n        const rawValue = values[i];\n        const orderByComponent = orderBy[i];\n        if (orderByComponent.field.isKeyField()) {\n            if (typeof rawValue !== \"string\") {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ` + `${methodName}(), but got a ${typeof rawValue}`);\n            }\n            if (!isCollectionGroupQuery(query) && rawValue.indexOf(\"/\") !== -1) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), ` + `the value passed to ${methodName}() must be a plain document ID, but ` + `'${rawValue}' contains a slash.`);\n            }\n            const path = query.path.child(ResourcePath.fromString(rawValue));\n            if (!DocumentKey.isDocumentKey(path)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by ` + `documentId(), the value passed to ${methodName}() must result in a ` + `valid document path, but '${path}' is not because it contains an odd number ` + `of segments.`);\n            }\n            const key = new DocumentKey(path);\n            components.push(refValue(databaseId, key));\n        } else {\n            const wrapped = parseQueryValue(dataReader, methodName, rawValue);\n            components.push(wrapped);\n        }\n    }\n    return new Bound(components, inclusive);\n}\n/**\r\n * Parses the given `documentIdValue` into a `ReferenceValue`, throwing\r\n * appropriate errors if the value is anything other than a `DocumentReference`\r\n * or `string`, or if the string is malformed.\r\n */ function parseDocumentIdValue(databaseId, query, documentIdValue) {\n    documentIdValue = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(documentIdValue);\n    if (typeof documentIdValue === \"string\") {\n        if (documentIdValue === \"\") {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. When querying with documentId(), you \" + \"must provide a valid document ID, but it was an empty string.\");\n        }\n        if (!isCollectionGroupQuery(query) && documentIdValue.indexOf(\"/\") !== -1) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection by ` + `documentId(), you must provide a plain document ID, but ` + `'${documentIdValue}' contains a '/' character.`);\n        }\n        const path = query.path.child(ResourcePath.fromString(documentIdValue));\n        if (!DocumentKey.isDocumentKey(path)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group by ` + `documentId(), the value provided must result in a valid document path, ` + `but '${path}' is not because it has an odd number of segments (${path.length}).`);\n        }\n        return refValue(databaseId, new DocumentKey(path));\n    } else if (documentIdValue instanceof DocumentReference) {\n        return refValue(databaseId, documentIdValue._key);\n    } else {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid ` + `string or a DocumentReference, but it was: ` + `${valueDescription(documentIdValue)}.`);\n    }\n}\n/**\r\n * Validates that the value passed into a disjunctive filter satisfies all\r\n * array requirements.\r\n */ function validateDisjunctiveFilterElements(value, operator) {\n    if (!Array.isArray(value) || value.length === 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid Query. A non-empty array is required for \" + `'${operator.toString()}' filters.`);\n    }\n}\n/**\r\n * Given an operator, returns the set of operators that cannot be used with it.\r\n *\r\n * This is not a comprehensive check, and this function should be removed in the\r\n * long term. Validations should occur in the Firestore backend.\r\n *\r\n * Operators in a query must adhere to the following set of rules:\r\n * 1. Only one inequality per query.\r\n * 2. `NOT_IN` cannot be used with array, disjunctive, or `NOT_EQUAL` operators.\r\n */ function conflictingOps(op) {\n    switch(op){\n        case \"!=\" /* Operator.NOT_EQUAL */ :\n            return [\n                \"!=\" /* Operator.NOT_EQUAL */ ,\n                \"not-in\" /* Operator.NOT_IN */ \n            ];\n        case \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */ :\n        case \"in\" /* Operator.IN */ :\n            return [\n                \"not-in\" /* Operator.NOT_IN */ \n            ];\n        case \"not-in\" /* Operator.NOT_IN */ :\n            return [\n                \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */ ,\n                \"in\" /* Operator.IN */ ,\n                \"not-in\" /* Operator.NOT_IN */ ,\n                \"!=\" /* Operator.NOT_EQUAL */ \n            ];\n        default:\n            return [];\n    }\n}\nfunction validateNewFieldFilter(query, fieldFilter) {\n    const conflictingOp = findOpInsideFilters(query.filters, conflictingOps(fieldFilter.op));\n    if (conflictingOp !== null) {\n        // Special case when it's a duplicate op to give a slightly clearer error message.\n        if (conflictingOp === fieldFilter.op) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. You cannot use more than one \" + `'${fieldFilter.op.toString()}' filter.`);\n        } else {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You cannot use '${fieldFilter.op.toString()}' filters ` + `with '${conflictingOp.toString()}' filters.`);\n        }\n    }\n}\nfunction validateNewFilter(query, filter) {\n    let testQuery = query;\n    const subFilters = filter.getFlattenedFilters();\n    for (const subFilter of subFilters){\n        validateNewFieldFilter(testQuery, subFilter);\n        testQuery = queryWithAddedFilter(testQuery, subFilter);\n    }\n}\n// Checks if any of the provided filter operators are included in the given list of filters and\n// returns the first one that is, or null if none are.\nfunction findOpInsideFilters(filters, operators) {\n    for (const filter of filters){\n        for (const fieldFilter of filter.getFlattenedFilters()){\n            if (operators.indexOf(fieldFilter.op) >= 0) {\n                return fieldFilter.op;\n            }\n        }\n    }\n    return null;\n}\nfunction validateQueryFilterConstraint(functionName, queryConstraint) {\n    if (!(queryConstraint instanceof QueryFieldFilterConstraint) && !(queryConstraint instanceof QueryCompositeFilterConstraint)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`);\n    }\n}\nfunction validateQueryConstraintArray(queryConstraint) {\n    const compositeFilterCount = queryConstraint.filter((filter)=>filter instanceof QueryCompositeFilterConstraint).length;\n    const fieldFilterCount = queryConstraint.filter((filter)=>filter instanceof QueryFieldFilterConstraint).length;\n    if (compositeFilterCount > 1 || compositeFilterCount > 0 && fieldFilterCount > 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"InvalidQuery. When using composite filters, you cannot use \" + \"more than one filter at the top level. Consider nesting the multiple \" + \"filters within an `and(...)` statement. For example: \" + \"change `query(query, where(...), or(...))` to \" + \"`query(query, and(where(...), or(...)))`.\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Converts Firestore's internal types to the JavaScript types that we expose\r\n * to the user.\r\n *\r\n * @internal\r\n */ class AbstractUserDataWriter {\n    convertValue(value, serverTimestampBehavior = \"none\") {\n        switch(typeOrder(value)){\n            case 0 /* TypeOrder.NullValue */ :\n                return null;\n            case 1 /* TypeOrder.BooleanValue */ :\n                return value.booleanValue;\n            case 2 /* TypeOrder.NumberValue */ :\n                return normalizeNumber(value.integerValue || value.doubleValue);\n            case 3 /* TypeOrder.TimestampValue */ :\n                return this.convertTimestamp(value.timestampValue);\n            case 4 /* TypeOrder.ServerTimestampValue */ :\n                return this.convertServerTimestamp(value, serverTimestampBehavior);\n            case 5 /* TypeOrder.StringValue */ :\n                return value.stringValue;\n            case 6 /* TypeOrder.BlobValue */ :\n                return this.convertBytes(normalizeByteString(value.bytesValue));\n            case 7 /* TypeOrder.RefValue */ :\n                return this.convertReference(value.referenceValue);\n            case 8 /* TypeOrder.GeoPointValue */ :\n                return this.convertGeoPoint(value.geoPointValue);\n            case 9 /* TypeOrder.ArrayValue */ :\n                return this.convertArray(value.arrayValue, serverTimestampBehavior);\n            case 10 /* TypeOrder.ObjectValue */ :\n                return this.convertObject(value.mapValue, serverTimestampBehavior);\n            default:\n                throw fail();\n        }\n    }\n    convertObject(mapValue, serverTimestampBehavior) {\n        return this.convertObjectMap(mapValue.fields, serverTimestampBehavior);\n    }\n    /**\r\n     * @internal\r\n     */ convertObjectMap(fields, serverTimestampBehavior = \"none\") {\n        const result = {};\n        forEach(fields, (key, value)=>{\n            result[key] = this.convertValue(value, serverTimestampBehavior);\n        });\n        return result;\n    }\n    convertGeoPoint(value) {\n        return new GeoPoint(normalizeNumber(value.latitude), normalizeNumber(value.longitude));\n    }\n    convertArray(arrayValue, serverTimestampBehavior) {\n        return (arrayValue.values || []).map((value)=>this.convertValue(value, serverTimestampBehavior));\n    }\n    convertServerTimestamp(value, serverTimestampBehavior) {\n        switch(serverTimestampBehavior){\n            case \"previous\":\n                const previousValue = getPreviousValue(value);\n                if (previousValue == null) {\n                    return null;\n                }\n                return this.convertValue(previousValue, serverTimestampBehavior);\n            case \"estimate\":\n                return this.convertTimestamp(getLocalWriteTime(value));\n            default:\n                return null;\n        }\n    }\n    convertTimestamp(value) {\n        const normalizedValue = normalizeTimestamp(value);\n        return new Timestamp(normalizedValue.seconds, normalizedValue.nanos);\n    }\n    convertDocumentKey(name, expectedDatabaseId) {\n        const resourcePath = ResourcePath.fromString(name);\n        hardAssert(isValidResourceName(resourcePath));\n        const databaseId = new DatabaseId(resourcePath.get(1), resourcePath.get(3));\n        const key = new DocumentKey(resourcePath.popFirst(5));\n        if (!databaseId.isEqual(expectedDatabaseId)) {\n            // TODO(b/64130202): Somehow support foreign references.\n            logError(`Document ${key} contains a document ` + `reference within a different database (` + `${databaseId.projectId}/${databaseId.database}) which is not ` + `supported. It will be treated as a reference in the current ` + `database (${expectedDatabaseId.projectId}/${expectedDatabaseId.database}) ` + `instead.`);\n        }\n        return key;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Converts custom model object of type T into `DocumentData` by applying the\r\n * converter if it exists.\r\n *\r\n * This function is used when converting user objects to `DocumentData`\r\n * because we want to provide the user with a more specific error message if\r\n * their `set()` or fails due to invalid data originating from a `toFirestore()`\r\n * call.\r\n */ function applyFirestoreDataConverter(converter, value, options) {\n    let convertedValue;\n    if (converter) {\n        if (options && (options.merge || options.mergeFields)) {\n            // Cast to `any` in order to satisfy the union type constraint on\n            // toFirestore().\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            convertedValue = converter.toFirestore(value, options);\n        } else {\n            convertedValue = converter.toFirestore(value);\n        }\n    } else {\n        convertedValue = value;\n    }\n    return convertedValue;\n}\nclass LiteUserDataWriter extends AbstractUserDataWriter {\n    constructor(firestore){\n        super();\n        this.firestore = firestore;\n    }\n    convertBytes(bytes) {\n        return new Bytes(bytes);\n    }\n    convertReference(name) {\n        const key = this.convertDocumentKey(name, this.firestore._databaseId);\n        return new DocumentReference(this.firestore, /* converter= */ null, key);\n    }\n}\n/**\r\n * Reads the document referred to by the specified document reference.\r\n *\r\n * All documents are directly fetched from the server, even if the document was\r\n * previously read or modified. Recent modifications are only reflected in the\r\n * retrieved `DocumentSnapshot` if they have already been applied by the\r\n * backend. If the client is offline, the read fails. If you like to use\r\n * caching or see local modifications, please use the full Firestore SDK.\r\n *\r\n * @param reference - The reference of the document to fetch.\r\n * @returns A Promise resolved with a `DocumentSnapshot` containing the current\r\n * document contents.\r\n */ function getDoc(reference) {\n    reference = cast(reference, DocumentReference);\n    const datastore = getDatastore(reference.firestore);\n    const userDataWriter = new LiteUserDataWriter(reference.firestore);\n    return invokeBatchGetDocumentsRpc(datastore, [\n        reference._key\n    ]).then((result)=>{\n        hardAssert(result.length === 1);\n        const document = result[0];\n        return new DocumentSnapshot(reference.firestore, userDataWriter, reference._key, document.isFoundDocument() ? document : null, reference.converter);\n    });\n}\n/**\r\n * Executes the query and returns the results as a {@link QuerySnapshot}.\r\n *\r\n * All queries are executed directly by the server, even if the the query was\r\n * previously executed. Recent modifications are only reflected in the retrieved\r\n * results if they have already been applied by the backend. If the client is\r\n * offline, the operation fails. To see previously cached result and local\r\n * modifications, use the full Firestore SDK.\r\n *\r\n * @param query - The `Query` to execute.\r\n * @returns A Promise that will be resolved with the results of the query.\r\n */ function getDocs(query) {\n    query = cast(query, Query);\n    validateHasExplicitOrderByForLimitToLast(query._query);\n    const datastore = getDatastore(query.firestore);\n    const userDataWriter = new LiteUserDataWriter(query.firestore);\n    return invokeRunQueryRpc(datastore, query._query).then((result)=>{\n        const docs = result.map((doc)=>new QueryDocumentSnapshot(query.firestore, userDataWriter, doc.key, doc, query.converter));\n        if (query._query.limitType === \"L\" /* LimitType.Last */ ) {\n            // Limit to last queries reverse the orderBy constraint that was\n            // specified by the user. As such, we need to reverse the order of the\n            // results to return the documents in the expected order.\n            docs.reverse();\n        }\n        return new QuerySnapshot(query, docs);\n    });\n}\nfunction setDoc(reference, data, options) {\n    reference = cast(reference, DocumentReference);\n    const convertedValue = applyFirestoreDataConverter(reference.converter, data, options);\n    const dataReader = newUserDataReader(reference.firestore);\n    const parsed = parseSetData(dataReader, \"setDoc\", reference._key, convertedValue, reference.converter !== null, options);\n    const datastore = getDatastore(reference.firestore);\n    return invokeCommitRpc(datastore, [\n        parsed.toMutation(reference._key, Precondition.none())\n    ]);\n}\nfunction updateDoc(reference, fieldOrUpdateData, value, ...moreFieldsAndValues) {\n    reference = cast(reference, DocumentReference);\n    const dataReader = newUserDataReader(reference.firestore);\n    // For Compat types, we have to \"extract\" the underlying types before\n    // performing validation.\n    fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\n    let parsed;\n    if (typeof fieldOrUpdateData === \"string\" || fieldOrUpdateData instanceof FieldPath) {\n        parsed = parseUpdateVarargs(dataReader, \"updateDoc\", reference._key, fieldOrUpdateData, value, moreFieldsAndValues);\n    } else {\n        parsed = parseUpdateData(dataReader, \"updateDoc\", reference._key, fieldOrUpdateData);\n    }\n    const datastore = getDatastore(reference.firestore);\n    return invokeCommitRpc(datastore, [\n        parsed.toMutation(reference._key, Precondition.exists(true))\n    ]);\n}\n/**\r\n * Deletes the document referred to by the specified `DocumentReference`.\r\n *\r\n * The deletion will only be reflected in document reads that occur after the\r\n * returned promise resolves. If the client is offline, the\r\n * delete fails. If you would like to see local modifications or buffer writes\r\n * until the client is online, use the full Firestore SDK.\r\n *\r\n * @param reference - A reference to the document to delete.\r\n * @returns A `Promise` resolved once the document has been successfully\r\n * deleted from the backend.\r\n */ function deleteDoc(reference) {\n    reference = cast(reference, DocumentReference);\n    const datastore = getDatastore(reference.firestore);\n    return invokeCommitRpc(datastore, [\n        new DeleteMutation(reference._key, Precondition.none())\n    ]);\n}\n/**\r\n * Add a new document to specified `CollectionReference` with the given data,\r\n * assigning it a document ID automatically.\r\n *\r\n * The result of this write will only be reflected in document reads that occur\r\n * after the returned promise resolves. If the client is offline, the\r\n * write fails. If you would like to see local modifications or buffer writes\r\n * until the client is online, use the full Firestore SDK.\r\n *\r\n * @param reference - A reference to the collection to add this document to.\r\n * @param data - An Object containing the data for the new document.\r\n * @throws Error - If the provided input is not a valid Firestore document.\r\n * @returns A `Promise` resolved with a `DocumentReference` pointing to the\r\n * newly created document after it has been written to the backend.\r\n */ function addDoc(reference, data) {\n    reference = cast(reference, CollectionReference);\n    const docRef = doc(reference);\n    const convertedValue = applyFirestoreDataConverter(reference.converter, data);\n    const dataReader = newUserDataReader(reference.firestore);\n    const parsed = parseSetData(dataReader, \"addDoc\", docRef._key, convertedValue, docRef.converter !== null, {});\n    const datastore = getDatastore(reference.firestore);\n    return invokeCommitRpc(datastore, [\n        parsed.toMutation(docRef._key, Precondition.exists(false))\n    ]).then(()=>docRef);\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Calculates the number of documents in the result set of the given query\r\n * without actually downloading the documents.\r\n *\r\n * Using this function to count the documents is efficient because only the\r\n * final count, not the documents' data, is downloaded. This function can\r\n * count the documents in cases where the result set is prohibitively large to\r\n * download entirely (thousands of documents).\r\n *\r\n * @param query The query whose result set size is calculated.\r\n * @returns A Promise that will be resolved with the count; the count can be\r\n * retrieved from `snapshot.data().count`, where `snapshot` is the\r\n * `AggregateQuerySnapshot` to which the returned Promise resolves.\r\n */ function getCount(query) {\n    const countQuerySpec = {\n        count: count()\n    };\n    return getAggregate(query, countQuerySpec);\n}\n/**\r\n * Calculates the specified aggregations over the documents in the result\r\n * set of the given query without actually downloading the documents.\r\n *\r\n * Using this function to perform aggregations is efficient because only the\r\n * final aggregation values, not the documents' data, are downloaded. This\r\n * function can perform aggregations of the documents in cases where the result\r\n * set is prohibitively large to download entirely (thousands of documents).\r\n *\r\n * @param query The query whose result set is aggregated over.\r\n * @param aggregateSpec An `AggregateSpec` object that specifies the aggregates\r\n * to perform over the result set. The AggregateSpec specifies aliases for each\r\n * aggregate, which can be used to retrieve the aggregate result.\r\n * @example\r\n * ```typescript\r\n * const aggregateSnapshot = await getAggregate(query, {\r\n *   countOfDocs: count(),\r\n *   totalHours: sum('hours'),\r\n *   averageScore: average('score')\r\n * });\r\n *\r\n * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;\r\n * const totalHours: number = aggregateSnapshot.data().totalHours;\r\n * const averageScore: number | null = aggregateSnapshot.data().averageScore;\r\n * ```\r\n */ function getAggregate(query, aggregateSpec) {\n    const firestore = cast(query.firestore, Firestore);\n    const datastore = getDatastore(firestore);\n    const internalAggregates = mapToArray(aggregateSpec, (aggregate, alias)=>{\n        return new AggregateImpl(alias, aggregate.aggregateType, aggregate._internalFieldPath);\n    });\n    // Run the aggregation and convert the results\n    return invokeRunAggregationQueryRpc(datastore, query._query, internalAggregates).then((aggregateResult)=>convertToAggregateQuerySnapshot(firestore, query, aggregateResult));\n}\nfunction convertToAggregateQuerySnapshot(firestore, query, aggregateResult) {\n    const userDataWriter = new LiteUserDataWriter(firestore);\n    const querySnapshot = new AggregateQuerySnapshot(query, userDataWriter, aggregateResult);\n    return querySnapshot;\n}\n/**\r\n * Create an AggregateField object that can be used to compute the sum of\r\n * a specified field over a range of documents in the result set of a query.\r\n * @param field Specifies the field to sum across the result set.\r\n */ function sum(field) {\n    return new AggregateField(\"sum\", fieldPathFromArgument$1(\"sum\", field));\n}\n/**\r\n * Create an AggregateField object that can be used to compute the average of\r\n * a specified field over a range of documents in the result set of a query.\r\n * @param field Specifies the field to average across the result set.\r\n */ function average(field) {\n    return new AggregateField(\"avg\", fieldPathFromArgument$1(\"average\", field));\n}\n/**\r\n * Create an AggregateField object that can be used to compute the count of\r\n * documents in the result set of a query.\r\n */ function count() {\n    return new AggregateField(\"count\");\n}\n/**\r\n * Compares two 'AggregateField` instances for equality.\r\n *\r\n * @param left Compare this AggregateField to the `right`.\r\n * @param right Compare this AggregateField to the `left`.\r\n */ function aggregateFieldEqual(left, right) {\n    var _a, _b;\n    return left instanceof AggregateField && right instanceof AggregateField && left.aggregateType === right.aggregateType && ((_a = left._internalFieldPath) === null || _a === void 0 ? void 0 : _a.canonicalString()) === ((_b = right._internalFieldPath) === null || _b === void 0 ? void 0 : _b.canonicalString());\n}\n/**\r\n * Compares two `AggregateQuerySnapshot` instances for equality.\r\n *\r\n * Two `AggregateQuerySnapshot` instances are considered \"equal\" if they have\r\n * underlying queries that compare equal, and the same data.\r\n *\r\n * @param left - The first `AggregateQuerySnapshot` to compare.\r\n * @param right - The second `AggregateQuerySnapshot` to compare.\r\n *\r\n * @returns `true` if the objects are \"equal\", as defined above, or `false`\r\n * otherwise.\r\n */ function aggregateQuerySnapshotEqual(left, right) {\n    return queryEqual(left.query, right.query) && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(left.data(), right.data());\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns a sentinel for use with {@link @firebase/firestore/lite#(updateDoc:1)} or\r\n * {@link @firebase/firestore/lite#(setDoc:1)} with `{merge: true}` to mark a field for deletion.\r\n */ function deleteField() {\n    return new DeleteFieldValueImpl(\"deleteField\");\n}\n/**\r\n * Returns a sentinel used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link @firebase/firestore/lite#(updateDoc:1)} to\r\n * include a server-generated timestamp in the written data.\r\n */ function serverTimestamp() {\n    return new ServerTimestampFieldValueImpl(\"serverTimestamp\");\n}\n/**\r\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\r\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to union the given elements with any array\r\n * value that already exists on the server. Each specified element that doesn't\r\n * already exist in the array will be added to the end. If the field being\r\n * modified is not already an array it will be overwritten with an array\r\n * containing exactly the specified elements.\r\n *\r\n * @param elements - The elements to union into the array.\r\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\r\n * `updateDoc()`.\r\n */ function arrayUnion(...elements) {\n    // NOTE: We don't actually parse the data until it's used in set() or\n    // update() since we'd need the Firestore instance to do this.\n    return new ArrayUnionFieldValueImpl(\"arrayUnion\", elements);\n}\n/**\r\n * Returns a special value that can be used with {@link (setDoc:1)} or {@link\r\n * updateDoc:1} that tells the server to remove the given elements from any\r\n * array value that already exists on the server. All instances of each element\r\n * specified will be removed from the array. If the field being modified is not\r\n * already an array it will be overwritten with an empty array.\r\n *\r\n * @param elements - The elements to remove from the array.\r\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\r\n * `updateDoc()`\r\n */ function arrayRemove(...elements) {\n    // NOTE: We don't actually parse the data until it's used in set() or\n    // update() since we'd need the Firestore instance to do this.\n    return new ArrayRemoveFieldValueImpl(\"arrayRemove\", elements);\n}\n/**\r\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\r\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to increment the field's current value by\r\n * the given value.\r\n *\r\n * If either the operand or the current field value uses floating point\r\n * precision, all arithmetic follows IEEE 754 semantics. If both values are\r\n * integers, values outside of JavaScript's safe number range\r\n * (`Number.MIN_SAFE_INTEGER` to `Number.MAX_SAFE_INTEGER`) are also subject to\r\n * precision loss. Furthermore, once processed by the Firestore backend, all\r\n * integer operations are capped between -2^63 and 2^63-1.\r\n *\r\n * If the current field value is not of type `number`, or if the field does not\r\n * yet exist, the transformation sets the field to the given value.\r\n *\r\n * @param n - The value to increment by.\r\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\r\n * `updateDoc()`\r\n */ function increment(n) {\n    return new NumericIncrementFieldValueImpl(\"increment\", n);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A write batch, used to perform multiple writes as a single atomic unit.\r\n *\r\n * A `WriteBatch` object can be acquired by calling {@link writeBatch}. It\r\n * provides methods for adding writes to the write batch. None of the writes\r\n * will be committed (or visible locally) until {@link WriteBatch.commit} is\r\n * called.\r\n */ class WriteBatch {\n    /** @hideconstructor */ constructor(_firestore, _commitHandler){\n        this._firestore = _firestore;\n        this._commitHandler = _commitHandler;\n        this._mutations = [];\n        this._committed = false;\n        this._dataReader = newUserDataReader(_firestore);\n    }\n    set(documentRef, data, options) {\n        this._verifyNotCommitted();\n        const ref = validateReference(documentRef, this._firestore);\n        const convertedValue = applyFirestoreDataConverter(ref.converter, data, options);\n        const parsed = parseSetData(this._dataReader, \"WriteBatch.set\", ref._key, convertedValue, ref.converter !== null, options);\n        this._mutations.push(parsed.toMutation(ref._key, Precondition.none()));\n        return this;\n    }\n    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {\n        this._verifyNotCommitted();\n        const ref = validateReference(documentRef, this._firestore);\n        // For Compat types, we have to \"extract\" the underlying types before\n        // performing validation.\n        fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\n        let parsed;\n        if (typeof fieldOrUpdateData === \"string\" || fieldOrUpdateData instanceof FieldPath) {\n            parsed = parseUpdateVarargs(this._dataReader, \"WriteBatch.update\", ref._key, fieldOrUpdateData, value, moreFieldsAndValues);\n        } else {\n            parsed = parseUpdateData(this._dataReader, \"WriteBatch.update\", ref._key, fieldOrUpdateData);\n        }\n        this._mutations.push(parsed.toMutation(ref._key, Precondition.exists(true)));\n        return this;\n    }\n    /**\r\n     * Deletes the document referred to by the provided {@link DocumentReference}.\r\n     *\r\n     * @param documentRef - A reference to the document to be deleted.\r\n     * @returns This `WriteBatch` instance. Used for chaining method calls.\r\n     */ delete(documentRef) {\n        this._verifyNotCommitted();\n        const ref = validateReference(documentRef, this._firestore);\n        this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.none()));\n        return this;\n    }\n    /**\r\n     * Commits all of the writes in this write batch as a single atomic unit.\r\n     *\r\n     * The result of these writes will only be reflected in document reads that\r\n     * occur after the returned promise resolves. If the client is offline, the\r\n     * write fails. If you would like to see local modifications or buffer writes\r\n     * until the client is online, use the full Firestore SDK.\r\n     *\r\n     * @returns A `Promise` resolved once all of the writes in the batch have been\r\n     * successfully written to the backend as an atomic unit (note that it won't\r\n     * resolve while you're offline).\r\n     */ commit() {\n        this._verifyNotCommitted();\n        this._committed = true;\n        if (this._mutations.length > 0) {\n            return this._commitHandler(this._mutations);\n        }\n        return Promise.resolve();\n    }\n    _verifyNotCommitted() {\n        if (this._committed) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, \"A write batch can no longer be used after commit() \" + \"has been called.\");\n        }\n    }\n}\nfunction validateReference(documentRef, firestore) {\n    documentRef = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(documentRef);\n    if (documentRef.firestore !== firestore) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Provided document reference is from a different Firestore instance.\");\n    } else {\n        return documentRef;\n    }\n}\n/**\r\n * Creates a write batch, used for performing multiple writes as a single\r\n * atomic operation. The maximum number of writes allowed in a single WriteBatch\r\n * is 500.\r\n *\r\n * The result of these writes will only be reflected in document reads that\r\n * occur after the returned promise resolves. If the client is offline, the\r\n * write fails. If you would like to see local modifications or buffer writes\r\n * until the client is online, use the full Firestore SDK.\r\n *\r\n * @returns A `WriteBatch` that can be used to atomically execute multiple\r\n * writes.\r\n */ function writeBatch(firestore) {\n    firestore = cast(firestore, Firestore);\n    const datastore = getDatastore(firestore);\n    return new WriteBatch(firestore, (writes)=>invokeCommitRpc(datastore, writes));\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DEFAULT_TRANSACTION_OPTIONS = {\n    maxAttempts: 5\n};\nfunction validateTransactionOptions(options) {\n    if (options.maxAttempts < 1) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Max attempts must be at least 1\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Internal transaction object responsible for accumulating the mutations to\r\n * perform and the base versions for any documents read.\r\n */ class Transaction$1 {\n    constructor(datastore){\n        this.datastore = datastore;\n        // The version of each document that was read during this transaction.\n        this.readVersions = new Map();\n        this.mutations = [];\n        this.committed = false;\n        /**\r\n         * A deferred usage error that occurred previously in this transaction that\r\n         * will cause the transaction to fail once it actually commits.\r\n         */ this.lastTransactionError = null;\n        /**\r\n         * Set of documents that have been written in the transaction.\r\n         *\r\n         * When there's more than one write to the same key in a transaction, any\r\n         * writes after the first are handled differently.\r\n         */ this.writtenDocs = new Set();\n    }\n    async lookup(keys) {\n        this.ensureCommitNotCalled();\n        if (this.mutations.length > 0) {\n            this.lastTransactionError = new FirestoreError(Code.INVALID_ARGUMENT, \"Firestore transactions require all reads to be executed before all writes.\");\n            throw this.lastTransactionError;\n        }\n        const docs = await invokeBatchGetDocumentsRpc(this.datastore, keys);\n        docs.forEach((doc)=>this.recordVersion(doc));\n        return docs;\n    }\n    set(key, data) {\n        this.write(data.toMutation(key, this.precondition(key)));\n        this.writtenDocs.add(key.toString());\n    }\n    update(key, data) {\n        try {\n            this.write(data.toMutation(key, this.preconditionForUpdate(key)));\n        } catch (e) {\n            this.lastTransactionError = e;\n        }\n        this.writtenDocs.add(key.toString());\n    }\n    delete(key) {\n        this.write(new DeleteMutation(key, this.precondition(key)));\n        this.writtenDocs.add(key.toString());\n    }\n    async commit() {\n        this.ensureCommitNotCalled();\n        if (this.lastTransactionError) {\n            throw this.lastTransactionError;\n        }\n        const unwritten = this.readVersions;\n        // For each mutation, note that the doc was written.\n        this.mutations.forEach((mutation)=>{\n            unwritten.delete(mutation.key.toString());\n        });\n        // For each document that was read but not written to, we want to perform\n        // a `verify` operation.\n        unwritten.forEach((_, path)=>{\n            const key = DocumentKey.fromPath(path);\n            this.mutations.push(new VerifyMutation(key, this.precondition(key)));\n        });\n        await invokeCommitRpc(this.datastore, this.mutations);\n        this.committed = true;\n    }\n    recordVersion(doc) {\n        let docVersion;\n        if (doc.isFoundDocument()) {\n            docVersion = doc.version;\n        } else if (doc.isNoDocument()) {\n            // Represent a deleted doc using SnapshotVersion.min().\n            docVersion = SnapshotVersion.min();\n        } else {\n            throw fail();\n        }\n        const existingVersion = this.readVersions.get(doc.key.toString());\n        if (existingVersion) {\n            if (!docVersion.isEqual(existingVersion)) {\n                // This transaction will fail no matter what.\n                throw new FirestoreError(Code.ABORTED, \"Document version changed between two reads.\");\n            }\n        } else {\n            this.readVersions.set(doc.key.toString(), docVersion);\n        }\n    }\n    /**\r\n     * Returns the version of this document when it was read in this transaction,\r\n     * as a precondition, or no precondition if it was not read.\r\n     */ precondition(key) {\n        const version = this.readVersions.get(key.toString());\n        if (!this.writtenDocs.has(key.toString()) && version) {\n            if (version.isEqual(SnapshotVersion.min())) {\n                return Precondition.exists(false);\n            } else {\n                return Precondition.updateTime(version);\n            }\n        } else {\n            return Precondition.none();\n        }\n    }\n    /**\r\n     * Returns the precondition for a document if the operation is an update.\r\n     */ preconditionForUpdate(key) {\n        const version = this.readVersions.get(key.toString());\n        // The first time a document is written, we want to take into account the\n        // read time and existence\n        if (!this.writtenDocs.has(key.toString()) && version) {\n            if (version.isEqual(SnapshotVersion.min())) {\n                // The document doesn't exist, so fail the transaction.\n                // This has to be validated locally because you can't send a\n                // precondition that a document does not exist without changing the\n                // semantics of the backend write to be an insert. This is the reverse\n                // of what we want, since we want to assert that the document doesn't\n                // exist but then send the update and have it fail. Since we can't\n                // express that to the backend, we have to validate locally.\n                // Note: this can change once we can send separate verify writes in the\n                // transaction.\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't update a document that doesn't exist.\");\n            }\n            // Document exists, base precondition on document update time.\n            return Precondition.updateTime(version);\n        } else {\n            // Document was not read, so we just use the preconditions for a blind\n            // update.\n            return Precondition.exists(true);\n        }\n    }\n    write(mutation) {\n        this.ensureCommitNotCalled();\n        this.mutations.push(mutation);\n    }\n    ensureCommitNotCalled() {}\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * TransactionRunner encapsulates the logic needed to run and retry transactions\r\n * with backoff.\r\n */ class TransactionRunner {\n    constructor(asyncQueue, datastore, options, updateFunction, deferred){\n        this.asyncQueue = asyncQueue;\n        this.datastore = datastore;\n        this.options = options;\n        this.updateFunction = updateFunction;\n        this.deferred = deferred;\n        this.attemptsRemaining = options.maxAttempts;\n        this.backoff = new ExponentialBackoff(this.asyncQueue, \"transaction_retry\" /* TimerId.TransactionRetry */ );\n    }\n    /** Runs the transaction and sets the result on deferred. */ run() {\n        this.attemptsRemaining -= 1;\n        this.runWithBackOff();\n    }\n    runWithBackOff() {\n        this.backoff.backoffAndRun(async ()=>{\n            const transaction = new Transaction$1(this.datastore);\n            const userPromise = this.tryRunUpdateFunction(transaction);\n            if (userPromise) {\n                userPromise.then((result)=>{\n                    this.asyncQueue.enqueueAndForget(()=>{\n                        return transaction.commit().then(()=>{\n                            this.deferred.resolve(result);\n                        }).catch((commitError)=>{\n                            this.handleTransactionError(commitError);\n                        });\n                    });\n                }).catch((userPromiseError)=>{\n                    this.handleTransactionError(userPromiseError);\n                });\n            }\n        });\n    }\n    tryRunUpdateFunction(transaction) {\n        try {\n            const userPromise = this.updateFunction(transaction);\n            if (isNullOrUndefined(userPromise) || !userPromise.catch || !userPromise.then) {\n                this.deferred.reject(Error(\"Transaction callback must return a Promise\"));\n                return null;\n            }\n            return userPromise;\n        } catch (error) {\n            // Do not retry errors thrown by user provided updateFunction.\n            this.deferred.reject(error);\n            return null;\n        }\n    }\n    handleTransactionError(error) {\n        if (this.attemptsRemaining > 0 && this.isRetryableTransactionError(error)) {\n            this.attemptsRemaining -= 1;\n            this.asyncQueue.enqueueAndForget(()=>{\n                this.runWithBackOff();\n                return Promise.resolve();\n            });\n        } else {\n            this.deferred.reject(error);\n        }\n    }\n    isRetryableTransactionError(error) {\n        if (error.name === \"FirebaseError\") {\n            // In transactions, the backend will fail outdated reads with FAILED_PRECONDITION and\n            // non-matching document versions with ABORTED. These errors should be retried.\n            const code = error.code;\n            return code === \"aborted\" || code === \"failed-precondition\" || code === \"already-exists\" || !isPermanentError(code);\n        }\n        return false;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Represents an operation scheduled to be run in the future on an AsyncQueue.\r\n *\r\n * It is created via DelayedOperation.createAndSchedule().\r\n *\r\n * Supports cancellation (via cancel()) and early execution (via skipDelay()).\r\n *\r\n * Note: We implement `PromiseLike` instead of `Promise`, as the `Promise` type\r\n * in newer versions of TypeScript defines `finally`, which is not available in\r\n * IE.\r\n */ class DelayedOperation {\n    constructor(asyncQueue, timerId, targetTimeMs, op, removalCallback){\n        this.asyncQueue = asyncQueue;\n        this.timerId = timerId;\n        this.targetTimeMs = targetTimeMs;\n        this.op = op;\n        this.removalCallback = removalCallback;\n        this.deferred = new Deferred();\n        this.then = this.deferred.promise.then.bind(this.deferred.promise);\n        // It's normal for the deferred promise to be canceled (due to cancellation)\n        // and so we attach a dummy catch callback to avoid\n        // 'UnhandledPromiseRejectionWarning' log spam.\n        this.deferred.promise.catch((err)=>{});\n    }\n    get promise() {\n        return this.deferred.promise;\n    }\n    /**\r\n     * Creates and returns a DelayedOperation that has been scheduled to be\r\n     * executed on the provided asyncQueue after the provided delayMs.\r\n     *\r\n     * @param asyncQueue - The queue to schedule the operation on.\r\n     * @param id - A Timer ID identifying the type of operation this is.\r\n     * @param delayMs - The delay (ms) before the operation should be scheduled.\r\n     * @param op - The operation to run.\r\n     * @param removalCallback - A callback to be called synchronously once the\r\n     *   operation is executed or canceled, notifying the AsyncQueue to remove it\r\n     *   from its delayedOperations list.\r\n     *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and\r\n     *   the DelayedOperation class public.\r\n     */ static createAndSchedule(asyncQueue, timerId, delayMs, op, removalCallback) {\n        const targetTime = Date.now() + delayMs;\n        const delayedOp = new DelayedOperation(asyncQueue, timerId, targetTime, op, removalCallback);\n        delayedOp.start(delayMs);\n        return delayedOp;\n    }\n    /**\r\n     * Starts the timer. This is called immediately after construction by\r\n     * createAndSchedule().\r\n     */ start(delayMs) {\n        this.timerHandle = setTimeout(()=>this.handleDelayElapsed(), delayMs);\n    }\n    /**\r\n     * Queues the operation to run immediately (if it hasn't already been run or\r\n     * canceled).\r\n     */ skipDelay() {\n        return this.handleDelayElapsed();\n    }\n    /**\r\n     * Cancels the operation if it hasn't already been executed or canceled. The\r\n     * promise will be rejected.\r\n     *\r\n     * As long as the operation has not yet been run, calling cancel() provides a\r\n     * guarantee that the operation will not be run.\r\n     */ cancel(reason) {\n        if (this.timerHandle !== null) {\n            this.clearTimeout();\n            this.deferred.reject(new FirestoreError(Code.CANCELLED, \"Operation cancelled\" + (reason ? \": \" + reason : \"\")));\n        }\n    }\n    handleDelayElapsed() {\n        this.asyncQueue.enqueueAndForget(()=>{\n            if (this.timerHandle !== null) {\n                this.clearTimeout();\n                return this.op().then((result)=>{\n                    return this.deferred.resolve(result);\n                });\n            } else {\n                return Promise.resolve();\n            }\n        });\n    }\n    clearTimeout() {\n        if (this.timerHandle !== null) {\n            this.removalCallback(this);\n            clearTimeout(this.timerHandle);\n            this.timerHandle = null;\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const LOG_TAG = \"AsyncQueue\";\nclass AsyncQueueImpl {\n    constructor(){\n        // The last promise in the queue.\n        this.tail = Promise.resolve();\n        // A list of retryable operations. Retryable operations are run in order and\n        // retried with backoff.\n        this.retryableOps = [];\n        // Is this AsyncQueue being shut down? Once it is set to true, it will not\n        // be changed again.\n        this._isShuttingDown = false;\n        // Operations scheduled to be queued in the future. Operations are\n        // automatically removed after they are run or canceled.\n        this.delayedOperations = [];\n        // visible for testing\n        this.failure = null;\n        // Flag set while there's an outstanding AsyncQueue operation, used for\n        // assertion sanity-checks.\n        this.operationInProgress = false;\n        // Enabled during shutdown on Safari to prevent future access to IndexedDB.\n        this.skipNonRestrictedTasks = false;\n        // List of TimerIds to fast-forward delays for.\n        this.timerIdsToSkip = [];\n        // Backoff timer used to schedule retries for retryable operations\n        this.backoff = new ExponentialBackoff(this, \"async_queue_retry\" /* TimerId.AsyncQueueRetry */ );\n        // Visibility handler that triggers an immediate retry of all retryable\n        // operations. Meant to speed up recovery when we regain file system access\n        // after page comes into foreground.\n        this.visibilityHandler = ()=>{\n            this.backoff.skipBackoff();\n        };\n    }\n    get isShuttingDown() {\n        return this._isShuttingDown;\n    }\n    /**\r\n     * Adds a new operation to the queue without waiting for it to complete (i.e.\r\n     * we ignore the Promise result).\r\n     */ enqueueAndForget(op) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.enqueue(op);\n    }\n    enqueueAndForgetEvenWhileRestricted(op) {\n        this.verifyNotFailed();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.enqueueInternal(op);\n    }\n    enterRestrictedMode(purgeExistingTasks) {\n        if (!this._isShuttingDown) {\n            this._isShuttingDown = true;\n            this.skipNonRestrictedTasks = purgeExistingTasks || false;\n        }\n    }\n    enqueue(op) {\n        this.verifyNotFailed();\n        if (this._isShuttingDown) {\n            // Return a Promise which never resolves.\n            return new Promise(()=>{});\n        }\n        // Create a deferred Promise that we can return to the callee. This\n        // allows us to return a \"hanging Promise\" only to the callee and still\n        // advance the queue even when the operation is not run.\n        const task = new Deferred();\n        return this.enqueueInternal(()=>{\n            if (this._isShuttingDown && this.skipNonRestrictedTasks) {\n                // We do not resolve 'task'\n                return Promise.resolve();\n            }\n            op().then(task.resolve, task.reject);\n            return task.promise;\n        }).then(()=>task.promise);\n    }\n    enqueueRetryable(op) {\n        this.enqueueAndForget(()=>{\n            this.retryableOps.push(op);\n            return this.retryNextOp();\n        });\n    }\n    /**\r\n     * Runs the next operation from the retryable queue. If the operation fails,\r\n     * reschedules with backoff.\r\n     */ async retryNextOp() {\n        if (this.retryableOps.length === 0) {\n            return;\n        }\n        try {\n            await this.retryableOps[0]();\n            this.retryableOps.shift();\n            this.backoff.reset();\n        } catch (e) {\n            if (isIndexedDbTransactionError(e)) {\n                logDebug(LOG_TAG, \"Operation failed with retryable error: \" + e);\n            } else {\n                throw e; // Failure will be handled by AsyncQueue\n            }\n        }\n        if (this.retryableOps.length > 0) {\n            // If there are additional operations, we re-schedule `retryNextOp()`.\n            // This is necessary to run retryable operations that failed during\n            // their initial attempt since we don't know whether they are already\n            // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`\n            // needs to  be re-run, we will run `op1`, `op1`, `op2` using the\n            // already enqueued calls to `retryNextOp()`. `op3()` will then run in the\n            // call scheduled here.\n            // Since `backoffAndRun()` cancels an existing backoff and schedules a\n            // new backoff on every call, there is only ever a single additional\n            // operation in the queue.\n            this.backoff.backoffAndRun(()=>this.retryNextOp());\n        }\n    }\n    enqueueInternal(op) {\n        const newTail = this.tail.then(()=>{\n            this.operationInProgress = true;\n            return op().catch((error)=>{\n                this.failure = error;\n                this.operationInProgress = false;\n                const message = getMessageOrStack(error);\n                logError(\"INTERNAL UNHANDLED ERROR: \", message);\n                // Re-throw the error so that this.tail becomes a rejected Promise and\n                // all further attempts to chain (via .then) will just short-circuit\n                // and return the rejected Promise.\n                throw error;\n            }).then((result)=>{\n                this.operationInProgress = false;\n                return result;\n            });\n        });\n        this.tail = newTail;\n        return newTail;\n    }\n    enqueueAfterDelay(timerId, delayMs, op) {\n        this.verifyNotFailed();\n        // Fast-forward delays for timerIds that have been overriden.\n        if (this.timerIdsToSkip.indexOf(timerId) > -1) {\n            delayMs = 0;\n        }\n        const delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, (removedOp)=>this.removeDelayedOperation(removedOp));\n        this.delayedOperations.push(delayedOp);\n        return delayedOp;\n    }\n    verifyNotFailed() {\n        if (this.failure) {\n            fail();\n        }\n    }\n    verifyOperationInProgress() {}\n    /**\r\n     * Waits until all currently queued tasks are finished executing. Delayed\r\n     * operations are not run.\r\n     */ async drain() {\n        // Operations in the queue prior to draining may have enqueued additional\n        // operations. Keep draining the queue until the tail is no longer advanced,\n        // which indicates that no more new operations were enqueued and that all\n        // operations were executed.\n        let currentTail;\n        do {\n            currentTail = this.tail;\n            await currentTail;\n        }while (currentTail !== this.tail);\n    }\n    /**\r\n     * For Tests: Determine if a delayed operation with a particular TimerId\r\n     * exists.\r\n     */ containsDelayedOperation(timerId) {\n        for (const op of this.delayedOperations){\n            if (op.timerId === timerId) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\r\n     * For Tests: Runs some or all delayed operations early.\r\n     *\r\n     * @param lastTimerId - Delayed operations up to and including this TimerId\r\n     * will be drained. Pass TimerId.All to run all delayed operations.\r\n     * @returns a Promise that resolves once all operations have been run.\r\n     */ runAllDelayedOperationsUntil(lastTimerId) {\n        // Note that draining may generate more delayed ops, so we do that first.\n        return this.drain().then(()=>{\n            // Run ops in the same order they'd run if they ran naturally.\n            this.delayedOperations.sort((a, b)=>a.targetTimeMs - b.targetTimeMs);\n            for (const op of this.delayedOperations){\n                op.skipDelay();\n                if (lastTimerId !== \"all\" /* TimerId.All */  && op.timerId === lastTimerId) {\n                    break;\n                }\n            }\n            return this.drain();\n        });\n    }\n    /**\r\n     * For Tests: Skip all subsequent delays for a timer id.\r\n     */ skipDelaysForTimerId(timerId) {\n        this.timerIdsToSkip.push(timerId);\n    }\n    /** Called once a DelayedOperation is run or canceled. */ removeDelayedOperation(op) {\n        // NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.\n        const index = this.delayedOperations.indexOf(op);\n        this.delayedOperations.splice(index, 1);\n    }\n}\nfunction newAsyncQueue() {\n    return new AsyncQueueImpl();\n}\n/**\r\n * Chrome includes Error.message in Error.stack. Other browsers do not.\r\n * This returns expected output of message + stack when available.\r\n * @param error - Error or FirestoreError\r\n */ function getMessageOrStack(error) {\n    let message = error.message || \"\";\n    if (error.stack) {\n        if (error.stack.includes(error.message)) {\n            message = error.stack;\n        } else {\n            message = error.message + \"\\n\" + error.stack;\n        }\n    }\n    return message;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // TODO(mrschmidt) Consider using `BaseTransaction` as the base class in the\n// legacy SDK.\n/**\r\n * A reference to a transaction.\r\n *\r\n * The `Transaction` object passed to a transaction's `updateFunction` provides\r\n * the methods to read and write data within the transaction context. See\r\n * {@link runTransaction}.\r\n */ class Transaction {\n    /** @hideconstructor */ constructor(_firestore, _transaction){\n        this._firestore = _firestore;\n        this._transaction = _transaction;\n        this._dataReader = newUserDataReader(_firestore);\n    }\n    /**\r\n     * Reads the document referenced by the provided {@link DocumentReference}.\r\n     *\r\n     * @param documentRef - A reference to the document to be read.\r\n     * @returns A `DocumentSnapshot` with the read data.\r\n     */ get(documentRef) {\n        const ref = validateReference(documentRef, this._firestore);\n        const userDataWriter = new LiteUserDataWriter(this._firestore);\n        return this._transaction.lookup([\n            ref._key\n        ]).then((docs)=>{\n            if (!docs || docs.length !== 1) {\n                return fail();\n            }\n            const doc = docs[0];\n            if (doc.isFoundDocument()) {\n                return new DocumentSnapshot(this._firestore, userDataWriter, doc.key, doc, ref.converter);\n            } else if (doc.isNoDocument()) {\n                return new DocumentSnapshot(this._firestore, userDataWriter, ref._key, null, ref.converter);\n            } else {\n                throw fail();\n            }\n        });\n    }\n    set(documentRef, value, options) {\n        const ref = validateReference(documentRef, this._firestore);\n        const convertedValue = applyFirestoreDataConverter(ref.converter, value, options);\n        const parsed = parseSetData(this._dataReader, \"Transaction.set\", ref._key, convertedValue, ref.converter !== null, options);\n        this._transaction.set(ref._key, parsed);\n        return this;\n    }\n    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {\n        const ref = validateReference(documentRef, this._firestore);\n        // For Compat types, we have to \"extract\" the underlying types before\n        // performing validation.\n        fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\n        let parsed;\n        if (typeof fieldOrUpdateData === \"string\" || fieldOrUpdateData instanceof FieldPath) {\n            parsed = parseUpdateVarargs(this._dataReader, \"Transaction.update\", ref._key, fieldOrUpdateData, value, moreFieldsAndValues);\n        } else {\n            parsed = parseUpdateData(this._dataReader, \"Transaction.update\", ref._key, fieldOrUpdateData);\n        }\n        this._transaction.update(ref._key, parsed);\n        return this;\n    }\n    /**\r\n     * Deletes the document referred to by the provided {@link DocumentReference}.\r\n     *\r\n     * @param documentRef - A reference to the document to be deleted.\r\n     * @returns This `Transaction` instance. Used for chaining method calls.\r\n     */ delete(documentRef) {\n        const ref = validateReference(documentRef, this._firestore);\n        this._transaction.delete(ref._key);\n        return this;\n    }\n}\n/**\r\n * Executes the given `updateFunction` and then attempts to commit the changes\r\n * applied within the transaction. If any document read within the transaction\r\n * has changed, Cloud Firestore retries the `updateFunction`. If it fails to\r\n * commit after 5 attempts, the transaction fails.\r\n *\r\n * The maximum number of writes allowed in a single transaction is 500.\r\n *\r\n * @param firestore - A reference to the Firestore database to run this\r\n * transaction against.\r\n * @param updateFunction - The function to execute within the transaction\r\n * context.\r\n * @param options - An options object to configure maximum number of attempts to\r\n * commit.\r\n * @returns If the transaction completed successfully or was explicitly aborted\r\n * (the `updateFunction` returned a failed promise), the promise returned by the\r\n * `updateFunction `is returned here. Otherwise, if the transaction failed, a\r\n * rejected promise with the corresponding failure error is returned.\r\n */ function runTransaction(firestore, updateFunction, options) {\n    firestore = cast(firestore, Firestore);\n    const datastore = getDatastore(firestore);\n    const optionsWithDefaults = Object.assign(Object.assign({}, DEFAULT_TRANSACTION_OPTIONS), options);\n    validateTransactionOptions(optionsWithDefaults);\n    const deferred = new Deferred();\n    new TransactionRunner(newAsyncQueue(), datastore, optionsWithDefaults, (internalTransaction)=>updateFunction(new Transaction(firestore, internalTransaction)), deferred).run();\n    return deferred.promise;\n}\n/**\r\n * Firestore Lite\r\n *\r\n * @remarks Firestore Lite is a small online-only SDK that allows read\r\n * and write access to your Firestore database. All operations connect\r\n * directly to the backend, and `onSnapshot()` APIs are not supported.\r\n * @packageDocumentation\r\n */ registerFirestore();\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2ZpcmVzdG9yZS9kaXN0L2xpdGUvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0o7QUFDaEc7QUFDSTtBQUNyQjtBQUN1RztBQUN2RztBQUN1QjtBQUV0RCxNQUFNbUIsWUFBWTtBQUVsQjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7O0NBR0MsR0FDRCxNQUFNQztJQUNGQyxZQUFZQyxHQUFHLENBQUU7UUFDYixJQUFJLENBQUNBLEdBQUcsR0FBR0E7SUFDZjtJQUNBQyxrQkFBa0I7UUFDZCxPQUFPLElBQUksQ0FBQ0QsR0FBRyxJQUFJO0lBQ3ZCO0lBQ0E7OztLQUdDLEdBQ0RFLFFBQVE7UUFDSixJQUFJLElBQUksQ0FBQ0QsZUFBZSxJQUFJO1lBQ3hCLE9BQU8sU0FBUyxJQUFJLENBQUNELEdBQUc7UUFDNUIsT0FDSztZQUNELE9BQU87UUFDWDtJQUNKO0lBQ0FHLFFBQVFDLFNBQVMsRUFBRTtRQUNmLE9BQU9BLFVBQVVKLEdBQUcsS0FBSyxJQUFJLENBQUNBLEdBQUc7SUFDckM7QUFDSjtBQUNBLDRCQUE0QixHQUM1QkYsS0FBS08sZUFBZSxHQUFHLElBQUlQLEtBQUs7QUFDaEMsaUVBQWlFO0FBQ2pFLDhCQUE4QjtBQUM5QkEsS0FBS1Esa0JBQWtCLEdBQUcsSUFBSVIsS0FBSztBQUNuQ0EsS0FBS1MsV0FBVyxHQUFHLElBQUlULEtBQUs7QUFDNUJBLEtBQUtVLFNBQVMsR0FBRyxJQUFJVixLQUFLO0FBRTFCLE1BQU1XLFVBQVU7QUFFaEI7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsSUFBSTFCLGNBQWMwQjtBQUNsQixTQUFTQyxjQUFjRCxPQUFPO0lBQzFCMUIsY0FBYzBCO0FBQ2xCO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsOERBQThELEdB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ZHVsZXMvQGZpcmViYXNlL2ZpcmVzdG9yZS9kaXN0L2xpdGUvaW5kZXgubm9kZS5tanM/NDUwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfZ2V0UHJvdmlkZXIsIGdldEFwcCwgX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSwgX3JlZ2lzdGVyQ29tcG9uZW50LCByZWdpc3RlclZlcnNpb24sIFNES19WRVJTSU9OIGFzIFNES19WRVJTSU9OJDEgfSBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgTG9nZ2VyLCBMb2dMZXZlbCB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuaW1wb3J0IHsgaW5zcGVjdCB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciwgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0LCBjcmVhdGVNb2NrVXNlclRva2VuLCBnZXRNb2R1bGFySW5zdGFuY2UsIGRlZXBFcXVhbCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGZldGNoIH0gZnJvbSAndW5kaWNpJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIGFzIHJhbmRvbUJ5dGVzJDEgfSBmcm9tICdjcnlwdG8nO1xuXG5jb25zdCB2ZXJzaW9uJDEgPSBcIjQuNi4xXCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBTaW1wbGUgd3JhcHBlciBhcm91bmQgYSBudWxsYWJsZSBVSUQuIE1vc3RseSBleGlzdHMgdG8gbWFrZSBjb2RlIG1vcmVcclxuICogcmVhZGFibGUuXHJcbiAqL1xyXG5jbGFzcyBVc2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHVpZCkge1xyXG4gICAgICAgIHRoaXMudWlkID0gdWlkO1xyXG4gICAgfVxyXG4gICAgaXNBdXRoZW50aWNhdGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVpZCAhPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEga2V5IHJlcHJlc2VudGluZyB0aGlzIHVzZXIsIHN1aXRhYmxlIGZvciBpbmNsdXNpb24gaW4gYVxyXG4gICAgICogZGljdGlvbmFyeS5cclxuICAgICAqL1xyXG4gICAgdG9LZXkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBdXRoZW50aWNhdGVkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICd1aWQ6JyArIHRoaXMudWlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdhbm9ueW1vdXMtdXNlcic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlclVzZXIpIHtcclxuICAgICAgICByZXR1cm4gb3RoZXJVc2VyLnVpZCA9PT0gdGhpcy51aWQ7XHJcbiAgICB9XHJcbn1cclxuLyoqIEEgdXNlciB3aXRoIGEgbnVsbCBVSUQuICovXHJcblVzZXIuVU5BVVRIRU5USUNBVEVEID0gbmV3IFVzZXIobnVsbCk7XHJcbi8vIFRPRE8obWlrZWxlaGVuKTogTG9vayBpbnRvIGdldHRpbmcgYSBwcm9wZXIgdWlkLWVxdWl2YWxlbnQgZm9yXHJcbi8vIG5vbi1GaXJlYmFzZUF1dGggcHJvdmlkZXJzLlxyXG5Vc2VyLkdPT0dMRV9DUkVERU5USUFMUyA9IG5ldyBVc2VyKCdnb29nbGUtY3JlZGVudGlhbHMtdWlkJyk7XHJcblVzZXIuRklSU1RfUEFSVFkgPSBuZXcgVXNlcignZmlyc3QtcGFydHktdWlkJyk7XHJcblVzZXIuTU9DS19VU0VSID0gbmV3IFVzZXIoJ21vY2stdXNlcicpO1xuXG5jb25zdCB2ZXJzaW9uID0gXCIxMC4xMS4xXCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmxldCBTREtfVkVSU0lPTiA9IHZlcnNpb247XHJcbmZ1bmN0aW9uIHNldFNES1ZlcnNpb24odmVyc2lvbikge1xyXG4gICAgU0RLX1ZFUlNJT04gPSB2ZXJzaW9uO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBGb3JtYXRzIGFuIG9iamVjdCBhcyBhIEpTT04gc3RyaW5nLCBzdWl0YWJsZSBmb3IgbG9nZ2luZy4gKi9cclxuZnVuY3Rpb24gZm9ybWF0SlNPTih2YWx1ZSkge1xyXG4gICAgLy8gdXRpbC5pbnNwZWN0KCkgcmVzdWx0cyBpbiBtdWNoIG1vcmUgcmVhZGFibGUgb3V0cHV0IHRoYW4gSlNPTi5zdHJpbmdpZnkoKVxyXG4gICAgcmV0dXJuIGluc3BlY3QodmFsdWUsIHsgZGVwdGg6IDEwMCB9KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBsb2dDbGllbnQgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvZmlyZXN0b3JlJyk7XHJcbi8qKlxyXG4gKiBTZXRzIHRoZSB2ZXJib3NpdHkgb2YgQ2xvdWQgRmlyZXN0b3JlIGxvZ3MgKGRlYnVnLCBlcnJvciwgb3Igc2lsZW50KS5cclxuICpcclxuICogQHBhcmFtIGxvZ0xldmVsIC0gVGhlIHZlcmJvc2l0eSB5b3Ugc2V0IGZvciBhY3Rpdml0eSBhbmQgZXJyb3IgbG9nZ2luZy4gQ2FuXHJcbiAqICAgYmUgYW55IG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxyXG4gKlxyXG4gKiAgIDx1bD5cclxuICogICAgIDxsaT5gZGVidWdgIGZvciB0aGUgbW9zdCB2ZXJib3NlIGxvZ2dpbmcgbGV2ZWwsIHByaW1hcmlseSBmb3JcclxuICogICAgIGRlYnVnZ2luZy48L2xpPlxyXG4gKiAgICAgPGxpPmBlcnJvcmAgdG8gbG9nIGVycm9ycyBvbmx5LjwvbGk+XHJcbiAqICAgICA8bGk+PGNvZGU+YHNpbGVudGAgdG8gdHVybiBvZmYgbG9nZ2luZy48L2xpPlxyXG4gKiAgIDwvdWw+XHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsb2dMZXZlbCkge1xyXG4gICAgbG9nQ2xpZW50LnNldExvZ0xldmVsKGxvZ0xldmVsKTtcclxufVxyXG5mdW5jdGlvbiBsb2dEZWJ1Zyhtc2csIC4uLm9iaikge1xyXG4gICAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5ERUJVRykge1xyXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBvYmoubWFwKGFyZ1RvU3RyaW5nKTtcclxuICAgICAgICBsb2dDbGllbnQuZGVidWcoYEZpcmVzdG9yZSAoJHtTREtfVkVSU0lPTn0pOiAke21zZ31gLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBsb2dFcnJvcihtc2csIC4uLm9iaikge1xyXG4gICAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5FUlJPUikge1xyXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBvYmoubWFwKGFyZ1RvU3RyaW5nKTtcclxuICAgICAgICBsb2dDbGllbnQuZXJyb3IoYEZpcmVzdG9yZSAoJHtTREtfVkVSU0lPTn0pOiAke21zZ31gLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2dXYXJuKG1zZywgLi4ub2JqKSB7XHJcbiAgICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLldBUk4pIHtcclxuICAgICAgICBjb25zdCBhcmdzID0gb2JqLm1hcChhcmdUb1N0cmluZyk7XHJcbiAgICAgICAgbG9nQ2xpZW50Lndhcm4oYEZpcmVzdG9yZSAoJHtTREtfVkVSU0lPTn0pOiAke21zZ31gLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ29udmVydHMgYW4gYWRkaXRpb25hbCBsb2cgcGFyYW1ldGVyIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gYXJnVG9TdHJpbmcob2JqKSB7XHJcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEpTT04ob2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gQ29udmVydGluZyB0byBKU09OIGZhaWxlZCwganVzdCBsb2cgdGhlIG9iamVjdCBkaXJlY3RseVxyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVW5jb25kaXRpb25hbGx5IGZhaWxzLCB0aHJvd2luZyBhbiBFcnJvciB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlLlxyXG4gKiBNZXNzYWdlcyBhcmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMuXHJcbiAqXHJcbiAqIFJldHVybnMgYG5ldmVyYCBhbmQgY2FuIGJlIHVzZWQgaW4gZXhwcmVzc2lvbnM6XHJcbiAqIEBleGFtcGxlXHJcbiAqIGxldCBmdXR1cmVWYXIgPSBmYWlsKCdub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XHJcbiAqL1xyXG5mdW5jdGlvbiBmYWlsKGZhaWx1cmUgPSAnVW5leHBlY3RlZCBzdGF0ZScpIHtcclxuICAgIC8vIExvZyB0aGUgZmFpbHVyZSBpbiBhZGRpdGlvbiB0byB0aHJvdyBhbiBleGNlcHRpb24sIGp1c3QgaW4gY2FzZSB0aGVcclxuICAgIC8vIGV4Y2VwdGlvbiBpcyBzd2FsbG93ZWQuXHJcbiAgICBjb25zdCBtZXNzYWdlID0gYEZJUkVTVE9SRSAoJHtTREtfVkVSU0lPTn0pIElOVEVSTkFMIEFTU0VSVElPTiBGQUlMRUQ6IGAgKyBmYWlsdXJlO1xyXG4gICAgbG9nRXJyb3IobWVzc2FnZSk7XHJcbiAgICAvLyBOT1RFOiBXZSBkb24ndCB1c2UgRmlyZXN0b3JlRXJyb3IgaGVyZSBiZWNhdXNlIHRoZXNlIGFyZSBpbnRlcm5hbCBmYWlsdXJlc1xyXG4gICAgLy8gdGhhdCBjYW5ub3QgYmUgaGFuZGxlZCBieSB0aGUgdXNlci4gKEFsc28gaXQgd291bGQgY3JlYXRlIGEgY2lyY3VsYXJcclxuICAgIC8vIGRlcGVuZGVuY3kgYmV0d2VlbiB0aGUgZXJyb3IgYW5kIGFzc2VydCBtb2R1bGVzIHdoaWNoIGRvZXNuJ3Qgd29yay4pXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbn1cclxuLyoqXHJcbiAqIEZhaWxzIGlmIHRoZSBnaXZlbiBhc3NlcnRpb24gY29uZGl0aW9uIGlzIGZhbHNlLCB0aHJvd2luZyBhbiBFcnJvciB3aXRoIHRoZVxyXG4gKiBnaXZlbiBtZXNzYWdlIGlmIGl0IGRpZC5cclxuICpcclxuICogTWVzc2FnZXMgYXJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLlxyXG4gKi9cclxuZnVuY3Rpb24gaGFyZEFzc2VydChhc3NlcnRpb24sIG1lc3NhZ2UpIHtcclxuICAgIGlmICghYXNzZXJ0aW9uKSB7XHJcbiAgICAgICAgZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYXN0cyBgb2JqYCB0byBgVGAuIEluIG5vbi1wcm9kdWN0aW9uIGJ1aWxkcywgdmVyaWZpZXMgdGhhdCBgb2JqYCBpcyBhblxyXG4gKiBpbnN0YW5jZSBvZiBgVGAgYmVmb3JlIGNhc3RpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWJ1Z0Nhc3Qob2JqLCBcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuY29uc3RydWN0b3IpIHtcclxuICAgIHJldHVybiBvYmo7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgQ29kZSA9IHtcclxuICAgIC8vIENhdXNlcyBhcmUgY29waWVkIGZyb206XHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvYmNlZWM5NGVhNGZjNWYwMDg1ZDgxMjM1ZDhlMWMwNjc5OGRjMzQxYS9pbmNsdWRlL2dycGMlMkIlMkIvaW1wbC9jb2RlZ2VuL3N0YXR1c19jb2RlX2VudW0uaFxyXG4gICAgLyoqIE5vdCBhbiBlcnJvcjsgcmV0dXJuZWQgb24gc3VjY2Vzcy4gKi9cclxuICAgIE9LOiAnb2snLFxyXG4gICAgLyoqIFRoZSBvcGVyYXRpb24gd2FzIGNhbmNlbGxlZCAodHlwaWNhbGx5IGJ5IHRoZSBjYWxsZXIpLiAqL1xyXG4gICAgQ0FOQ0VMTEVEOiAnY2FuY2VsbGVkJyxcclxuICAgIC8qKiBVbmtub3duIGVycm9yIG9yIGFuIGVycm9yIGZyb20gYSBkaWZmZXJlbnQgZXJyb3IgZG9tYWluLiAqL1xyXG4gICAgVU5LTk9XTjogJ3Vua25vd24nLFxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGllbnQgc3BlY2lmaWVkIGFuIGludmFsaWQgYXJndW1lbnQuIE5vdGUgdGhhdCB0aGlzIGRpZmZlcnMgZnJvbVxyXG4gICAgICogRkFJTEVEX1BSRUNPTkRJVElPTi4gSU5WQUxJRF9BUkdVTUVOVCBpbmRpY2F0ZXMgYXJndW1lbnRzIHRoYXQgYXJlXHJcbiAgICAgKiBwcm9ibGVtYXRpYyByZWdhcmRsZXNzIG9mIHRoZSBzdGF0ZSBvZiB0aGUgc3lzdGVtIChlLmcuLCBhIG1hbGZvcm1lZCBmaWxlXHJcbiAgICAgKiBuYW1lKS5cclxuICAgICAqL1xyXG4gICAgSU5WQUxJRF9BUkdVTUVOVDogJ2ludmFsaWQtYXJndW1lbnQnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWFkbGluZSBleHBpcmVkIGJlZm9yZSBvcGVyYXRpb24gY291bGQgY29tcGxldGUuIEZvciBvcGVyYXRpb25zIHRoYXRcclxuICAgICAqIGNoYW5nZSB0aGUgc3RhdGUgb2YgdGhlIHN5c3RlbSwgdGhpcyBlcnJvciBtYXkgYmUgcmV0dXJuZWQgZXZlbiBpZiB0aGVcclxuICAgICAqIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS4gRm9yIGV4YW1wbGUsIGEgc3VjY2Vzc2Z1bCByZXNwb25zZVxyXG4gICAgICogZnJvbSBhIHNlcnZlciBjb3VsZCBoYXZlIGJlZW4gZGVsYXllZCBsb25nIGVub3VnaCBmb3IgdGhlIGRlYWRsaW5lIHRvXHJcbiAgICAgKiBleHBpcmUuXHJcbiAgICAgKi9cclxuICAgIERFQURMSU5FX0VYQ0VFREVEOiAnZGVhZGxpbmUtZXhjZWVkZWQnLFxyXG4gICAgLyoqIFNvbWUgcmVxdWVzdGVkIGVudGl0eSAoZS5nLiwgZmlsZSBvciBkaXJlY3RvcnkpIHdhcyBub3QgZm91bmQuICovXHJcbiAgICBOT1RfRk9VTkQ6ICdub3QtZm91bmQnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBTb21lIGVudGl0eSB0aGF0IHdlIGF0dGVtcHRlZCB0byBjcmVhdGUgKGUuZy4sIGZpbGUgb3IgZGlyZWN0b3J5KSBhbHJlYWR5XHJcbiAgICAgKiBleGlzdHMuXHJcbiAgICAgKi9cclxuICAgIEFMUkVBRFlfRVhJU1RTOiAnYWxyZWFkeS1leGlzdHMnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FsbGVyIGRvZXMgbm90IGhhdmUgcGVybWlzc2lvbiB0byBleGVjdXRlIHRoZSBzcGVjaWZpZWQgb3BlcmF0aW9uLlxyXG4gICAgICogUEVSTUlTU0lPTl9ERU5JRUQgbXVzdCBub3QgYmUgdXNlZCBmb3IgcmVqZWN0aW9ucyBjYXVzZWQgYnkgZXhoYXVzdGluZ1xyXG4gICAgICogc29tZSByZXNvdXJjZSAodXNlIFJFU09VUkNFX0VYSEFVU1RFRCBpbnN0ZWFkIGZvciB0aG9zZSBlcnJvcnMpLlxyXG4gICAgICogUEVSTUlTU0lPTl9ERU5JRUQgbXVzdCBub3QgYmUgdXNlZCBpZiB0aGUgY2FsbGVyIGNhbiBub3QgYmUgaWRlbnRpZmllZFxyXG4gICAgICogKHVzZSBVTkFVVEhFTlRJQ0FURUQgaW5zdGVhZCBmb3IgdGhvc2UgZXJyb3JzKS5cclxuICAgICAqL1xyXG4gICAgUEVSTUlTU0lPTl9ERU5JRUQ6ICdwZXJtaXNzaW9uLWRlbmllZCcsXHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZXF1ZXN0IGRvZXMgbm90IGhhdmUgdmFsaWQgYXV0aGVudGljYXRpb24gY3JlZGVudGlhbHMgZm9yIHRoZVxyXG4gICAgICogb3BlcmF0aW9uLlxyXG4gICAgICovXHJcbiAgICBVTkFVVEhFTlRJQ0FURUQ6ICd1bmF1dGhlbnRpY2F0ZWQnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBTb21lIHJlc291cmNlIGhhcyBiZWVuIGV4aGF1c3RlZCwgcGVyaGFwcyBhIHBlci11c2VyIHF1b3RhLCBvciBwZXJoYXBzIHRoZVxyXG4gICAgICogZW50aXJlIGZpbGUgc3lzdGVtIGlzIG91dCBvZiBzcGFjZS5cclxuICAgICAqL1xyXG4gICAgUkVTT1VSQ0VfRVhIQVVTVEVEOiAncmVzb3VyY2UtZXhoYXVzdGVkJyxcclxuICAgIC8qKlxyXG4gICAgICogT3BlcmF0aW9uIHdhcyByZWplY3RlZCBiZWNhdXNlIHRoZSBzeXN0ZW0gaXMgbm90IGluIGEgc3RhdGUgcmVxdWlyZWQgZm9yXHJcbiAgICAgKiB0aGUgb3BlcmF0aW9uJ3MgZXhlY3V0aW9uLiBGb3IgZXhhbXBsZSwgZGlyZWN0b3J5IHRvIGJlIGRlbGV0ZWQgbWF5IGJlXHJcbiAgICAgKiBub24tZW1wdHksIGFuIHJtZGlyIG9wZXJhdGlvbiBpcyBhcHBsaWVkIHRvIGEgbm9uLWRpcmVjdG9yeSwgZXRjLlxyXG4gICAgICpcclxuICAgICAqIEEgbGl0bXVzIHRlc3QgdGhhdCBtYXkgaGVscCBhIHNlcnZpY2UgaW1wbGVtZW50b3IgaW4gZGVjaWRpbmdcclxuICAgICAqIGJldHdlZW4gRkFJTEVEX1BSRUNPTkRJVElPTiwgQUJPUlRFRCwgYW5kIFVOQVZBSUxBQkxFOlxyXG4gICAgICogIChhKSBVc2UgVU5BVkFJTEFCTEUgaWYgdGhlIGNsaWVudCBjYW4gcmV0cnkganVzdCB0aGUgZmFpbGluZyBjYWxsLlxyXG4gICAgICogIChiKSBVc2UgQUJPUlRFRCBpZiB0aGUgY2xpZW50IHNob3VsZCByZXRyeSBhdCBhIGhpZ2hlci1sZXZlbFxyXG4gICAgICogICAgICAoZS5nLiwgcmVzdGFydGluZyBhIHJlYWQtbW9kaWZ5LXdyaXRlIHNlcXVlbmNlKS5cclxuICAgICAqICAoYykgVXNlIEZBSUxFRF9QUkVDT05ESVRJT04gaWYgdGhlIGNsaWVudCBzaG91bGQgbm90IHJldHJ5IHVudGlsXHJcbiAgICAgKiAgICAgIHRoZSBzeXN0ZW0gc3RhdGUgaGFzIGJlZW4gZXhwbGljaXRseSBmaXhlZC4gRS5nLiwgaWYgYW4gXCJybWRpclwiXHJcbiAgICAgKiAgICAgIGZhaWxzIGJlY2F1c2UgdGhlIGRpcmVjdG9yeSBpcyBub24tZW1wdHksIEZBSUxFRF9QUkVDT05ESVRJT05cclxuICAgICAqICAgICAgc2hvdWxkIGJlIHJldHVybmVkIHNpbmNlIHRoZSBjbGllbnQgc2hvdWxkIG5vdCByZXRyeSB1bmxlc3NcclxuICAgICAqICAgICAgdGhleSBoYXZlIGZpcnN0IGZpeGVkIHVwIHRoZSBkaXJlY3RvcnkgYnkgZGVsZXRpbmcgZmlsZXMgZnJvbSBpdC5cclxuICAgICAqICAoZCkgVXNlIEZBSUxFRF9QUkVDT05ESVRJT04gaWYgdGhlIGNsaWVudCBwZXJmb3JtcyBjb25kaXRpb25hbFxyXG4gICAgICogICAgICBSRVNUIEdldC9VcGRhdGUvRGVsZXRlIG9uIGEgcmVzb3VyY2UgYW5kIHRoZSByZXNvdXJjZSBvbiB0aGVcclxuICAgICAqICAgICAgc2VydmVyIGRvZXMgbm90IG1hdGNoIHRoZSBjb25kaXRpb24uIEUuZy4sIGNvbmZsaWN0aW5nXHJcbiAgICAgKiAgICAgIHJlYWQtbW9kaWZ5LXdyaXRlIG9uIHRoZSBzYW1lIHJlc291cmNlLlxyXG4gICAgICovXHJcbiAgICBGQUlMRURfUFJFQ09ORElUSU9OOiAnZmFpbGVkLXByZWNvbmRpdGlvbicsXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQsIHR5cGljYWxseSBkdWUgdG8gYSBjb25jdXJyZW5jeSBpc3N1ZSBsaWtlXHJcbiAgICAgKiBzZXF1ZW5jZXIgY2hlY2sgZmFpbHVyZXMsIHRyYW5zYWN0aW9uIGFib3J0cywgZXRjLlxyXG4gICAgICpcclxuICAgICAqIFNlZSBsaXRtdXMgdGVzdCBhYm92ZSBmb3IgZGVjaWRpbmcgYmV0d2VlbiBGQUlMRURfUFJFQ09ORElUSU9OLCBBQk9SVEVELFxyXG4gICAgICogYW5kIFVOQVZBSUxBQkxFLlxyXG4gICAgICovXHJcbiAgICBBQk9SVEVEOiAnYWJvcnRlZCcsXHJcbiAgICAvKipcclxuICAgICAqIE9wZXJhdGlvbiB3YXMgYXR0ZW1wdGVkIHBhc3QgdGhlIHZhbGlkIHJhbmdlLiBFLmcuLCBzZWVraW5nIG9yIHJlYWRpbmdcclxuICAgICAqIHBhc3QgZW5kIG9mIGZpbGUuXHJcbiAgICAgKlxyXG4gICAgICogVW5saWtlIElOVkFMSURfQVJHVU1FTlQsIHRoaXMgZXJyb3IgaW5kaWNhdGVzIGEgcHJvYmxlbSB0aGF0IG1heSBiZSBmaXhlZFxyXG4gICAgICogaWYgdGhlIHN5c3RlbSBzdGF0ZSBjaGFuZ2VzLiBGb3IgZXhhbXBsZSwgYSAzMi1iaXQgZmlsZSBzeXN0ZW0gd2lsbFxyXG4gICAgICogZ2VuZXJhdGUgSU5WQUxJRF9BUkdVTUVOVCBpZiBhc2tlZCB0byByZWFkIGF0IGFuIG9mZnNldCB0aGF0IGlzIG5vdCBpbiB0aGVcclxuICAgICAqIHJhbmdlIFswLDJeMzItMV0sIGJ1dCBpdCB3aWxsIGdlbmVyYXRlIE9VVF9PRl9SQU5HRSBpZiBhc2tlZCB0byByZWFkIGZyb21cclxuICAgICAqIGFuIG9mZnNldCBwYXN0IHRoZSBjdXJyZW50IGZpbGUgc2l6ZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGVyZSBpcyBhIGZhaXIgYml0IG9mIG92ZXJsYXAgYmV0d2VlbiBGQUlMRURfUFJFQ09ORElUSU9OIGFuZFxyXG4gICAgICogT1VUX09GX1JBTkdFLiBXZSByZWNvbW1lbmQgdXNpbmcgT1VUX09GX1JBTkdFICh0aGUgbW9yZSBzcGVjaWZpYyBlcnJvcilcclxuICAgICAqIHdoZW4gaXQgYXBwbGllcyBzbyB0aGF0IGNhbGxlcnMgd2hvIGFyZSBpdGVyYXRpbmcgdGhyb3VnaCBhIHNwYWNlIGNhblxyXG4gICAgICogZWFzaWx5IGxvb2sgZm9yIGFuIE9VVF9PRl9SQU5HRSBlcnJvciB0byBkZXRlY3Qgd2hlbiB0aGV5IGFyZSBkb25lLlxyXG4gICAgICovXHJcbiAgICBPVVRfT0ZfUkFOR0U6ICdvdXQtb2YtcmFuZ2UnLFxyXG4gICAgLyoqIE9wZXJhdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgb3Igbm90IHN1cHBvcnRlZC9lbmFibGVkIGluIHRoaXMgc2VydmljZS4gKi9cclxuICAgIFVOSU1QTEVNRU5URUQ6ICd1bmltcGxlbWVudGVkJyxcclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgZXJyb3JzLiBNZWFucyBzb21lIGludmFyaWFudHMgZXhwZWN0ZWQgYnkgdW5kZXJseWluZyBTeXN0ZW0gaGFzXHJcbiAgICAgKiBiZWVuIGJyb2tlbi4gSWYgeW91IHNlZSBvbmUgb2YgdGhlc2UgZXJyb3JzLCBTb21ldGhpbmcgaXMgdmVyeSBicm9rZW4uXHJcbiAgICAgKi9cclxuICAgIElOVEVSTkFMOiAnaW50ZXJuYWwnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2VydmljZSBpcyBjdXJyZW50bHkgdW5hdmFpbGFibGUuIFRoaXMgaXMgYSBtb3N0IGxpa2VseSBhIHRyYW5zaWVudFxyXG4gICAgICogY29uZGl0aW9uIGFuZCBtYXkgYmUgY29ycmVjdGVkIGJ5IHJldHJ5aW5nIHdpdGggYSBiYWNrb2ZmLlxyXG4gICAgICpcclxuICAgICAqIFNlZSBsaXRtdXMgdGVzdCBhYm92ZSBmb3IgZGVjaWRpbmcgYmV0d2VlbiBGQUlMRURfUFJFQ09ORElUSU9OLCBBQk9SVEVELFxyXG4gICAgICogYW5kIFVOQVZBSUxBQkxFLlxyXG4gICAgICovXHJcbiAgICBVTkFWQUlMQUJMRTogJ3VuYXZhaWxhYmxlJyxcclxuICAgIC8qKiBVbnJlY292ZXJhYmxlIGRhdGEgbG9zcyBvciBjb3JydXB0aW9uLiAqL1xyXG4gICAgREFUQV9MT1NTOiAnZGF0YS1sb3NzJ1xyXG59O1xyXG4vKiogQW4gZXJyb3IgcmV0dXJuZWQgYnkgYSBGaXJlc3RvcmUgb3BlcmF0aW9uLiAqL1xyXG5jbGFzcyBGaXJlc3RvcmVFcnJvciBleHRlbmRzIEZpcmViYXNlRXJyb3Ige1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFja2VuZCBlcnJvciBjb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBjb2RlLCBcclxuICAgIC8qKlxyXG4gICAgICogQSBjdXN0b20gZXJyb3IgZGVzY3JpcHRpb24uXHJcbiAgICAgKi9cclxuICAgIG1lc3NhZ2UpIHtcclxuICAgICAgICBzdXBlcihjb2RlLCBtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgLy8gSEFDSzogV2Ugd3JpdGUgYSB0b1N0cmluZyBwcm9wZXJ0eSBkaXJlY3RseSBiZWNhdXNlIEVycm9yIGlzIG5vdCBhIHJlYWxcclxuICAgICAgICAvLyBjbGFzcyBhbmQgc28gaW5oZXJpdGFuY2UgZG9lcyBub3Qgd29yayBjb3JyZWN0bHkuIFdlIGNvdWxkIGFsdGVybmF0aXZlbHlcclxuICAgICAgICAvLyBkbyB0aGUgc2FtZSBcImJhY2stZG9vciBpbmhlcml0YW5jZVwiIHRyaWNrIHRoYXQgRmlyZWJhc2VFcnJvciBkb2VzLlxyXG4gICAgICAgIHRoaXMudG9TdHJpbmcgPSAoKSA9PiBgJHt0aGlzLm5hbWV9OiBbY29kZT0ke3RoaXMuY29kZX1dOiAke3RoaXMubWVzc2FnZX1gO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIERlZmVycmVkIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgT0F1dGhUb2tlbiB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdXNlcikge1xyXG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ09BdXRoJztcclxuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHt2YWx1ZX1gKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBDcmVkZW50aWFsc1Byb3ZpZGVyIHRoYXQgYWx3YXlzIHlpZWxkcyBhbiBlbXB0eSB0b2tlbi5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBFbXB0eUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIHtcclxuICAgIGdldFRva2VuKCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICB9XHJcbiAgICBpbnZhbGlkYXRlVG9rZW4oKSB7IH1cclxuICAgIHN0YXJ0KGFzeW5jUXVldWUsIGNoYW5nZUxpc3RlbmVyKSB7XHJcbiAgICAgICAgLy8gRmlyZSB3aXRoIGluaXRpYWwgdXNlci5cclxuICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gY2hhbmdlTGlzdGVuZXIoVXNlci5VTkFVVEhFTlRJQ0FURUQpKTtcclxuICAgIH1cclxuICAgIHNodXRkb3duKCkgeyB9XHJcbn1cclxuLyoqXHJcbiAqIEEgQ3JlZGVudGlhbHNQcm92aWRlciB0aGF0IGFsd2F5cyByZXR1cm5zIGEgY29uc3RhbnQgdG9rZW4uIFVzZWQgZm9yXHJcbiAqIGVtdWxhdG9yIHRva2VuIG1vY2tpbmcuXHJcbiAqL1xyXG5jbGFzcyBFbXVsYXRvckF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHRva2VuKSB7XHJcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0b3JlcyB0aGUgbGlzdGVuZXIgcmVnaXN0ZXJlZCB3aXRoIHNldENoYW5nZUxpc3RlbmVyKClcclxuICAgICAgICAgKiBUaGlzIGlzbid0IGFjdHVhbGx5IG5lY2Vzc2FyeSBzaW5jZSB0aGUgVUlEIG5ldmVyIGNoYW5nZXMsIGJ1dCB3ZSB1c2UgdGhpc1xyXG4gICAgICAgICAqIHRvIHZlcmlmeSB0aGUgbGlzdGVuIGNvbnRyYWN0IGlzIGFkaGVyZWQgdG8gaW4gdGVzdHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXRUb2tlbigpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMudG9rZW4pO1xyXG4gICAgfVxyXG4gICAgaW52YWxpZGF0ZVRva2VuKCkgeyB9XHJcbiAgICBzdGFydChhc3luY1F1ZXVlLCBjaGFuZ2VMaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIgPSBjaGFuZ2VMaXN0ZW5lcjtcclxuICAgICAgICAvLyBGaXJlIHdpdGggaW5pdGlhbCB1c2VyLlxyXG4gICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiBjaGFuZ2VMaXN0ZW5lcih0aGlzLnRva2VuLnVzZXIpKTtcclxuICAgIH1cclxuICAgIHNodXRkb3duKCkge1xyXG4gICAgICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIgPSBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKiBDcmVkZW50aWFsIHByb3ZpZGVyIGZvciB0aGUgTGl0ZSBTREsuICovXHJcbmNsYXNzIExpdGVBdXRoQ3JlZGVudGlhbHNQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhdXRoUHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLmF1dGggPSBudWxsO1xyXG4gICAgICAgIGF1dGhQcm92aWRlci5vbkluaXQoYXV0aCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRUb2tlbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYXV0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRoLmdldFRva2VuKCkudGhlbih0b2tlbkRhdGEgPT4ge1xyXG4gICAgICAgICAgICBpZiAodG9rZW5EYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KHR5cGVvZiB0b2tlbkRhdGEuYWNjZXNzVG9rZW4gPT09ICdzdHJpbmcnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT0F1dGhUb2tlbih0b2tlbkRhdGEuYWNjZXNzVG9rZW4sIG5ldyBVc2VyKHRoaXMuYXV0aC5nZXRVaWQoKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGludmFsaWRhdGVUb2tlbigpIHsgfVxyXG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHsgfVxyXG4gICAgc2h1dGRvd24oKSB7IH1cclxufVxyXG4vKlxyXG4gKiBGaXJzdFBhcnR5VG9rZW4gcHJvdmlkZXMgYSBmcmVzaCB0b2tlbiBlYWNoIHRpbWUgaXRzIHZhbHVlXHJcbiAqIGlzIHJlcXVlc3RlZCwgYmVjYXVzZSBpZiB0aGUgdG9rZW4gaXMgdG9vIG9sZCwgcmVxdWVzdHMgd2lsbCBiZSByZWplY3RlZC5cclxuICogVGVjaG5pY2FsbHkgdGhpcyBtYXkgbm8gbG9uZ2VyIGJlIG5lY2Vzc2FyeSBzaW5jZSB0aGUgU0RLIHNob3VsZCBncmFjZWZ1bGx5XHJcbiAqIHJlY292ZXIgZnJvbSB1bmF1dGhlbnRpY2F0ZWQgZXJyb3JzIChzZWUgYi8zMzE0NzgxOCBmb3IgY29udGV4dCksIGJ1dCBpdCdzXHJcbiAqIHNhZmVyIHRvIGtlZXAgdGhlIGltcGxlbWVudGF0aW9uIGFzLWlzLlxyXG4gKi9cclxuY2xhc3MgRmlyc3RQYXJ0eVRva2VuIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlc3Npb25JbmRleCwgaWFtVG9rZW4sIGF1dGhUb2tlbkZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLnNlc3Npb25JbmRleCA9IHNlc3Npb25JbmRleDtcclxuICAgICAgICB0aGlzLmlhbVRva2VuID0gaWFtVG9rZW47XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5GYWN0b3J5ID0gYXV0aFRva2VuRmFjdG9yeTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnRmlyc3RQYXJ0eSc7XHJcbiAgICAgICAgdGhpcy51c2VyID0gVXNlci5GSVJTVF9QQVJUWTtcclxuICAgICAgICB0aGlzLl9oZWFkZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFuIGF1dGhvcml6YXRpb24gdG9rZW4sIHVzaW5nIGEgcHJvdmlkZWQgZmFjdG9yeSBmdW5jdGlvbiwgb3IgcmV0dXJuXHJcbiAgICAgKiBudWxsLlxyXG4gICAgICovXHJcbiAgICBnZXRBdXRoVG9rZW4oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuRmFjdG9yeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRoVG9rZW5GYWN0b3J5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgaGVhZGVycygpIHtcclxuICAgICAgICB0aGlzLl9oZWFkZXJzLnNldCgnWC1Hb29nLUF1dGhVc2VyJywgdGhpcy5zZXNzaW9uSW5kZXgpO1xyXG4gICAgICAgIC8vIFVzZSBhcnJheSBub3RhdGlvbiB0byBwcmV2ZW50IG1pbmlmaWNhdGlvblxyXG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXJUb2tlblZhbHVlID0gdGhpcy5nZXRBdXRoVG9rZW4oKTtcclxuICAgICAgICBpZiAoYXV0aEhlYWRlclRva2VuVmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5faGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBhdXRoSGVhZGVyVG9rZW5WYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlhbVRva2VuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdYLUdvb2ctSWFtLUF1dGhvcml6YXRpb24tVG9rZW4nLCB0aGlzLmlhbVRva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcnM7XHJcbiAgICB9XHJcbn1cclxuLypcclxuICogUHJvdmlkZXMgdXNlciBjcmVkZW50aWFscyByZXF1aXJlZCBmb3IgdGhlIEZpcmVzdG9yZSBKYXZhU2NyaXB0IFNES1xyXG4gKiB0byBhdXRoZW50aWNhdGUgdGhlIHVzZXIsIHVzaW5nIHRlY2huaXF1ZSB0aGF0IGlzIG9ubHkgYXZhaWxhYmxlXHJcbiAqIHRvIGFwcGxpY2F0aW9ucyBob3N0ZWQgYnkgR29vZ2xlLlxyXG4gKi9cclxuY2xhc3MgRmlyc3RQYXJ0eUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlc3Npb25JbmRleCwgaWFtVG9rZW4sIGF1dGhUb2tlbkZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLnNlc3Npb25JbmRleCA9IHNlc3Npb25JbmRleDtcclxuICAgICAgICB0aGlzLmlhbVRva2VuID0gaWFtVG9rZW47XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5GYWN0b3J5ID0gYXV0aFRva2VuRmFjdG9yeTtcclxuICAgIH1cclxuICAgIGdldFRva2VuKCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEZpcnN0UGFydHlUb2tlbih0aGlzLnNlc3Npb25JbmRleCwgdGhpcy5pYW1Ub2tlbiwgdGhpcy5hdXRoVG9rZW5GYWN0b3J5KSk7XHJcbiAgICB9XHJcbiAgICBzdGFydChhc3luY1F1ZXVlLCBjaGFuZ2VMaXN0ZW5lcikge1xyXG4gICAgICAgIC8vIEZpcmUgd2l0aCBpbml0aWFsIHVpZC5cclxuICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gY2hhbmdlTGlzdGVuZXIoVXNlci5GSVJTVF9QQVJUWSkpO1xyXG4gICAgfVxyXG4gICAgc2h1dGRvd24oKSB7IH1cclxuICAgIGludmFsaWRhdGVUb2tlbigpIHsgfVxyXG59XHJcbmNsYXNzIEFwcENoZWNrVG9rZW4ge1xyXG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ0FwcENoZWNrJztcclxuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgneC1maXJlYmFzZS1hcHBjaGVjaycsIHRoaXMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKiogQXBwQ2hlY2sgdG9rZW4gcHJvdmlkZXIgZm9yIHRoZSBMaXRlIFNESy4gKi9cclxuY2xhc3MgTGl0ZUFwcENoZWNrVG9rZW5Qcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHBDaGVja1Byb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Byb3ZpZGVyID0gYXBwQ2hlY2tQcm92aWRlcjtcclxuICAgICAgICB0aGlzLmFwcENoZWNrID0gbnVsbDtcclxuICAgICAgICBhcHBDaGVja1Byb3ZpZGVyLm9uSW5pdChhcHBDaGVjayA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2sgPSBhcHBDaGVjaztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFRva2VuKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5hcHBDaGVjaykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBDaGVjay5nZXRUb2tlbigpLnRoZW4odG9rZW5SZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICBpZiAodG9rZW5SZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIHRva2VuUmVzdWx0LnRva2VuID09PSAnc3RyaW5nJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFwcENoZWNrVG9rZW4odG9rZW5SZXN1bHQudG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGludmFsaWRhdGVUb2tlbigpIHsgfVxyXG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHsgfVxyXG4gICAgc2h1dGRvd24oKSB7IH1cclxufVxyXG4vKipcclxuICogQnVpbGRzIGEgQ3JlZGVudGlhbHNQcm92aWRlciBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2ZcclxuICogdGhlIGNyZWRlbnRpYWxzIHBhc3NlZCBpbi5cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlcihjcmVkZW50aWFscykge1xyXG4gICAgaWYgKCFjcmVkZW50aWFscykge1xyXG4gICAgICAgIHJldHVybiBuZXcgRW1wdHlBdXRoQ3JlZGVudGlhbHNQcm92aWRlcigpO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChjcmVkZW50aWFsc1sndHlwZSddKSB7XHJcbiAgICAgICAgY2FzZSAnZmlyc3RQYXJ0eSc6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmlyc3RQYXJ0eUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKGNyZWRlbnRpYWxzWydzZXNzaW9uSW5kZXgnXSB8fCAnMCcsIGNyZWRlbnRpYWxzWydpYW1Ub2tlbiddIHx8IG51bGwsIGNyZWRlbnRpYWxzWydhdXRoVG9rZW5GYWN0b3J5J10gfHwgbnVsbCk7XHJcbiAgICAgICAgY2FzZSAncHJvdmlkZXInOlxyXG4gICAgICAgICAgICByZXR1cm4gY3JlZGVudGlhbHNbJ2NsaWVudCddO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdtYWtlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXIgZmFpbGVkIGR1ZSB0byBpbnZhbGlkIGNyZWRlbnRpYWwgdHlwZScpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIERhdGFiYXNlSW5mbyB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBEYXRhYmFzZUluZm8gdXNpbmcgdGhlIHByb3ZpZGVkIGhvc3QsIGRhdGFiYXNlSWQgYW5kXHJcbiAgICAgKiBwZXJzaXN0ZW5jZUtleS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGF0YWJhc2VJZCAtIFRoZSBkYXRhYmFzZSB0byB1c2UuXHJcbiAgICAgKiBAcGFyYW0gYXBwSWQgLSBUaGUgRmlyZWJhc2UgQXBwIElkLlxyXG4gICAgICogQHBhcmFtIHBlcnNpc3RlbmNlS2V5IC0gQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBGaXJlc3RvcmUncyBsb2NhbFxyXG4gICAgICogc3RvcmFnZSAodXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBkYXRhYmFzZUlkKS5cclxuICAgICAqIEBwYXJhbSBob3N0IC0gVGhlIEZpcmVzdG9yZSBiYWNrZW5kIGhvc3QgdG8gY29ubmVjdCB0by5cclxuICAgICAqIEBwYXJhbSBzc2wgLSBXaGV0aGVyIHRvIHVzZSBTU0wgd2hlbiBjb25uZWN0aW5nLlxyXG4gICAgICogQHBhcmFtIGZvcmNlTG9uZ1BvbGxpbmcgLSBXaGV0aGVyIHRvIHVzZSB0aGUgZm9yY2VMb25nUG9sbGluZyBvcHRpb25cclxuICAgICAqIHdoZW4gdXNpbmcgV2ViQ2hhbm5lbCBhcyB0aGUgbmV0d29yayB0cmFuc3BvcnQuXHJcbiAgICAgKiBAcGFyYW0gYXV0b0RldGVjdExvbmdQb2xsaW5nIC0gV2hldGhlciB0byB1c2UgdGhlIGRldGVjdEJ1ZmZlcmluZ1Byb3h5XHJcbiAgICAgKiBvcHRpb24gd2hlbiB1c2luZyBXZWJDaGFubmVsIGFzIHRoZSBuZXR3b3JrIHRyYW5zcG9ydC5cclxuICAgICAqIEBwYXJhbSBsb25nUG9sbGluZ09wdGlvbnMgT3B0aW9ucyB0aGF0IGNvbmZpZ3VyZSBsb25nLXBvbGxpbmcuXHJcbiAgICAgKiBAcGFyYW0gdXNlRmV0Y2hTdHJlYW1zIFdoZXRoZXIgdG8gdXNlIHRoZSBGZXRjaCBBUEkgaW5zdGVhZCBvZlxyXG4gICAgICogWE1MSFRUUFJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZGF0YWJhc2VJZCwgYXBwSWQsIHBlcnNpc3RlbmNlS2V5LCBob3N0LCBzc2wsIGZvcmNlTG9uZ1BvbGxpbmcsIGF1dG9EZXRlY3RMb25nUG9sbGluZywgbG9uZ1BvbGxpbmdPcHRpb25zLCB1c2VGZXRjaFN0cmVhbXMpIHtcclxuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBkYXRhYmFzZUlkO1xyXG4gICAgICAgIHRoaXMuYXBwSWQgPSBhcHBJZDtcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlS2V5ID0gcGVyc2lzdGVuY2VLZXk7XHJcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcclxuICAgICAgICB0aGlzLnNzbCA9IHNzbDtcclxuICAgICAgICB0aGlzLmZvcmNlTG9uZ1BvbGxpbmcgPSBmb3JjZUxvbmdQb2xsaW5nO1xyXG4gICAgICAgIHRoaXMuYXV0b0RldGVjdExvbmdQb2xsaW5nID0gYXV0b0RldGVjdExvbmdQb2xsaW5nO1xyXG4gICAgICAgIHRoaXMubG9uZ1BvbGxpbmdPcHRpb25zID0gbG9uZ1BvbGxpbmdPcHRpb25zO1xyXG4gICAgICAgIHRoaXMudXNlRmV0Y2hTdHJlYW1zID0gdXNlRmV0Y2hTdHJlYW1zO1xyXG4gICAgfVxyXG59XHJcbi8qKiBUaGUgZGVmYXVsdCBkYXRhYmFzZSBuYW1lIGZvciBhIHByb2plY3QuICovXHJcbmNvbnN0IERFRkFVTFRfREFUQUJBU0VfTkFNRSA9ICcoZGVmYXVsdCknO1xyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgZGF0YWJhc2UgSUQgYSBGaXJlc3RvcmUgY2xpZW50IGlzIGFzc29jaWF0ZWQgd2l0aC5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBEYXRhYmFzZUlkIHtcclxuICAgIGNvbnN0cnVjdG9yKHByb2plY3RJZCwgZGF0YWJhc2UpIHtcclxuICAgICAgICB0aGlzLnByb2plY3RJZCA9IHByb2plY3RJZDtcclxuICAgICAgICB0aGlzLmRhdGFiYXNlID0gZGF0YWJhc2UgPyBkYXRhYmFzZSA6IERFRkFVTFRfREFUQUJBU0VfTkFNRTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGFiYXNlSWQoJycsICcnKTtcclxuICAgIH1cclxuICAgIGdldCBpc0RlZmF1bHREYXRhYmFzZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhYmFzZSA9PT0gREVGQVVMVF9EQVRBQkFTRV9OQU1FO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBEYXRhYmFzZUlkICYmXHJcbiAgICAgICAgICAgIG90aGVyLnByb2plY3RJZCA9PT0gdGhpcy5wcm9qZWN0SWQgJiZcclxuICAgICAgICAgICAgb3RoZXIuZGF0YWJhc2UgPT09IHRoaXMuZGF0YWJhc2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRhdGFiYXNlSWRGcm9tQXBwKGFwcCwgZGF0YWJhc2UpIHtcclxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5hcHBseShhcHAub3B0aW9ucywgWydwcm9qZWN0SWQnXSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnXCJwcm9qZWN0SWRcIiBub3QgcHJvdmlkZWQgaW4gZmlyZWJhc2UuaW5pdGlhbGl6ZUFwcC4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgRGF0YWJhc2VJZChhcHAub3B0aW9ucy5wcm9qZWN0SWQsIGRhdGFiYXNlKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBET0NVTUVOVF9LRVlfTkFNRSA9ICdfX25hbWVfXyc7XHJcbi8qKlxyXG4gKiBQYXRoIHJlcHJlc2VudHMgYW4gb3JkZXJlZCBzZXF1ZW5jZSBvZiBzdHJpbmcgc2VnbWVudHMuXHJcbiAqL1xyXG5jbGFzcyBCYXNlUGF0aCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZWdtZW50cywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob2Zmc2V0ID4gc2VnbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCAtIG9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoID4gc2VnbWVudHMubGVuZ3RoIC0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWdtZW50cyA9IHNlZ21lbnRzO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIHRoaXMubGVuID0gbGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZW47XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIEJhc2VQYXRoLmNvbXBhcmF0b3IodGhpcywgb3RoZXIpID09PSAwO1xyXG4gICAgfVxyXG4gICAgY2hpbGQobmFtZU9yUGF0aCkge1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cy5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5saW1pdCgpKTtcclxuICAgICAgICBpZiAobmFtZU9yUGF0aCBpbnN0YW5jZW9mIEJhc2VQYXRoKSB7XHJcbiAgICAgICAgICAgIG5hbWVPclBhdGguZm9yRWFjaChzZWdtZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2VnbWVudHMucHVzaChuYW1lT3JQYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0KHNlZ21lbnRzKTtcclxuICAgIH1cclxuICAgIC8qKiBUaGUgaW5kZXggb2Ygb25lIHBhc3QgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgcGF0aC4gKi9cclxuICAgIGxpbWl0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldCArIHRoaXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgcG9wRmlyc3Qoc2l6ZSkge1xyXG4gICAgICAgIHNpemUgPSBzaXplID09PSB1bmRlZmluZWQgPyAxIDogc2l6ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3QodGhpcy5zZWdtZW50cywgdGhpcy5vZmZzZXQgKyBzaXplLCB0aGlzLmxlbmd0aCAtIHNpemUpO1xyXG4gICAgfVxyXG4gICAgcG9wTGFzdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3QodGhpcy5zZWdtZW50cywgdGhpcy5vZmZzZXQsIHRoaXMubGVuZ3RoIC0gMSk7XHJcbiAgICB9XHJcbiAgICBmaXJzdFNlZ21lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudHNbdGhpcy5vZmZzZXRdO1xyXG4gICAgfVxyXG4gICAgbGFzdFNlZ21lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMubGVuZ3RoIC0gMSk7XHJcbiAgICB9XHJcbiAgICBnZXQoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWdtZW50c1t0aGlzLm9mZnNldCArIGluZGV4XTtcclxuICAgIH1cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG4gICAgaXNQcmVmaXhPZihvdGhlcikge1xyXG4gICAgICAgIGlmIChvdGhlci5sZW5ndGggPCB0aGlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoaSkgIT09IG90aGVyLmdldChpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaXNJbW1lZGlhdGVQYXJlbnRPZihwb3RlbnRpYWxDaGlsZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCArIDEgIT09IHBvdGVudGlhbENoaWxkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoaSkgIT09IHBvdGVudGlhbENoaWxkLmdldChpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZm9yRWFjaChmbikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLm9mZnNldCwgZW5kID0gdGhpcy5saW1pdCgpOyBpIDwgZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgZm4odGhpcy5zZWdtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9BcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWdtZW50cy5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5saW1pdCgpKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjb21wYXJhdG9yKHAxLCBwMikge1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKHAxLmxlbmd0aCwgcDIubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBwMS5nZXQoaSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gcDIuZ2V0KGkpO1xyXG4gICAgICAgICAgICBpZiAobGVmdCA8IHJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxlZnQgPiByaWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAxLmxlbmd0aCA8IHAyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwMS5sZW5ndGggPiBwMi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIHNsYXNoLXNlcGFyYXRlZCBwYXRoIGZvciBuYXZpZ2F0aW5nIHJlc291cmNlcyAoZG9jdW1lbnRzIGFuZCBjb2xsZWN0aW9ucylcclxuICogd2l0aGluIEZpcmVzdG9yZS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBSZXNvdXJjZVBhdGggZXh0ZW5kcyBCYXNlUGF0aCB7XHJcbiAgICBjb25zdHJ1Y3Qoc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBhdGgoc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGNhbm9uaWNhbFN0cmluZygpIHtcclxuICAgICAgICAvLyBOT1RFOiBUaGUgY2xpZW50IGlzIGlnbm9yYW50IG9mIGFueSBwYXRoIHNlZ21lbnRzIGNvbnRhaW5pbmcgZXNjYXBlXHJcbiAgICAgICAgLy8gc2VxdWVuY2VzIChlLmcuIF9faWQxMjNfXykgYW5kIGp1c3QgcGFzc2VzIHRoZW0gdGhyb3VnaCByYXcgKHRoZXkgZXhpc3RcclxuICAgICAgICAvLyBmb3IgbGVnYWN5IHJlYXNvbnMgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBmcmVxdWVudGx5KS5cclxuICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuam9pbignLycpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwYXRoXHJcbiAgICAgKiB3aGVyZSBlYWNoIHBhdGggc2VnbWVudCBoYXMgYmVlbiBlbmNvZGVkIHdpdGhcclxuICAgICAqIGBlbmNvZGVVUklDb21wb25lbnRgLlxyXG4gICAgICovXHJcbiAgICB0b1VyaUVuY29kZWRTdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLm1hcChlbmNvZGVVUklDb21wb25lbnQpLmpvaW4oJy8nKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHJlc291cmNlIHBhdGggZnJvbSB0aGUgZ2l2ZW4gc2xhc2gtZGVsaW1pdGVkIHN0cmluZy4gSWYgbXVsdGlwbGVcclxuICAgICAqIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIGFsbCBjb21wb25lbnRzIGFyZSBjb21iaW5lZC4gTGVhZGluZyBhbmQgdHJhaWxpbmdcclxuICAgICAqIHNsYXNoZXMgZnJvbSBhbGwgY29tcG9uZW50cyBhcmUgaWdub3JlZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21TdHJpbmcoLi4ucGF0aENvbXBvbmVudHMpIHtcclxuICAgICAgICAvLyBOT1RFOiBUaGUgY2xpZW50IGlzIGlnbm9yYW50IG9mIGFueSBwYXRoIHNlZ21lbnRzIGNvbnRhaW5pbmcgZXNjYXBlXHJcbiAgICAgICAgLy8gc2VxdWVuY2VzIChlLmcuIF9faWQxMjNfXykgYW5kIGp1c3QgcGFzc2VzIHRoZW0gdGhyb3VnaCByYXcgKHRoZXkgZXhpc3RcclxuICAgICAgICAvLyBmb3IgbGVnYWN5IHJlYXNvbnMgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBmcmVxdWVudGx5KS5cclxuICAgICAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRoQ29tcG9uZW50cykge1xyXG4gICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKCcvLycpID49IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHNlZ21lbnQgKCR7cGF0aH0pLiBQYXRocyBtdXN0IG5vdCBjb250YWluIC8vIGluIHRoZW0uYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyBhbmQgdHJhbGluZyBzbGFzaGVkLlxyXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKC4uLnBhdGguc3BsaXQoJy8nKS5maWx0ZXIoc2VnbWVudCA9PiBzZWdtZW50Lmxlbmd0aCA+IDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBhdGgoc2VnbWVudHMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGVtcHR5UGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlUGF0aChbXSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgaWRlbnRpZmllclJlZ0V4cCA9IC9eW19hLXpBLVpdW19hLXpBLVowLTldKiQvO1xyXG4vKipcclxuICogQSBkb3Qtc2VwYXJhdGVkIHBhdGggZm9yIG5hdmlnYXRpbmcgc3ViLW9iamVjdHMgd2l0aGluIGEgZG9jdW1lbnQuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgRmllbGRQYXRoJDEgZXh0ZW5kcyBCYXNlUGF0aCB7XHJcbiAgICBjb25zdHJ1Y3Qoc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgkMShzZWdtZW50cywgb2Zmc2V0LCBsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBjb3VsZCBiZSB1c2VkIGFzIGEgc2VnbWVudCBpbiBhIGZpZWxkIHBhdGhcclxuICAgICAqIHdpdGhvdXQgZXNjYXBpbmcuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc1ZhbGlkSWRlbnRpZmllcihzZWdtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXJSZWdFeHAudGVzdChzZWdtZW50KTtcclxuICAgIH1cclxuICAgIGNhbm9uaWNhbFN0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5KClcclxuICAgICAgICAgICAgLm1hcChzdHIgPT4ge1xyXG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9gL2csICdcXFxcYCcpO1xyXG4gICAgICAgICAgICBpZiAoIUZpZWxkUGF0aCQxLmlzVmFsaWRJZGVudGlmaWVyKHN0cikpIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9ICdgJyArIHN0ciArICdgJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5qb2luKCcuJyk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW5vbmljYWxTdHJpbmcoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZmllbGQgcmVmZXJlbmNlcyB0aGUga2V5IG9mIGEgZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGlzS2V5RmllbGQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMuZ2V0KDApID09PSBET0NVTUVOVF9LRVlfTkFNRTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZpZWxkIGRlc2lnbmF0aW5nIHRoZSBrZXkgb2YgYSBkb2N1bWVudC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGtleUZpZWxkKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRQYXRoJDEoW0RPQ1VNRU5UX0tFWV9OQU1FXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBhIGZpZWxkIHN0cmluZyBmcm9tIHRoZSBnaXZlbiBzZXJ2ZXItZm9ybWF0dGVkIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiAtIFNwbGl0dGluZyB0aGUgZW1wdHkgc3RyaW5nIGlzIG5vdCBhbGxvd2VkIChmb3Igbm93IGF0IGxlYXN0KS5cclxuICAgICAqIC0gRW1wdHkgc2VnbWVudHMgd2l0aGluIHRoZSBzdHJpbmcgKGUuZy4gaWYgdGhlcmUgYXJlIHR3byBjb25zZWN1dGl2ZVxyXG4gICAgICogICBzZXBhcmF0b3JzKSBhcmUgbm90IGFsbG93ZWQuXHJcbiAgICAgKlxyXG4gICAgICogVE9ETyhiLzM3MjQ0MTU3KTogd2Ugc2hvdWxkIG1ha2UgdGhpcyBtb3JlIHN0cmljdC4gUmlnaHQgbm93LCBpdCBhbGxvd3NcclxuICAgICAqIG5vbi1pZGVudGlmaWVyIHBhdGggY29tcG9uZW50cywgZXZlbiBpZiB0aGV5IGFyZW4ndCBlc2NhcGVkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVNlcnZlckZvcm1hdChwYXRoKSB7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcclxuICAgICAgICBsZXQgY3VycmVudCA9ICcnO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBjb25zdCBhZGRDdXJyZW50U2VnbWVudCA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBmaWVsZCBwYXRoICgke3BhdGh9KS4gUGF0aHMgbXVzdCBub3QgYmUgZW1wdHksIGJlZ2luIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGB3aXRoICcuJywgZW5kIHdpdGggJy4nLCBvciBjb250YWluICcuLidgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gJyc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgaW5CYWNrdGlja3MgPSBmYWxzZTtcclxuICAgICAgICB3aGlsZSAoaSA8IHBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBwYXRoW2ldO1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPT09IHBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1BhdGggaGFzIHRyYWlsaW5nIGVzY2FwZSBjaGFyYWN0ZXI6ICcgKyBwYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwYXRoW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIGlmICghKG5leHQgPT09ICdcXFxcJyB8fCBuZXh0ID09PSAnLicgfHwgbmV4dCA9PT0gJ2AnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdQYXRoIGhhcyBpbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZTogJyArIHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCArPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICdgJykge1xyXG4gICAgICAgICAgICAgICAgaW5CYWNrdGlja3MgPSAhaW5CYWNrdGlja3M7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJy4nICYmICFpbkJhY2t0aWNrcykge1xyXG4gICAgICAgICAgICAgICAgYWRkQ3VycmVudFNlZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRDdXJyZW50U2VnbWVudCgpO1xyXG4gICAgICAgIGlmIChpbkJhY2t0aWNrcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVW50ZXJtaW5hdGVkIGAgaW4gcGF0aDogJyArIHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEZpZWxkUGF0aCQxKHNlZ21lbnRzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbXB0eVBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgkMShbXSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgRG9jdW1lbnRLZXkge1xyXG4gICAgY29uc3RydWN0b3IocGF0aCkge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVBhdGgocGF0aCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRLZXkoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21OYW1lKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKG5hbWUpLnBvcEZpcnN0KDUpKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KFJlc291cmNlUGF0aC5lbXB0eVBhdGgoKSk7XHJcbiAgICB9XHJcbiAgICBnZXQgY29sbGVjdGlvbkdyb3VwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgucG9wTGFzdCgpLmxhc3RTZWdtZW50KCk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBkb2N1bWVudCBpcyBpbiB0aGUgc3BlY2lmaWVkIGNvbGxlY3Rpb25JZC4gKi9cclxuICAgIGhhc0NvbGxlY3Rpb25JZChjb2xsZWN0aW9uSWQpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMucGF0aC5sZW5ndGggPj0gMiAmJlxyXG4gICAgICAgICAgICB0aGlzLnBhdGguZ2V0KHRoaXMucGF0aC5sZW5ndGggLSAyKSA9PT0gY29sbGVjdGlvbklkKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIGdyb3VwIChpLmUuIHRoZSBuYW1lIG9mIHRoZSBwYXJlbnQgY29sbGVjdGlvbikgZm9yIHRoaXMga2V5LiAqL1xyXG4gICAgZ2V0Q29sbGVjdGlvbkdyb3VwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGguZ2V0KHRoaXMucGF0aC5sZW5ndGggLSAyKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHRoZSBmdWxseSBxdWFsaWZpZWQgcGF0aCB0byB0aGUgcGFyZW50IGNvbGxlY3Rpb24uICovXHJcbiAgICBnZXRDb2xsZWN0aW9uUGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLnBvcExhc3QoKTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKG90aGVyICE9PSBudWxsICYmIFJlc291cmNlUGF0aC5jb21wYXJhdG9yKHRoaXMucGF0aCwgb3RoZXIucGF0aCkgPT09IDApO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNvbXBhcmF0b3IoazEsIGsyKSB7XHJcbiAgICAgICAgcmV0dXJuIFJlc291cmNlUGF0aC5jb21wYXJhdG9yKGsxLnBhdGgsIGsyLnBhdGgpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGlzRG9jdW1lbnRLZXkocGF0aCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCAlIDIgPT09IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgZG9jdW1lbnQga2V5IHdpdGggdGhlIGdpdmVuIHNlZ21lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZWdtZW50cyAtIFRoZSBzZWdtZW50cyBvZiB0aGUgcGF0aCB0byB0aGUgZG9jdW1lbnRcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluc3RhbmNlIG9mIERvY3VtZW50S2V5XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tU2VnbWVudHMoc2VnbWVudHMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KG5ldyBSZXNvdXJjZVBhdGgoc2VnbWVudHMuc2xpY2UoKSkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlTm9uRW1wdHlBcmd1bWVudChmdW5jdGlvbk5hbWUsIGFyZ3VtZW50TmFtZSwgYXJndW1lbnQpIHtcclxuICAgIGlmICghYXJndW1lbnQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9KCkgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5ICR7YXJndW1lbnROYW1lfS5gKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgdHdvIGJvb2xlYW4gb3B0aW9ucyBhcmUgbm90IHNldCBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlSXNOb3RVc2VkVG9nZXRoZXIob3B0aW9uTmFtZTEsIGFyZ3VtZW50MSwgb3B0aW9uTmFtZTIsIGFyZ3VtZW50Mikge1xyXG4gICAgaWYgKGFyZ3VtZW50MSA9PT0gdHJ1ZSAmJiBhcmd1bWVudDIgPT09IHRydWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgJHtvcHRpb25OYW1lMX0gYW5kICR7b3B0aW9uTmFtZTJ9IGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyLmApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgdGhhdCBgcGF0aGAgcmVmZXJzIHRvIGEgZG9jdW1lbnQgKGluZGljYXRlZCBieSB0aGUgZmFjdCBpdCBjb250YWluc1xyXG4gKiBhbiBldmVuIG51bWJlcnMgb2Ygc2VnbWVudHMpLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVEb2N1bWVudFBhdGgocGF0aCkge1xyXG4gICAgaWYgKCFEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHBhdGgpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgZG9jdW1lbnQgcmVmZXJlbmNlLiBEb2N1bWVudCByZWZlcmVuY2VzIG11c3QgaGF2ZSBhbiBldmVuIG51bWJlciBvZiBzZWdtZW50cywgYnV0ICR7cGF0aH0gaGFzICR7cGF0aC5sZW5ndGh9LmApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgdGhhdCBgcGF0aGAgcmVmZXJzIHRvIGEgY29sbGVjdGlvbiAoaW5kaWNhdGVkIGJ5IHRoZSBmYWN0IGl0XHJcbiAqIGNvbnRhaW5zIGFuIG9kZCBudW1iZXJzIG9mIHNlZ21lbnRzKS5cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ29sbGVjdGlvblBhdGgocGF0aCkge1xyXG4gICAgaWYgKERvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkocGF0aCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBjb2xsZWN0aW9uIHJlZmVyZW5jZS4gQ29sbGVjdGlvbiByZWZlcmVuY2VzIG11c3QgaGF2ZSBhbiBvZGQgbnVtYmVyIG9mIHNlZ21lbnRzLCBidXQgJHtwYXRofSBoYXMgJHtwYXRoLmxlbmd0aH0uYCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBpdCdzIGEgbm9uLW51bGwgb2JqZWN0IHdpdGhvdXQgYSBjdXN0b20gcHJvdG90eXBlXHJcbiAqIChpLmUuIGV4Y2x1ZGVzIEFycmF5LCBEYXRlLCBldGMuKS5cclxuICovXHJcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoaW5wdXQpIHtcclxuICAgIHJldHVybiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgIGlucHV0ICE9PSBudWxsICYmXHJcbiAgICAgICAgKE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnB1dCkgPT09IE9iamVjdC5wcm90b3R5cGUgfHxcclxuICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKGlucHV0KSA9PT0gbnVsbCkpO1xyXG59XHJcbi8qKiBSZXR1cm5zIGEgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIHR5cGUgLyB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQgaW5wdXQuICovXHJcbmZ1bmN0aW9uIHZhbHVlRGVzY3JpcHRpb24oaW5wdXQpIHtcclxuICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaW5wdXQgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gJ251bGwnO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmIChpbnB1dC5sZW5ndGggPiAyMCkge1xyXG4gICAgICAgICAgICBpbnB1dCA9IGAke2lucHV0LnN1YnN0cmluZygwLCAyMCl9Li4uYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGlucHV0KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGlucHV0ID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICByZXR1cm4gJycgKyBpbnB1dDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2FuIGFycmF5JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbU9iamVjdE5hbWUgPSB0cnlHZXRDdXN0b21PYmplY3RUeXBlKGlucHV0KTtcclxuICAgICAgICAgICAgaWYgKGN1c3RvbU9iamVjdE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgYSBjdXN0b20gJHtjdXN0b21PYmplY3ROYW1lfSBvYmplY3RgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdhbiBvYmplY3QnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuICdhIGZ1bmN0aW9uJztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqIHRyeSB0byBnZXQgdGhlIGNvbnN0cnVjdG9yIG5hbWUgZm9yIGFuIG9iamVjdC4gKi9cclxuZnVuY3Rpb24gdHJ5R2V0Q3VzdG9tT2JqZWN0VHlwZShpbnB1dCkge1xyXG4gICAgaWYgKGlucHV0LmNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0LmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vKipcclxuICogQ2FzdHMgYG9iamAgdG8gYFRgLCBvcHRpb25hbGx5IHVud3JhcHBpbmcgQ29tcGF0IHR5cGVzIHRvIGV4cG9zZSB0aGVcclxuICogdW5kZXJseWluZyBpbnN0YW5jZS4gVGhyb3dzIGlmICBgb2JqYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYFRgLlxyXG4gKlxyXG4gKiBUaGlzIGNhc3QgaXMgdXNlZCBpbiB0aGUgTGl0ZSBhbmQgRnVsbCBTREsgdG8gdmVyaWZ5IGluc3RhbmNlIHR5cGVzIGZvclxyXG4gKiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBwdWJsaWMgQVBJLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGNhc3Qob2JqLCBcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuY29uc3RydWN0b3IpIHtcclxuICAgIGlmICgnX2RlbGVnYXRlJyBpbiBvYmopIHtcclxuICAgICAgICAvLyBVbndyYXAgQ29tcGF0IHR5cGVzXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICBvYmogPSBvYmouX2RlbGVnYXRlO1xyXG4gICAgfVxyXG4gICAgaWYgKCEob2JqIGluc3RhbmNlb2YgY29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yLm5hbWUgPT09IG9iai5jb25zdHJ1Y3Rvci5uYW1lKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdUeXBlIGRvZXMgbm90IG1hdGNoIHRoZSBleHBlY3RlZCBpbnN0YW5jZS4gRGlkIHlvdSBwYXNzIGEgJyArXHJcbiAgICAgICAgICAgICAgICBgcmVmZXJlbmNlIGZyb20gYSBkaWZmZXJlbnQgRmlyZXN0b3JlIFNESz9gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsdWVEZXNjcmlwdGlvbihvYmopO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRXhwZWN0ZWQgdHlwZSAnJHtjb25zdHJ1Y3Rvci5uYW1lfScsIGJ1dCBpdCB3YXM6ICR7ZGVzY3JpcHRpb259YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iajtcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVBvc2l0aXZlTnVtYmVyKGZ1bmN0aW9uTmFtZSwgbikge1xyXG4gICAgaWYgKG4gPD0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBGdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0oKSByZXF1aXJlcyBhIHBvc2l0aXZlIG51bWJlciwgYnV0IGl0IHdhczogJHtufS5gKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29tcGFyZXMgdHdvIGBFeHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnNgIG9iamVjdHMgZm9yIGVxdWFsaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gbG9uZ1BvbGxpbmdPcHRpb25zRXF1YWwob3B0aW9uczEsIG9wdGlvbnMyKSB7XHJcbiAgICByZXR1cm4gb3B0aW9uczEudGltZW91dFNlY29uZHMgPT09IG9wdGlvbnMyLnRpbWVvdXRTZWNvbmRzO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IGBFeHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnNgIHdpdGggdGhlIHNhbWVcclxuICogb3B0aW9uIHZhbHVlcyBhcyB0aGUgZ2l2ZW4gaW5zdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjbG9uZUxvbmdQb2xsaW5nT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICBjb25zdCBjbG9uZSA9IHt9O1xyXG4gICAgaWYgKG9wdGlvbnMudGltZW91dFNlY29uZHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNsb25lLnRpbWVvdXRTZWNvbmRzID0gb3B0aW9ucy50aW1lb3V0U2Vjb25kcztcclxuICAgIH1cclxuICAgIHJldHVybiBjbG9uZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIG1vc3QgcmVjZW50IGludm9jYXRpb24gb2ZcclxuICogYGdlbmVyYXRlVW5pcXVlRGVidWdJZCgpYCwgb3IgbnVsbCBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBpbnZva2VkLlxyXG4gKi9cclxubGV0IGxhc3RVbmlxdWVEZWJ1Z0lkID0gbnVsbDtcclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyBhbiBpbml0aWFsIHZhbHVlIGZvciBgbGFzdFVuaXF1ZURlYnVnSWRgLlxyXG4gKlxyXG4gKiBUaGUgcmV0dXJuZWQgdmFsdWUgaXMgcmFuZG9tbHkgc2VsZWN0ZWQgZnJvbSBhIHJhbmdlIG9mIGludGVnZXJzIHRoYXQgYXJlXHJcbiAqIHJlcHJlc2VudGVkIGFzIDggaGV4YWRlY2ltYWwgZGlnaXRzLiBUaGlzIG1lYW5zIHRoYXQgKHdpdGhpbiByZWFzb24pIGFueVxyXG4gKiBudW1iZXJzIGdlbmVyYXRlZCBieSBpbmNyZW1lbnRpbmcgdGhlIHJldHVybmVkIG51bWJlciBieSAxIHdpbGwgYWxzbyBiZVxyXG4gKiByZXByZXNlbnRlZCBieSA4IGhleGFkZWNpbWFsIGRpZ2l0cy4gVGhpcyBsZWFkcyB0byBhbGwgXCJJRHNcIiBoYXZpbmcgdGhlIHNhbWVcclxuICogbGVuZ3RoIHdoZW4gY29udmVydGVkIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLCBtYWtpbmcgcmVhZGluZyBsb2dzIGNvbnRhaW5pbmdcclxuICogdGhlc2UgSURzIGVhc2llciB0byBmb2xsb3cuIEFuZCBzaW5jZSB0aGUgcmV0dXJuIHZhbHVlIGlzIHJhbmRvbWx5IHNlbGVjdGVkXHJcbiAqIGl0IHdpbGwgaGVscCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbG9ncyBmcm9tIGRpZmZlcmVudCBleGVjdXRpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVJbml0aWFsVW5pcXVlRGVidWdJZCgpIHtcclxuICAgIGNvbnN0IG1pblJlc3VsdCA9IDB4MTAwMDAwMDA7XHJcbiAgICBjb25zdCBtYXhSZXN1bHQgPSAweDkwMDAwMDAwO1xyXG4gICAgY29uc3QgcmVzdWx0UmFuZ2UgPSBtYXhSZXN1bHQgLSBtaW5SZXN1bHQ7XHJcbiAgICBjb25zdCByZXN1bHRPZmZzZXQgPSBNYXRoLnJvdW5kKHJlc3VsdFJhbmdlICogTWF0aC5yYW5kb20oKSk7XHJcbiAgICByZXR1cm4gbWluUmVzdWx0ICsgcmVzdWx0T2Zmc2V0O1xyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYW5kIHJldHVybnMgYSB1bmlxdWUgSUQgYXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcuXHJcbiAqXHJcbiAqIFRoZSByZXR1cm5lZCBJRCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGluIGRlYnVnIGxvZ2dpbmcgbWVzc2FnZXMgdG8gaGVscFxyXG4gKiBjb3JyZWxhdGUgbG9nIG1lc3NhZ2VzIHRoYXQgbWF5IGJlIHNwYXRpYWxseSBzZXBhcmF0ZWQgaW4gdGhlIGxvZ3MsIGJ1dFxyXG4gKiBsb2dpY2FsbHkgcmVsYXRlZC4gRm9yIGV4YW1wbGUsIGEgbmV0d29yayBjb25uZWN0aW9uIGNvdWxkIGluY2x1ZGUgdGhlIHNhbWVcclxuICogXCJkZWJ1ZyBJRFwiIHN0cmluZyBpbiBhbGwgb2YgaXRzIGxvZyBtZXNzYWdlcyB0byBoZWxwIHRyYWNlIGEgc3BlY2lmaWNcclxuICogY29ubmVjdGlvbiBvdmVyIHRpbWUuXHJcbiAqXHJcbiAqIEByZXR1cm4gdGhlIDEwLWNoYXJhY3RlciBnZW5lcmF0ZWQgSUQgKGUuZy4gXCIweGExYjJjM2Q0XCIpLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVVbmlxdWVEZWJ1Z0lkKCkge1xyXG4gICAgaWYgKGxhc3RVbmlxdWVEZWJ1Z0lkID09PSBudWxsKSB7XHJcbiAgICAgICAgbGFzdFVuaXF1ZURlYnVnSWQgPSBnZW5lcmF0ZUluaXRpYWxVbmlxdWVEZWJ1Z0lkKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsYXN0VW5pcXVlRGVidWdJZCsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICcweCcgKyBsYXN0VW5pcXVlRGVidWdJZC50b1N0cmluZygxNik7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HX1RBRyQzID0gJ1Jlc3RDb25uZWN0aW9uJztcclxuLyoqXHJcbiAqIE1hcHMgUlBDIG5hbWVzIHRvIHRoZSBjb3JyZXNwb25kaW5nIFJFU1QgZW5kcG9pbnQgbmFtZS5cclxuICpcclxuICogV2UgdXNlIGFycmF5IG5vdGF0aW9uIHRvIGF2b2lkIG1hbmdsaW5nLlxyXG4gKi9cclxuY29uc3QgUlBDX05BTUVfVVJMX01BUFBJTkcgPSB7fTtcclxuUlBDX05BTUVfVVJMX01BUFBJTkdbJ0JhdGNoR2V0RG9jdW1lbnRzJ10gPSAnYmF0Y2hHZXQnO1xyXG5SUENfTkFNRV9VUkxfTUFQUElOR1snQ29tbWl0J10gPSAnY29tbWl0JztcclxuUlBDX05BTUVfVVJMX01BUFBJTkdbJ1J1blF1ZXJ5J10gPSAncnVuUXVlcnknO1xyXG5SUENfTkFNRV9VUkxfTUFQUElOR1snUnVuQWdncmVnYXRpb25RdWVyeSddID0gJ3J1bkFnZ3JlZ2F0aW9uUXVlcnknO1xyXG5jb25zdCBSUENfVVJMX1ZFUlNJT04gPSAndjEnO1xyXG4vLyBTREtfVkVSU0lPTiBpcyB1cGRhdGVkIHRvIGRpZmZlcmVudCB2YWx1ZSBhdCBydW50aW1lIGRlcGVuZGluZyBvbiB0aGUgZW50cnkgcG9pbnQsXHJcbi8vIHNvIHdlIG5lZWQgdG8gZ2V0IGl0cyB2YWx1ZSB3aGVuIHdlIG5lZWQgaXQgaW4gYSBmdW5jdGlvbi5cclxuZnVuY3Rpb24gZ2V0R29vZ0FwaUNsaWVudFZhbHVlKCkge1xyXG4gICAgcmV0dXJuICdnbC1qcy8gZmlyZS8nICsgU0RLX1ZFUlNJT047XHJcbn1cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBSZXN0LWJhc2VkIGNvbm5lY3Rpb25zIHRvIHRoZSBiYWNrZW5kIChXZWJDaGFubmVsIGFuZFxyXG4gKiBIVFRQKS5cclxuICovXHJcbmNsYXNzIFJlc3RDb25uZWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGFiYXNlSW5mbykge1xyXG4gICAgICAgIHRoaXMuZGF0YWJhc2VJbmZvID0gZGF0YWJhc2VJbmZvO1xyXG4gICAgICAgIHRoaXMuZGF0YWJhc2VJZCA9IGRhdGFiYXNlSW5mby5kYXRhYmFzZUlkO1xyXG4gICAgICAgIGNvbnN0IHByb3RvID0gZGF0YWJhc2VJbmZvLnNzbCA/ICdodHRwcycgOiAnaHR0cCc7XHJcbiAgICAgICAgY29uc3QgcHJvamVjdElkID0gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuZGF0YWJhc2VJZC5wcm9qZWN0SWQpO1xyXG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBlbmNvZGVVUklDb21wb25lbnQodGhpcy5kYXRhYmFzZUlkLmRhdGFiYXNlKTtcclxuICAgICAgICB0aGlzLmJhc2VVcmwgPSBwcm90byArICc6Ly8nICsgZGF0YWJhc2VJbmZvLmhvc3Q7XHJcbiAgICAgICAgdGhpcy5kYXRhYmFzZVBhdGggPSBgcHJvamVjdHMvJHtwcm9qZWN0SWR9L2RhdGFiYXNlcy8ke2RhdGFiYXNlSWR9YDtcclxuICAgICAgICB0aGlzLnJlcXVlc3RQYXJhbXMgPVxyXG4gICAgICAgICAgICB0aGlzLmRhdGFiYXNlSWQuZGF0YWJhc2UgPT09IERFRkFVTFRfREFUQUJBU0VfTkFNRVxyXG4gICAgICAgICAgICAgICAgPyBgcHJvamVjdF9pZD0ke3Byb2plY3RJZH1gXHJcbiAgICAgICAgICAgICAgICA6IGBwcm9qZWN0X2lkPSR7cHJvamVjdElkfSZkYXRhYmFzZV9pZD0ke2RhdGFiYXNlSWR9YDtcclxuICAgIH1cclxuICAgIGdldCBzaG91bGRSZXNvdXJjZVBhdGhCZUluY2x1ZGVkSW5SZXF1ZXN0KCkge1xyXG4gICAgICAgIC8vIEJvdGggYGludm9rZVJQQygpYCBhbmQgYGludm9rZVN0cmVhbWluZ1JQQygpYCB1c2UgdGhlaXIgYHBhdGhgIGFyZ3VtZW50cyB0byBkZXRlcm1pbmVcclxuICAgICAgICAvLyB3aGVyZSB0byBydW4gdGhlIHF1ZXJ5LCBhbmQgZXhwZWN0IHRoZSBgcmVxdWVzdGAgdG8gTk9UIHNwZWNpZnkgdGhlIFwicGF0aFwiLlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGludm9rZVJQQyhycGNOYW1lLCBwYXRoLCByZXEsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbUlkID0gZ2VuZXJhdGVVbmlxdWVEZWJ1Z0lkKCk7XHJcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5tYWtlVXJsKHJwY05hbWUsIHBhdGgudG9VcmlFbmNvZGVkU3RyaW5nKCkpO1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgYFNlbmRpbmcgUlBDICcke3JwY05hbWV9JyAke3N0cmVhbUlkfTpgLCB1cmwsIHJlcSk7XHJcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcclxuICAgICAgICAgICAgJ2dvb2dsZS1jbG91ZC1yZXNvdXJjZS1wcmVmaXgnOiB0aGlzLmRhdGFiYXNlUGF0aCxcclxuICAgICAgICAgICAgJ3gtZ29vZy1yZXF1ZXN0LXBhcmFtcyc6IHRoaXMucmVxdWVzdFBhcmFtc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5tb2RpZnlIZWFkZXJzRm9yUmVxdWVzdChoZWFkZXJzLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1SUENSZXF1ZXN0KHJwY05hbWUsIHVybCwgaGVhZGVycywgcmVxKS50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCBgUmVjZWl2ZWQgUlBDICcke3JwY05hbWV9JyAke3N0cmVhbUlkfTogYCwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICAgICAgfSwgKGVycikgPT4ge1xyXG4gICAgICAgICAgICBsb2dXYXJuKExPR19UQUckMywgYFJQQyAnJHtycGNOYW1lfScgJHtzdHJlYW1JZH0gZmFpbGVkIHdpdGggZXJyb3I6IGAsIGVyciwgJ3VybDogJywgdXJsLCAncmVxdWVzdDonLCByZXEpO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpbnZva2VTdHJlYW1pbmdSUEMocnBjTmFtZSwgcGF0aCwgcmVxdWVzdCwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuLCBleHBlY3RlZFJlc3BvbnNlQ291bnQpIHtcclxuICAgICAgICAvLyBUaGUgUkVTVCBBUEkgYXV0b21hdGljYWxseSBhZ2dyZWdhdGVzIGFsbCBvZiB0aGUgc3RyZWFtZWQgcmVzdWx0cywgc28gd2VcclxuICAgICAgICAvLyBjYW4ganVzdCB1c2UgdGhlIG5vcm1hbCBpbnZva2UoKSBtZXRob2QuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52b2tlUlBDKHJwY05hbWUsIHBhdGgsIHJlcXVlc3QsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1vZGlmaWVzIHRoZSBoZWFkZXJzIGZvciBhIHJlcXVlc3QsIGFkZGluZyBhbnkgYXV0aG9yaXphdGlvbiB0b2tlbiBpZlxyXG4gICAgICogcHJlc2VudCBhbmQgYW55IGFkZGl0aW9uYWwgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIG1vZGlmeUhlYWRlcnNGb3JSZXF1ZXN0KGhlYWRlcnMsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgIGhlYWRlcnNbJ1gtR29vZy1BcGktQ2xpZW50J10gPSBnZXRHb29nQXBpQ2xpZW50VmFsdWUoKTtcclxuICAgICAgICAvLyBDb250ZW50LVR5cGU6IHRleHQvcGxhaW4gd2lsbCBhdm9pZCBwcmVmbGlnaHQgcmVxdWVzdHMgd2hpY2ggbWlnaHRcclxuICAgICAgICAvLyBtZXNzIHdpdGggQ09SUyBhbmQgcmVkaXJlY3RzIGJ5IHByb3hpZXMuIElmIHdlIGFkZCBjdXN0b20gaGVhZGVyc1xyXG4gICAgICAgIC8vIHdlIHdpbGwgbmVlZCB0byBjaGFuZ2UgdGhpcyBjb2RlIHRvIHBvdGVudGlhbGx5IHVzZSB0aGUgJGh0dHBPdmVyd3JpdGVcclxuICAgICAgICAvLyBwYXJhbWV0ZXIgc3VwcG9ydGVkIGJ5IEVTRiB0byBhdm9pZCB0cmlnZ2VyaW5nIHByZWZsaWdodCByZXF1ZXN0cy5cclxuICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICd0ZXh0L3BsYWluJztcclxuICAgICAgICBpZiAodGhpcy5kYXRhYmFzZUluZm8uYXBwSWQpIHtcclxuICAgICAgICAgICAgaGVhZGVyc1snWC1GaXJlYmFzZS1HTVBJRCddID0gdGhpcy5kYXRhYmFzZUluZm8uYXBwSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhdXRoVG9rZW4pIHtcclxuICAgICAgICAgICAgYXV0aFRva2VuLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gKGhlYWRlcnNba2V5XSA9IHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcHBDaGVja1Rva2VuKSB7XHJcbiAgICAgICAgICAgIGFwcENoZWNrVG9rZW4uaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiAoaGVhZGVyc1trZXldID0gdmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtYWtlVXJsKHJwY05hbWUsIHBhdGgpIHtcclxuICAgICAgICBjb25zdCB1cmxScGNOYW1lID0gUlBDX05BTUVfVVJMX01BUFBJTkdbcnBjTmFtZV07XHJcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuYmFzZVVybH0vJHtSUENfVVJMX1ZFUlNJT059LyR7cGF0aH06JHt1cmxScGNOYW1lfWA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsb3NlcyBhbmQgY2xlYW5zIHVwIGFueSByZXNvdXJjZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb25uZWN0aW9uLiBUaGlzXHJcbiAgICAgKiBpbXBsZW1lbnRhdGlvbiBpcyBhIG5vLW9wIGJlY2F1c2UgdGhlcmUgYXJlIG5vIHJlc291cmNlcyBhc3NvY2lhdGVkXHJcbiAgICAgKiB3aXRoIHRoZSBSZXN0Q29ubmVjdGlvbiB0aGF0IG5lZWQgdG8gYmUgY2xlYW5lZCB1cC5cclxuICAgICAqL1xyXG4gICAgdGVybWluYXRlKCkge1xyXG4gICAgICAgIC8vIE5vLW9wXHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEVycm9yIENvZGVzIGRlc2NyaWJpbmcgdGhlIGRpZmZlcmVudCB3YXlzIEdSUEMgY2FuIGZhaWwuIFRoZXNlIGFyZSBjb3BpZWRcclxuICogZGlyZWN0bHkgZnJvbSBHUlBDJ3Mgc291cmNlcyBoZXJlOlxyXG4gKlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvYmNlZWM5NGVhNGZjNWYwMDg1ZDgxMjM1ZDhlMWMwNjc5OGRjMzQxYS9pbmNsdWRlL2dycGMlMkIlMkIvaW1wbC9jb2RlZ2VuL3N0YXR1c19jb2RlX2VudW0uaFxyXG4gKlxyXG4gKiBJbXBvcnRhbnQhIFRoZSBuYW1lcyBvZiB0aGVzZSBpZGVudGlmaWVycyBtYXR0ZXIgYmVjYXVzZSB0aGUgc3RyaW5nIGZvcm1zXHJcbiAqIGFyZSB1c2VkIGZvciByZXZlcnNlIGxvb2t1cHMgZnJvbSB0aGUgd2ViY2hhbm5lbCBzdHJlYW0uIERvIE5PVCBjaGFuZ2UgdGhlXHJcbiAqIG5hbWVzIG9mIHRoZXNlIGlkZW50aWZpZXJzIG9yIGNoYW5nZSB0aGlzIGludG8gYSBjb25zdCBlbnVtLlxyXG4gKi9cclxudmFyIFJwY0NvZGU7XHJcbihmdW5jdGlvbiAoUnBjQ29kZSkge1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiT0tcIl0gPSAwXSA9IFwiT0tcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIkNBTkNFTExFRFwiXSA9IDFdID0gXCJDQU5DRUxMRURcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIlVOS05PV05cIl0gPSAyXSA9IFwiVU5LTk9XTlwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiSU5WQUxJRF9BUkdVTUVOVFwiXSA9IDNdID0gXCJJTlZBTElEX0FSR1VNRU5UXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJERUFETElORV9FWENFRURFRFwiXSA9IDRdID0gXCJERUFETElORV9FWENFRURFRFwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiTk9UX0ZPVU5EXCJdID0gNV0gPSBcIk5PVF9GT1VORFwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiQUxSRUFEWV9FWElTVFNcIl0gPSA2XSA9IFwiQUxSRUFEWV9FWElTVFNcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIlBFUk1JU1NJT05fREVOSUVEXCJdID0gN10gPSBcIlBFUk1JU1NJT05fREVOSUVEXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJVTkFVVEhFTlRJQ0FURURcIl0gPSAxNl0gPSBcIlVOQVVUSEVOVElDQVRFRFwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiUkVTT1VSQ0VfRVhIQVVTVEVEXCJdID0gOF0gPSBcIlJFU09VUkNFX0VYSEFVU1RFRFwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiRkFJTEVEX1BSRUNPTkRJVElPTlwiXSA9IDldID0gXCJGQUlMRURfUFJFQ09ORElUSU9OXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJBQk9SVEVEXCJdID0gMTBdID0gXCJBQk9SVEVEXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJPVVRfT0ZfUkFOR0VcIl0gPSAxMV0gPSBcIk9VVF9PRl9SQU5HRVwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiVU5JTVBMRU1FTlRFRFwiXSA9IDEyXSA9IFwiVU5JTVBMRU1FTlRFRFwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiSU5URVJOQUxcIl0gPSAxM10gPSBcIklOVEVSTkFMXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJVTkFWQUlMQUJMRVwiXSA9IDE0XSA9IFwiVU5BVkFJTEFCTEVcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIkRBVEFfTE9TU1wiXSA9IDE1XSA9IFwiREFUQV9MT1NTXCI7XHJcbn0pKFJwY0NvZGUgfHwgKFJwY0NvZGUgPSB7fSkpO1xyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGVycm9yIGNvZGUgcmVwcmVzZW50cyBhIHBlcm1hbmVudCBlcnJvciB3aGVuIHJlY2VpdmVkXHJcbiAqIGluIHJlc3BvbnNlIHRvIGEgbm9uLXdyaXRlIG9wZXJhdGlvbi5cclxuICpcclxuICogU2VlIGlzUGVybWFuZW50V3JpdGVFcnJvciBmb3IgY2xhc3NpZnlpbmcgd3JpdGUgZXJyb3JzLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNQZXJtYW5lbnRFcnJvcihjb2RlKSB7XHJcbiAgICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgICAgICBjYXNlIENvZGUuT0s6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICAgICAgY2FzZSBDb2RlLkNBTkNFTExFRDpcclxuICAgICAgICBjYXNlIENvZGUuVU5LTk9XTjpcclxuICAgICAgICBjYXNlIENvZGUuREVBRExJTkVfRVhDRUVERUQ6XHJcbiAgICAgICAgY2FzZSBDb2RlLlJFU09VUkNFX0VYSEFVU1RFRDpcclxuICAgICAgICBjYXNlIENvZGUuSU5URVJOQUw6XHJcbiAgICAgICAgY2FzZSBDb2RlLlVOQVZBSUxBQkxFOlxyXG4gICAgICAgIC8vIFVuYXV0aGVudGljYXRlZCBtZWFucyBzb21ldGhpbmcgd2VudCB3cm9uZyB3aXRoIG91ciB0b2tlbiBhbmQgd2UgbmVlZFxyXG4gICAgICAgIC8vIHRvIHJldHJ5IHdpdGggbmV3IGNyZWRlbnRpYWxzIHdoaWNoIHdpbGwgaGFwcGVuIGF1dG9tYXRpY2FsbHkuXHJcbiAgICAgICAgY2FzZSBDb2RlLlVOQVVUSEVOVElDQVRFRDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGNhc2UgQ29kZS5JTlZBTElEX0FSR1VNRU5UOlxyXG4gICAgICAgIGNhc2UgQ29kZS5OT1RfRk9VTkQ6XHJcbiAgICAgICAgY2FzZSBDb2RlLkFMUkVBRFlfRVhJU1RTOlxyXG4gICAgICAgIGNhc2UgQ29kZS5QRVJNSVNTSU9OX0RFTklFRDpcclxuICAgICAgICBjYXNlIENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTjpcclxuICAgICAgICAvLyBBYm9ydGVkIG1pZ2h0IGJlIHJldHJpZWQgaW4gc29tZSBzY2VuYXJpb3MsIGJ1dCB0aGF0IGlzIGRlcGVuZGFudCBvblxyXG4gICAgICAgIC8vIHRoZSBjb250ZXh0IGFuZCBzaG91bGQgaGFuZGxlZCBpbmRpdmlkdWFsbHkgYnkgdGhlIGNhbGxpbmcgY29kZS5cclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2FwaXMvZGVzaWduL2Vycm9ycy5cclxuICAgICAgICBjYXNlIENvZGUuQUJPUlRFRDpcclxuICAgICAgICBjYXNlIENvZGUuT1VUX09GX1JBTkdFOlxyXG4gICAgICAgIGNhc2UgQ29kZS5VTklNUExFTUVOVEVEOlxyXG4gICAgICAgIGNhc2UgQ29kZS5EQVRBX0xPU1M6XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGFuIEhUVFAgU3RhdHVzIENvZGUgdG8gdGhlIGVxdWl2YWxlbnQgZXJyb3IgY29kZS5cclxuICpcclxuICogQHBhcmFtIHN0YXR1cyAtIEFuIEhUVFAgU3RhdHVzIENvZGUsIGxpa2UgMjAwLCA0MDQsIDUwMywgZXRjLlxyXG4gKiBAcmV0dXJucyBUaGUgZXF1aXZhbGVudCBDb2RlLiBVbmtub3duIHN0YXR1cyBjb2RlcyBhcmUgbWFwcGVkIHRvXHJcbiAqICAgICBDb2RlLlVOS05PV04uXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXBDb2RlRnJvbUh0dHBTdGF0dXMoc3RhdHVzKSB7XHJcbiAgICBpZiAoc3RhdHVzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBsb2dFcnJvcignUlBDX0VSUk9SJywgJ0hUVFAgZXJyb3IgaGFzIG5vIHN0YXR1cycpO1xyXG4gICAgICAgIHJldHVybiBDb2RlLlVOS05PV047XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgY2Fub25pY2FsIGVycm9yIGNvZGVzIGZvciBHb29nbGUgQVBJcyBbMV0gc3BlY2lmeSBtYXBwaW5nIG9udG8gSFRUUFxyXG4gICAgLy8gc3RhdHVzIGNvZGVzIGJ1dCB0aGUgbWFwcGluZyBpcyBub3QgYmlqZWN0aXZlLiBJbiBlYWNoIGNhc2Ugb2YgYW1iaWd1aXR5XHJcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIGNob29zZXMgYSBwcmltYXJ5IGVycm9yLlxyXG4gICAgLy9cclxuICAgIC8vIFsxXVxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWFwaXMvZ29vZ2xlYXBpcy9ibG9iL21hc3Rlci9nb29nbGUvcnBjL2NvZGUucHJvdG9cclxuICAgIHN3aXRjaCAoc3RhdHVzKSB7XHJcbiAgICAgICAgY2FzZSAyMDA6IC8vIE9LXHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLk9LO1xyXG4gICAgICAgIGNhc2UgNDAwOiAvLyBCYWQgUmVxdWVzdFxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OO1xyXG4gICAgICAgIC8vIE90aGVyIHBvc3NpYmlsaXRpZXMgYmFzZWQgb24gdGhlIGZvcndhcmQgbWFwcGluZ1xyXG4gICAgICAgIC8vIHJldHVybiBDb2RlLklOVkFMSURfQVJHVU1FTlQ7XHJcbiAgICAgICAgLy8gcmV0dXJuIENvZGUuT1VUX09GX1JBTkdFO1xyXG4gICAgICAgIGNhc2UgNDAxOiAvLyBVbmF1dGhvcml6ZWRcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVU5BVVRIRU5USUNBVEVEO1xyXG4gICAgICAgIGNhc2UgNDAzOiAvLyBGb3JiaWRkZW5cclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuUEVSTUlTU0lPTl9ERU5JRUQ7XHJcbiAgICAgICAgY2FzZSA0MDQ6IC8vIE5vdCBGb3VuZFxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5OT1RfRk9VTkQ7XHJcbiAgICAgICAgY2FzZSA0MDk6IC8vIENvbmZsaWN0XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkFCT1JURUQ7XHJcbiAgICAgICAgLy8gT3RoZXIgcG9zc2liaWxpdGllczpcclxuICAgICAgICAvLyByZXR1cm4gQ29kZS5BTFJFQURZX0VYSVNUUztcclxuICAgICAgICBjYXNlIDQxNjogLy8gUmFuZ2UgTm90IFNhdGlzZmlhYmxlXHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLk9VVF9PRl9SQU5HRTtcclxuICAgICAgICBjYXNlIDQyOTogLy8gVG9vIE1hbnkgUmVxdWVzdHNcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuUkVTT1VSQ0VfRVhIQVVTVEVEO1xyXG4gICAgICAgIGNhc2UgNDk5OiAvLyBDbGllbnQgQ2xvc2VkIFJlcXVlc3RcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuQ0FOQ0VMTEVEO1xyXG4gICAgICAgIGNhc2UgNTAwOiAvLyBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVU5LTk9XTjtcclxuICAgICAgICAvLyBPdGhlciBwb3NzaWJpbGl0aWVzOlxyXG4gICAgICAgIC8vIHJldHVybiBDb2RlLklOVEVSTkFMO1xyXG4gICAgICAgIC8vIHJldHVybiBDb2RlLkRBVEFfTE9TUztcclxuICAgICAgICBjYXNlIDUwMTogLy8gVW5pbXBsZW1lbnRlZFxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5VTklNUExFTUVOVEVEO1xyXG4gICAgICAgIGNhc2UgNTAzOiAvLyBTZXJ2aWNlIFVuYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlVOQVZBSUxBQkxFO1xyXG4gICAgICAgIGNhc2UgNTA0OiAvLyBHYXRld2F5IFRpbWVvdXRcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuREVBRExJTkVfRVhDRUVERUQ7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29kZS5PSztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhdHVzID49IDQwMCAmJiBzdGF0dXMgPCA1MDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb2RlLkZBSUxFRF9QUkVDT05ESVRJT047XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA+PSA1MDAgJiYgc3RhdHVzIDwgNjAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29kZS5JTlRFUk5BTDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5VTktOT1dOO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIFJlc3QtYmFzZWQgY29ubmVjdGlvbiB0aGF0IHJlbGllcyBvbiB0aGUgbmF0aXZlIEhUVFAgc3RhY2tcclxuICogKGUuZy4gYGZldGNoYCBvciBhIHBvbHlmaWxsKS5cclxuICovXHJcbmNsYXNzIEZldGNoQ29ubmVjdGlvbiBleHRlbmRzIFJlc3RDb25uZWN0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGRhdGFiYXNlSW5mbyAtIFRoZSBjb25uZWN0aW9uIGluZm8uXHJcbiAgICAgKiBAcGFyYW0gZmV0Y2hJbXBsIC0gYGZldGNoYCBvciBhIFBvbHlmaWxsIHRoYXQgaW1wbGVtZW50cyB0aGUgZmV0Y2ggQVBJLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhYmFzZUluZm8sIGZldGNoSW1wbCkge1xyXG4gICAgICAgIHN1cGVyKGRhdGFiYXNlSW5mbyk7XHJcbiAgICAgICAgdGhpcy5mZXRjaEltcGwgPSBmZXRjaEltcGw7XHJcbiAgICB9XHJcbiAgICBvcGVuU3RyZWFtKHJwY05hbWUsIHRva2VuKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIGJ5IEZldGNoQ29ubmVjdGlvbicpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcGVyZm9ybVJQQ1JlcXVlc3QocnBjTmFtZSwgdXJsLCBoZWFkZXJzLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RKc29uID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XHJcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaEltcGwodXJsLCB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0SnNvblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyID0gZTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKG1hcENvZGVGcm9tSHR0cFN0YXR1cyhlcnIuc3RhdHVzKSwgJ1JlcXVlc3QgZmFpbGVkIHdpdGggZXJyb3I6ICcgKyBlcnIuc3RhdHVzVGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgbGV0IGVycm9yUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVycm9yUmVzcG9uc2UpKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvclJlc3BvbnNlID0gZXJyb3JSZXNwb25zZVswXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAoX2EgPSBlcnJvclJlc3BvbnNlID09PSBudWxsIHx8IGVycm9yUmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yUmVzcG9uc2UuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IobWFwQ29kZUZyb21IdHRwU3RhdHVzKHJlc3BvbnNlLnN0YXR1cyksIGBSZXF1ZXN0IGZhaWxlZCB3aXRoIGVycm9yOiAke2Vycm9yTWVzc2FnZSAhPT0gbnVsbCAmJiBlcnJvck1lc3NhZ2UgIT09IHZvaWQgMCA/IGVycm9yTWVzc2FnZSA6IHJlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIEluaXRpYWxpemVzIHRoZSBIVFRQIGNvbm5lY3Rpb24gZm9yIHRoZSBSRVNUIEFQSS4gKi9cclxuZnVuY3Rpb24gbmV3Q29ubmVjdGlvbihkYXRhYmFzZUluZm8pIHtcclxuICAgIC8vIHVuZGljaSBpcyBtZWFudCB0byBiZSBBUEkgY29tcGF0aWJsZSB3aXRoIGBmZXRjaGAsIGJ1dCBpdHMgdHlwZSBkb2Vzbid0XHJcbiAgICAvLyBtYXRjaCAxMDAlLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIHJldHVybiBuZXcgRmV0Y2hDb25uZWN0aW9uKGRhdGFiYXNlSW5mbywgZmV0Y2gpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYG5CeXRlc2Agb2YgcmFuZG9tIGJ5dGVzLlxyXG4gKlxyXG4gKiBJZiBgbkJ5dGVzIDwgMGAgLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cclxuICovXHJcbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKG5CeXRlcykge1xyXG4gICAgcmV0dXJuIHJhbmRvbUJ5dGVzJDEobkJ5dGVzKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSB1dGlsaXR5IGNsYXNzIGZvciBnZW5lcmF0aW5nIHVuaXF1ZSBhbHBoYW51bWVyaWMgSURzIG9mIGEgc3BlY2lmaWVkIGxlbmd0aC5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqIEV4cG9ydGVkIGludGVybmFsbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuXHJcbiAqL1xyXG5jbGFzcyBBdXRvSWQge1xyXG4gICAgc3RhdGljIG5ld0lkKCkge1xyXG4gICAgICAgIC8vIEFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXHJcbiAgICAgICAgY29uc3QgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknO1xyXG4gICAgICAgIC8vIFRoZSBsYXJnZXN0IGJ5dGUgdmFsdWUgdGhhdCBpcyBhIG11bHRpcGxlIG9mIGBjaGFyLmxlbmd0aGAuXHJcbiAgICAgICAgY29uc3QgbWF4TXVsdGlwbGUgPSBNYXRoLmZsb29yKDI1NiAvIGNoYXJzLmxlbmd0aCkgKiBjaGFycy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGF1dG9JZCA9ICcnO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldExlbmd0aCA9IDIwO1xyXG4gICAgICAgIHdoaWxlIChhdXRvSWQubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gcmFuZG9tQnl0ZXMoNDApO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFjY2VwdCB2YWx1ZXMgdGhhdCBhcmUgWzAsIG1heE11bHRpcGxlKSwgdGhpcyBlbnN1cmVzIHRoZXkgY2FuXHJcbiAgICAgICAgICAgICAgICAvLyBiZSBldmVubHkgbWFwcGVkIHRvIGluZGljZXMgb2YgYGNoYXJzYCB2aWEgYSBtb2R1bG8gb3BlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgaWYgKGF1dG9JZC5sZW5ndGggPCB0YXJnZXRMZW5ndGggJiYgYnl0ZXNbaV0gPCBtYXhNdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9JZCArPSBjaGFycy5jaGFyQXQoYnl0ZXNbaV0gJSBjaGFycy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhdXRvSWQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKGxlZnQgPCByaWdodCkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGlmIChsZWZ0ID4gcmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcbi8qKiBIZWxwZXIgdG8gY29tcGFyZSBhcnJheXMgdXNpbmcgaXNFcXVhbCgpLiAqL1xyXG5mdW5jdGlvbiBhcnJheUVxdWFscyhsZWZ0LCByaWdodCwgY29tcGFyYXRvcikge1xyXG4gICAgaWYgKGxlZnQubGVuZ3RoICE9PSByaWdodC5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVmdC5ldmVyeSgodmFsdWUsIGluZGV4KSA9PiBjb21wYXJhdG9yKHZhbHVlLCByaWdodFtpbmRleF0pKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBvYmplY3RTaXplKG9iaikge1xyXG4gICAgbGV0IGNvdW50ID0gMDtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvdW50O1xyXG59XHJcbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICAgICAgZm4oa2V5LCBvYmpba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1hcFRvQXJyYXkob2JqLCBmbikge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChmbihvYmpba2V5XSwga2V5LCBvYmopKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBhIHZhcmlhYmxlIGlzIGVpdGhlciB1bmRlZmluZWQgb3IgbnVsbC5cclxuICovXHJcbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcclxufVxyXG4vKiogUmV0dXJucyB3aGV0aGVyIHRoZSB2YWx1ZSByZXByZXNlbnRzIC0wLiAqL1xyXG5mdW5jdGlvbiBpc05lZ2F0aXZlWmVybyh2YWx1ZSkge1xyXG4gICAgLy8gRGV0ZWN0IGlmIHRoZSB2YWx1ZSBpcyAtMC4wLiBCYXNlZCBvbiBwb2x5ZmlsbCBmcm9tXHJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcclxuICAgIHJldHVybiB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPT09IDEgLyAtMDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIGEgdmFsdWUgaXMgYW4gaW50ZWdlciBhbmQgaW4gdGhlIHNhZmUgaW50ZWdlciByYW5nZVxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdCBmb3IgYmVpbmcgYW4gaW50ZWdlciBhbmQgaW4gdGhlIHNhZmUgcmFuZ2VcclxuICovXHJcbmZ1bmN0aW9uIGlzU2FmZUludGVnZXIodmFsdWUpIHtcclxuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmXHJcbiAgICAgICAgIWlzTmVnYXRpdmVaZXJvKHZhbHVlKSAmJlxyXG4gICAgICAgIHZhbHVlIDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmXHJcbiAgICAgICAgdmFsdWUgPj0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBDb252ZXJ0cyBhIEJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byBhIGJpbmFyeSBzdHJpbmcuICovXHJcbmZ1bmN0aW9uIGRlY29kZUJhc2U2NChlbmNvZGVkKSB7XHJcbiAgICAvLyBOb3RlOiBXZSB1c2VkIHRvIHZhbGlkYXRlIHRoZSBiYXNlNjQgc3RyaW5nIGhlcmUgdmlhIGEgcmVndWxhciBleHByZXNzaW9uLlxyXG4gICAgLy8gVGhpcyB3YXMgcmVtb3ZlZCB0byBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZSBvZiBpbmRleGluZy5cclxuICAgIHJldHVybiBCdWZmZXIuZnJvbShlbmNvZGVkLCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpO1xyXG59XHJcbi8qKiBDb252ZXJ0cyBhIGJpbmFyeSBzdHJpbmcgdG8gYSBCYXNlNjQgZW5jb2RlZCBzdHJpbmcuICovXHJcbmZ1bmN0aW9uIGVuY29kZUJhc2U2NChyYXcpIHtcclxuICAgIHJldHVybiBCdWZmZXIuZnJvbShyYXcsICdiaW5hcnknKS50b1N0cmluZygnYmFzZTY0Jyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEltbXV0YWJsZSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBcInByb3RvXCIgYnl0ZSBzdHJpbmcuXHJcbiAqXHJcbiAqIFByb3RvIGJ5dGUgc3RyaW5ncyBjYW4gZWl0aGVyIGJlIEJhc2U2NC1lbmNvZGVkIHN0cmluZ3Mgb3IgVWludDhBcnJheXMgd2hlblxyXG4gKiBzZW50IG9uIHRoZSB3aXJlLiBUaGlzIGNsYXNzIGFic3RyYWN0cyBhd2F5IHRoaXMgZGlmZmVyZW50aWF0aW9uIGJ5IGhvbGRpbmdcclxuICogdGhlIHByb3RvIGJ5dGUgc3RyaW5nIGluIGEgY29tbW9uIGNsYXNzIHRoYXQgbXVzdCBiZSBjb252ZXJ0ZWQgaW50byBhIHN0cmluZ1xyXG4gKiBiZWZvcmUgYmVpbmcgc2VudCBhcyBhIHByb3RvLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIEJ5dGVTdHJpbmcge1xyXG4gICAgY29uc3RydWN0b3IoYmluYXJ5U3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5iaW5hcnlTdHJpbmcgPSBiaW5hcnlTdHJpbmc7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUJhc2U2NFN0cmluZyhiYXNlNjQpIHtcclxuICAgICAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBkZWNvZGVCYXNlNjQoYmFzZTY0KTtcclxuICAgICAgICByZXR1cm4gbmV3IEJ5dGVTdHJpbmcoYmluYXJ5U3RyaW5nKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tVWludDhBcnJheShhcnJheSkge1xyXG4gICAgICAgIC8vIFRPRE8oaW5kZXhpbmcpOyBSZW1vdmUgdGhlIGNvcHkgb2YgdGhlIGJ5dGUgc3RyaW5nIGhlcmUgYXMgdGhpcyBtZXRob2RcclxuICAgICAgICAvLyBpcyBmcmVxdWVudGx5IGNhbGxlZCBkdXJpbmcgaW5kZXhpbmcuXHJcbiAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYmluYXJ5U3RyaW5nRnJvbVVpbnQ4QXJyYXkoYXJyYXkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQnl0ZVN0cmluZyhiaW5hcnlTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgdGhpcy5iaW5hcnlTdHJpbmcubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHRoaXMuYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSsrKSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB0b0Jhc2U2NCgpIHtcclxuICAgICAgICByZXR1cm4gZW5jb2RlQmFzZTY0KHRoaXMuYmluYXJ5U3RyaW5nKTtcclxuICAgIH1cclxuICAgIHRvVWludDhBcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gdWludDhBcnJheUZyb21CaW5hcnlTdHJpbmcodGhpcy5iaW5hcnlTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgYXBwcm94aW1hdGVCeXRlU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlTdHJpbmcubGVuZ3RoICogMjtcclxuICAgIH1cclxuICAgIGNvbXBhcmVUbyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKHRoaXMuYmluYXJ5U3RyaW5nLCBvdGhlci5iaW5hcnlTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJpbmFyeVN0cmluZyA9PT0gb3RoZXIuYmluYXJ5U3RyaW5nO1xyXG4gICAgfVxyXG59XHJcbkJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcgPSBuZXcgQnl0ZVN0cmluZygnJyk7XHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhbiBVaW50OGFycmF5IHRvIGEgYmluYXJ5IHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGJpbmFyeVN0cmluZ0Zyb21VaW50OEFycmF5KGFycmF5KSB7XHJcbiAgICBsZXQgYmluYXJ5U3RyaW5nID0gJyc7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgYmluYXJ5U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJpbmFyeVN0cmluZztcclxufVxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYSBiaW5hcnkgc3RyaW5nIHRvIGFuIFVpbnQ4QXJyYXkuXHJcbiAqL1xyXG5mdW5jdGlvbiB1aW50OEFycmF5RnJvbUJpbmFyeVN0cmluZyhiaW5hcnlTdHJpbmcpIHtcclxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBidWZmZXJbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBidWZmZXI7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gQSBSZWdFeHAgbWF0Y2hpbmcgSVNPIDg2MDEgVVRDIHRpbWVzdGFtcHMgd2l0aCBvcHRpb25hbCBmcmFjdGlvbi5cclxuY29uc3QgSVNPX1RJTUVTVEFNUF9SRUdfRVhQID0gbmV3IFJlZ0V4cCgvXlxcZHs0fS1cXGRcXGQtXFxkXFxkVFxcZFxcZDpcXGRcXGQ6XFxkXFxkKD86XFwuKFxcZCspKT9aJC8pO1xyXG4vKipcclxuICogQ29udmVydHMgdGhlIHBvc3NpYmxlIFByb3RvIHZhbHVlcyBmb3IgYSB0aW1lc3RhbXAgdmFsdWUgaW50byBhIFwic2Vjb25kcyBhbmRcclxuICogbmFub3NcIiByZXByZXNlbnRhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVRpbWVzdGFtcChkYXRlKSB7XHJcbiAgICBoYXJkQXNzZXJ0KCEhZGF0ZSk7XHJcbiAgICAvLyBUaGUganNvbiBpbnRlcmZhY2UgKGZvciB0aGUgYnJvd3Nlcikgd2lsbCByZXR1cm4gYW4gaXNvIHRpbWVzdGFtcCBzdHJpbmcsXHJcbiAgICAvLyB3aGlsZSB0aGUgcHJvdG8ganMgbGlicmFyeSAoZm9yIG5vZGUpIHdpbGwgcmV0dXJuIGFcclxuICAgIC8vIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgaW5zdGFuY2UuXHJcbiAgICBpZiAodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy8gVGhlIGRhdGUgc3RyaW5nIGNhbiBoYXZlIGhpZ2hlciBwcmVjaXNpb24gKG5hbm9zKSB0aGFuIHRoZSBEYXRlIGNsYXNzXHJcbiAgICAgICAgLy8gKG1pbGxpcyksIHNvIHdlIGRvIHNvbWUgY3VzdG9tIHBhcnNpbmcgaGVyZS5cclxuICAgICAgICAvLyBQYXJzZSB0aGUgbmFub3MgcmlnaHQgb3V0IG9mIHRoZSBzdHJpbmcuXHJcbiAgICAgICAgbGV0IG5hbm9zID0gMDtcclxuICAgICAgICBjb25zdCBmcmFjdGlvbiA9IElTT19USU1FU1RBTVBfUkVHX0VYUC5leGVjKGRhdGUpO1xyXG4gICAgICAgIGhhcmRBc3NlcnQoISFmcmFjdGlvbik7XHJcbiAgICAgICAgaWYgKGZyYWN0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgIC8vIFBhZCB0aGUgZnJhY3Rpb24gb3V0IHRvIDkgZGlnaXRzIChuYW5vcykuXHJcbiAgICAgICAgICAgIGxldCBuYW5vU3RyID0gZnJhY3Rpb25bMV07XHJcbiAgICAgICAgICAgIG5hbm9TdHIgPSAobmFub1N0ciArICcwMDAwMDAwMDAnKS5zdWJzdHIoMCwgOSk7XHJcbiAgICAgICAgICAgIG5hbm9zID0gTnVtYmVyKG5hbm9TdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQYXJzZSB0aGUgZGF0ZSB0byBnZXQgdGhlIHNlY29uZHMuXHJcbiAgICAgICAgY29uc3QgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xyXG4gICAgICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKHBhcnNlZERhdGUuZ2V0VGltZSgpIC8gMTAwMCk7XHJcbiAgICAgICAgcmV0dXJuIHsgc2Vjb25kcywgbmFub3MgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFRPRE8oYi8zNzI4MjIzNyk6IFVzZSBzdHJpbmdzIGZvciBQcm90bzMgdGltZXN0YW1wc1xyXG4gICAgICAgIC8vIGFzc2VydCghdGhpcy5vcHRpb25zLnVzZVByb3RvM0pzb24sXHJcbiAgICAgICAgLy8gICAnVGhlIHRpbWVzdGFtcCBpbnN0YW5jZSBmb3JtYXQgcmVxdWlyZXMgUHJvdG8gSlMuJyk7XHJcbiAgICAgICAgY29uc3Qgc2Vjb25kcyA9IG5vcm1hbGl6ZU51bWJlcihkYXRlLnNlY29uZHMpO1xyXG4gICAgICAgIGNvbnN0IG5hbm9zID0gbm9ybWFsaXplTnVtYmVyKGRhdGUubmFub3MpO1xyXG4gICAgICAgIHJldHVybiB7IHNlY29uZHMsIG5hbm9zIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBwb3NzaWJsZSBQcm90byB0eXBlcyBmb3IgbnVtYmVycyBpbnRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXHJcbiAqIFJldHVybnMgMCBpZiB0aGUgdmFsdWUgaXMgbm90IG51bWVyaWMuXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVOdW1iZXIodmFsdWUpIHtcclxuICAgIC8vIFRPRE8oYmpvcm5pY2spOiBIYW5kbGUgaW50NjQgZ3JlYXRlciB0aGFuIDUzIGJpdHMuXHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG59XHJcbi8qKiBDb252ZXJ0cyB0aGUgcG9zc2libGUgUHJvdG8gdHlwZXMgZm9yIEJsb2JzIGludG8gYSBCeXRlU3RyaW5nLiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVCeXRlU3RyaW5nKGJsb2IpIHtcclxuICAgIGlmICh0eXBlb2YgYmxvYiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gQnl0ZVN0cmluZy5mcm9tQmFzZTY0U3RyaW5nKGJsb2IpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIEJ5dGVTdHJpbmcuZnJvbVVpbnQ4QXJyYXkoYmxvYik7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gVGhlIGVhcmxpZXN0IGRhdGUgc3VwcG9ydGVkIGJ5IEZpcmVzdG9yZSB0aW1lc3RhbXBzICgwMDAxLTAxLTAxVDAwOjAwOjAwWikuXHJcbmNvbnN0IE1JTl9TRUNPTkRTID0gLTYyMTM1NTk2ODAwO1xyXG4vLyBOdW1iZXIgb2YgbmFub3NlY29uZHMgaW4gYSBtaWxsaXNlY29uZC5cclxuY29uc3QgTVNfVE9fTkFOT1MgPSAxZTY7XHJcbi8qKlxyXG4gKiBBIGBUaW1lc3RhbXBgIHJlcHJlc2VudHMgYSBwb2ludCBpbiB0aW1lIGluZGVwZW5kZW50IG9mIGFueSB0aW1lIHpvbmUgb3JcclxuICogY2FsZW5kYXIsIHJlcHJlc2VudGVkIGFzIHNlY29uZHMgYW5kIGZyYWN0aW9ucyBvZiBzZWNvbmRzIGF0IG5hbm9zZWNvbmRcclxuICogcmVzb2x1dGlvbiBpbiBVVEMgRXBvY2ggdGltZS5cclxuICpcclxuICogSXQgaXMgZW5jb2RlZCB1c2luZyB0aGUgUHJvbGVwdGljIEdyZWdvcmlhbiBDYWxlbmRhciB3aGljaCBleHRlbmRzIHRoZVxyXG4gKiBHcmVnb3JpYW4gY2FsZW5kYXIgYmFja3dhcmRzIHRvIHllYXIgb25lLiBJdCBpcyBlbmNvZGVkIGFzc3VtaW5nIGFsbCBtaW51dGVzXHJcbiAqIGFyZSA2MCBzZWNvbmRzIGxvbmcsIGkuZS4gbGVhcCBzZWNvbmRzIGFyZSBcInNtZWFyZWRcIiBzbyB0aGF0IG5vIGxlYXAgc2Vjb25kXHJcbiAqIHRhYmxlIGlzIG5lZWRlZCBmb3IgaW50ZXJwcmV0YXRpb24uIFJhbmdlIGlzIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG9cclxuICogOTk5OS0xMi0zMVQyMzo1OTo1OS45OTk5OTk5OTlaLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZXMgYW5kIGZ1cnRoZXIgc3BlY2lmaWNhdGlvbnMsIHJlZmVyIHRvIHRoZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9wcm90b2J1Zi9ibG9iL21hc3Rlci9zcmMvZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcC5wcm90byB8IFRpbWVzdGFtcCBkZWZpbml0aW9ufS5cclxuICovXHJcbmNsYXNzIFRpbWVzdGFtcCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGltZXN0YW1wLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZWNvbmRzIC0gVGhlIG51bWJlciBvZiBzZWNvbmRzIG9mIFVUQyB0aW1lIHNpbmNlIFVuaXggZXBvY2hcclxuICAgICAqICAgICAxOTcwLTAxLTAxVDAwOjAwOjAwWi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvXHJcbiAgICAgKiAgICAgOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlLlxyXG4gICAgICogQHBhcmFtIG5hbm9zZWNvbmRzIC0gVGhlIG5vbi1uZWdhdGl2ZSBmcmFjdGlvbnMgb2YgYSBzZWNvbmQgYXQgbmFub3NlY29uZFxyXG4gICAgICogICAgIHJlc29sdXRpb24uIE5lZ2F0aXZlIHNlY29uZCB2YWx1ZXMgd2l0aCBmcmFjdGlvbnMgbXVzdCBzdGlsbCBoYXZlXHJcbiAgICAgKiAgICAgbm9uLW5lZ2F0aXZlIG5hbm9zZWNvbmRzIHZhbHVlcyB0aGF0IGNvdW50IGZvcndhcmQgaW4gdGltZS4gTXVzdCBiZVxyXG4gICAgICogICAgIGZyb20gMCB0byA5OTksOTk5LDk5OSBpbmNsdXNpdmUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHNlY29uZHMgb2YgVVRDIHRpbWUgc2luY2UgVW5peCBlcG9jaCAxOTcwLTAxLTAxVDAwOjAwOjAwWi5cclxuICAgICAqL1xyXG4gICAgc2Vjb25kcywgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmcmFjdGlvbnMgb2YgYSBzZWNvbmQgYXQgbmFub3NlY29uZCByZXNvbHV0aW9uLipcclxuICAgICAqL1xyXG4gICAgbmFub3NlY29uZHMpIHtcclxuICAgICAgICB0aGlzLnNlY29uZHMgPSBzZWNvbmRzO1xyXG4gICAgICAgIHRoaXMubmFub3NlY29uZHMgPSBuYW5vc2Vjb25kcztcclxuICAgICAgICBpZiAobmFub3NlY29uZHMgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdUaW1lc3RhbXAgbmFub3NlY29uZHMgb3V0IG9mIHJhbmdlOiAnICsgbmFub3NlY29uZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmFub3NlY29uZHMgPj0gMWU5KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdUaW1lc3RhbXAgbmFub3NlY29uZHMgb3V0IG9mIHJhbmdlOiAnICsgbmFub3NlY29uZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2Vjb25kcyA8IE1JTl9TRUNPTkRTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdUaW1lc3RhbXAgc2Vjb25kcyBvdXQgb2YgcmFuZ2U6ICcgKyBzZWNvbmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJyZWFrIGluIHRoZSB5ZWFyIDEwLDAwMC5cclxuICAgICAgICBpZiAoc2Vjb25kcyA+PSAyNTM0MDIzMDA4MDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RpbWVzdGFtcCBzZWNvbmRzIG91dCBvZiByYW5nZTogJyArIHNlY29uZHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0aW1lc3RhbXAgd2l0aCB0aGUgY3VycmVudCBkYXRlLCB3aXRoIG1pbGxpc2Vjb25kIHByZWNpc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0aW1lc3RhbXAgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IGRhdGUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBub3coKSB7XHJcbiAgICAgICAgcmV0dXJuIFRpbWVzdGFtcC5mcm9tTWlsbGlzKERhdGUubm93KCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRpbWVzdGFtcCBmcm9tIHRoZSBnaXZlbiBkYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gaW5pdGlhbGl6ZSB0aGUgYFRpbWVzdGFtcGAgZnJvbS5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGBUaW1lc3RhbXBgIHJlcHJlc2VudGluZyB0aGUgc2FtZSBwb2ludCBpbiB0aW1lIGFzIHRoZSBnaXZlblxyXG4gICAgICogICAgIGRhdGUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tRGF0ZShkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIFRpbWVzdGFtcC5mcm9tTWlsbGlzKGRhdGUuZ2V0VGltZSgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0aW1lc3RhbXAgZnJvbSB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWlsbGlzZWNvbmRzIC0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSBVbml4IGVwb2NoXHJcbiAgICAgKiAgICAgMTk3MC0wMS0wMVQwMDowMDowMFouXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBgVGltZXN0YW1wYCByZXByZXNlbnRpbmcgdGhlIHNhbWUgcG9pbnQgaW4gdGltZSBhcyB0aGUgZ2l2ZW5cclxuICAgICAqICAgICBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbU1pbGxpcyhtaWxsaXNlY29uZHMpIHtcclxuICAgICAgICBjb25zdCBzZWNvbmRzID0gTWF0aC5mbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcclxuICAgICAgICBjb25zdCBuYW5vcyA9IE1hdGguZmxvb3IoKG1pbGxpc2Vjb25kcyAtIHNlY29uZHMgKiAxMDAwKSAqIE1TX1RPX05BTk9TKTtcclxuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChzZWNvbmRzLCBuYW5vcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgYFRpbWVzdGFtcGAgdG8gYSBKYXZhU2NyaXB0IGBEYXRlYCBvYmplY3QuIFRoaXMgY29udmVyc2lvblxyXG4gICAgICogY2F1c2VzIGEgbG9zcyBvZiBwcmVjaXNpb24gc2luY2UgYERhdGVgIG9iamVjdHMgb25seSBzdXBwb3J0IG1pbGxpc2Vjb25kXHJcbiAgICAgKiBwcmVjaXNpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgSmF2YVNjcmlwdCBgRGF0ZWAgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2FtZSBwb2ludCBpbiB0aW1lIGFzXHJcbiAgICAgKiAgICAgdGhpcyBgVGltZXN0YW1wYCwgd2l0aCBtaWxsaXNlY29uZCBwcmVjaXNpb24uXHJcbiAgICAgKi9cclxuICAgIHRvRGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy50b01pbGxpcygpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYSBgVGltZXN0YW1wYCB0byBhIG51bWVyaWMgdGltZXN0YW1wIChpbiBtaWxsaXNlY29uZHMgc2luY2VcclxuICAgICAqIGVwb2NoKS4gVGhpcyBvcGVyYXRpb24gY2F1c2VzIGEgbG9zcyBvZiBwcmVjaXNpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIHBvaW50IGluIHRpbWUgY29ycmVzcG9uZGluZyB0byB0aGlzIHRpbWVzdGFtcCwgcmVwcmVzZW50ZWQgYXNcclxuICAgICAqICAgICB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSBVbml4IGVwb2NoIDE5NzAtMDEtMDFUMDA6MDA6MDBaLlxyXG4gICAgICovXHJcbiAgICB0b01pbGxpcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWNvbmRzICogMTAwMCArIHRoaXMubmFub3NlY29uZHMgLyBNU19UT19OQU5PUztcclxuICAgIH1cclxuICAgIF9jb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWNvbmRzID09PSBvdGhlci5zZWNvbmRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKHRoaXMubmFub3NlY29uZHMsIG90aGVyLm5hbm9zZWNvbmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IodGhpcy5zZWNvbmRzLCBvdGhlci5zZWNvbmRzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYFRpbWVzdGFtcGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgYFRpbWVzdGFtcGAgdG8gY29tcGFyZSBhZ2FpbnN0LlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGBUaW1lc3RhbXBgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXHJcbiAgICAgKi9cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKG90aGVyLnNlY29uZHMgPT09IHRoaXMuc2Vjb25kcyAmJiBvdGhlci5uYW5vc2Vjb25kcyA9PT0gdGhpcy5uYW5vc2Vjb25kcyk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBhIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBgVGltZXN0YW1wYC4gKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAoJ1RpbWVzdGFtcChzZWNvbmRzPScgK1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZHMgK1xyXG4gICAgICAgICAgICAnLCBuYW5vc2Vjb25kcz0nICtcclxuICAgICAgICAgICAgdGhpcy5uYW5vc2Vjb25kcyArXHJcbiAgICAgICAgICAgICcpJyk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgYFRpbWVzdGFtcGAuICovXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgc2Vjb25kczogdGhpcy5zZWNvbmRzLCBuYW5vc2Vjb25kczogdGhpcy5uYW5vc2Vjb25kcyB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIG9iamVjdCB0byBhIHByaW1pdGl2ZSBzdHJpbmcsIHdoaWNoIGFsbG93cyBgVGltZXN0YW1wYCBvYmplY3RzXHJcbiAgICAgKiB0byBiZSBjb21wYXJlZCB1c2luZyB0aGUgYD5gLCBgPD1gLCBgPj1gIGFuZCBgPmAgb3BlcmF0b3JzLlxyXG4gICAgICovXHJcbiAgICB2YWx1ZU9mKCkge1xyXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIHJldHVybnMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gPHNlY29uZHM+LjxuYW5vc2Vjb25kcz4gd2hlcmVcclxuICAgICAgICAvLyA8c2Vjb25kcz4gaXMgdHJhbnNsYXRlZCB0byBoYXZlIGEgbm9uLW5lZ2F0aXZlIHZhbHVlIGFuZCBib3RoIDxzZWNvbmRzPlxyXG4gICAgICAgIC8vIGFuZCA8bmFub3NlY29uZHM+IGFyZSBsZWZ0LXBhZGRlZCB3aXRoIHplcm9lcyB0byBiZSBhIGNvbnNpc3RlbnQgbGVuZ3RoLlxyXG4gICAgICAgIC8vIFN0cmluZ3Mgd2l0aCB0aGlzIGZvcm1hdCB0aGVuIGhhdmUgYSBsZXhpb2dyYXBoaWNhbCBvcmRlcmluZyB0aGF0IG1hdGNoZXNcclxuICAgICAgICAvLyB0aGUgZXhwZWN0ZWQgb3JkZXJpbmcuIFRoZSA8c2Vjb25kcz4gdHJhbnNsYXRpb24gaXMgZG9uZSB0byBhdm9pZCBoYXZpbmdcclxuICAgICAgICAvLyBhIGxlYWRpbmcgbmVnYXRpdmUgc2lnbiAoaS5lLiBhIGxlYWRpbmcgJy0nIGNoYXJhY3RlcikgaW4gaXRzIHN0cmluZ1xyXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uLCB3aGljaCB3b3VsZCBhZmZlY3QgaXRzIGxleGlvZ3JhcGhpY2FsIG9yZGVyaW5nLlxyXG4gICAgICAgIGNvbnN0IGFkanVzdGVkU2Vjb25kcyA9IHRoaXMuc2Vjb25kcyAtIE1JTl9TRUNPTkRTO1xyXG4gICAgICAgIC8vIE5vdGU6IFVwIHRvIDEyIGRlY2ltYWwgZGlnaXRzIGFyZSByZXF1aXJlZCB0byByZXByZXNlbnQgYWxsIHZhbGlkXHJcbiAgICAgICAgLy8gJ3NlY29uZHMnIHZhbHVlcy5cclxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRTZWNvbmRzID0gU3RyaW5nKGFkanVzdGVkU2Vjb25kcykucGFkU3RhcnQoMTIsICcwJyk7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkTmFub3NlY29uZHMgPSBTdHJpbmcodGhpcy5uYW5vc2Vjb25kcykucGFkU3RhcnQoOSwgJzAnKTtcclxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkU2Vjb25kcyArICcuJyArIGZvcm1hdHRlZE5hbm9zZWNvbmRzO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgbG9jYWxseS1hcHBsaWVkIFNlcnZlclRpbWVzdGFtcC5cclxuICpcclxuICogU2VydmVyIFRpbWVzdGFtcHMgYXJlIGJhY2tlZCBieSBNYXBWYWx1ZXMgdGhhdCBjb250YWluIGFuIGludGVybmFsIGZpZWxkXHJcbiAqIGBfX3R5cGVfX2Agd2l0aCBhIHZhbHVlIG9mIGBzZXJ2ZXJfdGltZXN0YW1wYC4gVGhlIHByZXZpb3VzIHZhbHVlIGFuZCBsb2NhbFxyXG4gKiB3cml0ZSB0aW1lIGFyZSBzdG9yZWQgaW4gaXRzIGBfX3ByZXZpb3VzX3ZhbHVlX19gIGFuZCBgX19sb2NhbF93cml0ZV90aW1lX19gXHJcbiAqIGZpZWxkcyByZXNwZWN0aXZlbHkuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIFNlcnZlclRpbWVzdGFtcFZhbHVlIGluc3RhbmNlcyBhcmUgY3JlYXRlZCBhcyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGFcclxuICogICB0cmFuc2Zvcm0uIFRoZXkgY2FuIG9ubHkgZXhpc3QgaW4gdGhlIGxvY2FsIHZpZXcgb2YgYSBkb2N1bWVudC4gVGhlcmVmb3JlXHJcbiAqICAgdGhleSBkbyBub3QgbmVlZCB0byBiZSBwYXJzZWQgb3Igc2VyaWFsaXplZC5cclxuICogLSBXaGVuIGV2YWx1YXRlZCBsb2NhbGx5IChlLmcuIGZvciBzbmFwc2hvdC5kYXRhKCkpLCB0aGV5IGJ5IGRlZmF1bHRcclxuICogICBldmFsdWF0ZSB0byBgbnVsbGAuIFRoaXMgYmVoYXZpb3IgY2FuIGJlIGNvbmZpZ3VyZWQgYnkgcGFzc2luZyBjdXN0b21cclxuICogICBGaWVsZFZhbHVlT3B0aW9ucyB0byB2YWx1ZSgpLlxyXG4gKiAtIFdpdGggcmVzcGVjdCB0byBvdGhlciBTZXJ2ZXJUaW1lc3RhbXBWYWx1ZXMsIHRoZXkgc29ydCBieSB0aGVpclxyXG4gKiAgIGxvY2FsV3JpdGVUaW1lLlxyXG4gKi9cclxuY29uc3QgU0VSVkVSX1RJTUVTVEFNUF9TRU5USU5FTCA9ICdzZXJ2ZXJfdGltZXN0YW1wJztcclxuY29uc3QgVFlQRV9LRVkgPSAnX190eXBlX18nO1xyXG5jb25zdCBQUkVWSU9VU19WQUxVRV9LRVkgPSAnX19wcmV2aW91c192YWx1ZV9fJztcclxuY29uc3QgTE9DQUxfV1JJVEVfVElNRV9LRVkgPSAnX19sb2NhbF93cml0ZV90aW1lX18nO1xyXG5mdW5jdGlvbiBpc1NlcnZlclRpbWVzdGFtcCh2YWx1ZSkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGNvbnN0IHR5cGUgPSAoX2IgPSAoKChfYSA9IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5tYXBWYWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpZWxkcykgfHwge30pW1RZUEVfS0VZXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0cmluZ1ZhbHVlO1xyXG4gICAgcmV0dXJuIHR5cGUgPT09IFNFUlZFUl9USU1FU1RBTVBfU0VOVElORUw7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZCBiZWZvcmUgdGhpcyBTZXJ2ZXJUaW1lc3RhbXAgd2FzIHNldC5cclxuICpcclxuICogUHJlc2VydmluZyB0aGUgcHJldmlvdXMgdmFsdWVzIGFsbG93cyB0aGUgdXNlciB0byBkaXNwbGF5IHRoZSBsYXN0IHJlc29sZWRcclxuICogdmFsdWUgdW50aWwgdGhlIGJhY2tlbmQgcmVzcG9uZHMgd2l0aCB0aGUgdGltZXN0YW1wLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UHJldmlvdXNWYWx1ZSh2YWx1ZSkge1xyXG4gICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHZhbHVlLm1hcFZhbHVlLmZpZWxkc1tQUkVWSU9VU19WQUxVRV9LRVldO1xyXG4gICAgaWYgKGlzU2VydmVyVGltZXN0YW1wKHByZXZpb3VzVmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFByZXZpb3VzVmFsdWUocHJldmlvdXNWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbG9jYWwgdGltZSBhdCB3aGljaCB0aGlzIHRpbWVzdGFtcCB3YXMgZmlyc3Qgc2V0LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TG9jYWxXcml0ZVRpbWUodmFsdWUpIHtcclxuICAgIGNvbnN0IGxvY2FsV3JpdGVUaW1lID0gbm9ybWFsaXplVGltZXN0YW1wKHZhbHVlLm1hcFZhbHVlLmZpZWxkc1tMT0NBTF9XUklURV9USU1FX0tFWV0udGltZXN0YW1wVmFsdWUpO1xyXG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAobG9jYWxXcml0ZVRpbWUuc2Vjb25kcywgbG9jYWxXcml0ZVRpbWUubmFub3MpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IE1BWF9WQUxVRV9UWVBFID0gJ19fbWF4X18nO1xyXG5jb25zdCBNQVhfVkFMVUUgPSB7XHJcbiAgICBtYXBWYWx1ZToge1xyXG4gICAgICAgIGZpZWxkczoge1xyXG4gICAgICAgICAgICAnX190eXBlX18nOiB7IHN0cmluZ1ZhbHVlOiBNQVhfVkFMVUVfVFlQRSB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vKiogRXh0cmFjdHMgdGhlIGJhY2tlbmQncyB0eXBlIG9yZGVyIGZvciB0aGUgcHJvdmlkZWQgdmFsdWUuICovXHJcbmZ1bmN0aW9uIHR5cGVPcmRlcih2YWx1ZSkge1xyXG4gICAgaWYgKCdudWxsVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIDAgLyogVHlwZU9yZGVyLk51bGxWYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdib29sZWFuVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIDEgLyogVHlwZU9yZGVyLkJvb2xlYW5WYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIHZhbHVlIHx8ICdkb3VibGVWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gMiAvKiBUeXBlT3JkZXIuTnVtYmVyVmFsdWUgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgndGltZXN0YW1wVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIDMgLyogVHlwZU9yZGVyLlRpbWVzdGFtcFZhbHVlICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ3N0cmluZ1ZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiA1IC8qIFR5cGVPcmRlci5TdHJpbmdWYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdieXRlc1ZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgncmVmZXJlbmNlVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIDcgLyogVHlwZU9yZGVyLlJlZlZhbHVlICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2dlb1BvaW50VmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIDggLyogVHlwZU9yZGVyLkdlb1BvaW50VmFsdWUgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnYXJyYXlWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gOSAvKiBUeXBlT3JkZXIuQXJyYXlWYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdtYXBWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICBpZiAoaXNTZXJ2ZXJUaW1lc3RhbXAodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiA0IC8qIFR5cGVPcmRlci5TZXJ2ZXJUaW1lc3RhbXBWYWx1ZSAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNNYXhWYWx1ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDkwMDcxOTkyNTQ3NDA5OTEgLyogVHlwZU9yZGVyLk1heFZhbHVlICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMTAgLyogVHlwZU9yZGVyLk9iamVjdFZhbHVlICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG4vKiogVGVzdHMgYGxlZnRgIGFuZCBgcmlnaHRgIGZvciBlcXVhbGl0eSBiYXNlZCBvbiB0aGUgYmFja2VuZCBzZW1hbnRpY3MuICovXHJcbmZ1bmN0aW9uIHZhbHVlRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdCA9PT0gcmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxlZnRUeXBlID0gdHlwZU9yZGVyKGxlZnQpO1xyXG4gICAgY29uc3QgcmlnaHRUeXBlID0gdHlwZU9yZGVyKHJpZ2h0KTtcclxuICAgIGlmIChsZWZ0VHlwZSAhPT0gcmlnaHRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChsZWZ0VHlwZSkge1xyXG4gICAgICAgIGNhc2UgMCAvKiBUeXBlT3JkZXIuTnVsbFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBjYXNlIDEgLyogVHlwZU9yZGVyLkJvb2xlYW5WYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnQuYm9vbGVhblZhbHVlID09PSByaWdodC5ib29sZWFuVmFsdWU7XHJcbiAgICAgICAgY2FzZSA0IC8qIFR5cGVPcmRlci5TZXJ2ZXJUaW1lc3RhbXBWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGdldExvY2FsV3JpdGVUaW1lKGxlZnQpLmlzRXF1YWwoZ2V0TG9jYWxXcml0ZVRpbWUocmlnaHQpKTtcclxuICAgICAgICBjYXNlIDMgLyogVHlwZU9yZGVyLlRpbWVzdGFtcFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wRXF1YWxzKGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICBjYXNlIDUgLyogVHlwZU9yZGVyLlN0cmluZ1ZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbGVmdC5zdHJpbmdWYWx1ZSA9PT0gcmlnaHQuc3RyaW5nVmFsdWU7XHJcbiAgICAgICAgY2FzZSA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBibG9iRXF1YWxzKGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICBjYXNlIDcgLyogVHlwZU9yZGVyLlJlZlZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbGVmdC5yZWZlcmVuY2VWYWx1ZSA9PT0gcmlnaHQucmVmZXJlbmNlVmFsdWU7XHJcbiAgICAgICAgY2FzZSA4IC8qIFR5cGVPcmRlci5HZW9Qb2ludFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gZ2VvUG9pbnRFcXVhbHMobGVmdCwgcmlnaHQpO1xyXG4gICAgICAgIGNhc2UgMiAvKiBUeXBlT3JkZXIuTnVtYmVyVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJFcXVhbHMobGVmdCwgcmlnaHQpO1xyXG4gICAgICAgIGNhc2UgOSAvKiBUeXBlT3JkZXIuQXJyYXlWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKGxlZnQuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10sIHJpZ2h0LmFycmF5VmFsdWUudmFsdWVzIHx8IFtdLCB2YWx1ZUVxdWFscyk7XHJcbiAgICAgICAgY2FzZSAxMCAvKiBUeXBlT3JkZXIuT2JqZWN0VmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RFcXVhbHMobGVmdCwgcmlnaHQpO1xyXG4gICAgICAgIGNhc2UgOTAwNzE5OTI1NDc0MDk5MSAvKiBUeXBlT3JkZXIuTWF4VmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdGltZXN0YW1wRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAodHlwZW9mIGxlZnQudGltZXN0YW1wVmFsdWUgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgdHlwZW9mIHJpZ2h0LnRpbWVzdGFtcFZhbHVlID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgIGxlZnQudGltZXN0YW1wVmFsdWUubGVuZ3RoID09PSByaWdodC50aW1lc3RhbXBWYWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICAvLyBVc2Ugc3RyaW5nIGVxdWFsaXR5IGZvciBJU08gODYwMSB0aW1lc3RhbXBzXHJcbiAgICAgICAgcmV0dXJuIGxlZnQudGltZXN0YW1wVmFsdWUgPT09IHJpZ2h0LnRpbWVzdGFtcFZhbHVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGVmdFRpbWVzdGFtcCA9IG5vcm1hbGl6ZVRpbWVzdGFtcChsZWZ0LnRpbWVzdGFtcFZhbHVlKTtcclxuICAgIGNvbnN0IHJpZ2h0VGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKHJpZ2h0LnRpbWVzdGFtcFZhbHVlKTtcclxuICAgIHJldHVybiAobGVmdFRpbWVzdGFtcC5zZWNvbmRzID09PSByaWdodFRpbWVzdGFtcC5zZWNvbmRzICYmXHJcbiAgICAgICAgbGVmdFRpbWVzdGFtcC5uYW5vcyA9PT0gcmlnaHRUaW1lc3RhbXAubmFub3MpO1xyXG59XHJcbmZ1bmN0aW9uIGdlb1BvaW50RXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICByZXR1cm4gKG5vcm1hbGl6ZU51bWJlcihsZWZ0Lmdlb1BvaW50VmFsdWUubGF0aXR1ZGUpID09PVxyXG4gICAgICAgIG5vcm1hbGl6ZU51bWJlcihyaWdodC5nZW9Qb2ludFZhbHVlLmxhdGl0dWRlKSAmJlxyXG4gICAgICAgIG5vcm1hbGl6ZU51bWJlcihsZWZ0Lmdlb1BvaW50VmFsdWUubG9uZ2l0dWRlKSA9PT1cclxuICAgICAgICAgICAgbm9ybWFsaXplTnVtYmVyKHJpZ2h0Lmdlb1BvaW50VmFsdWUubG9uZ2l0dWRlKSk7XHJcbn1cclxuZnVuY3Rpb24gYmxvYkVxdWFscyhsZWZ0LCByaWdodCkge1xyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZUJ5dGVTdHJpbmcobGVmdC5ieXRlc1ZhbHVlKS5pc0VxdWFsKG5vcm1hbGl6ZUJ5dGVTdHJpbmcocmlnaHQuYnl0ZXNWYWx1ZSkpO1xyXG59XHJcbmZ1bmN0aW9uIG51bWJlckVxdWFscyhsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIGxlZnQgJiYgJ2ludGVnZXJWYWx1ZScgaW4gcmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gKG5vcm1hbGl6ZU51bWJlcihsZWZ0LmludGVnZXJWYWx1ZSkgPT09IG5vcm1hbGl6ZU51bWJlcihyaWdodC5pbnRlZ2VyVmFsdWUpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdkb3VibGVWYWx1ZScgaW4gbGVmdCAmJiAnZG91YmxlVmFsdWUnIGluIHJpZ2h0KSB7XHJcbiAgICAgICAgY29uc3QgbjEgPSBub3JtYWxpemVOdW1iZXIobGVmdC5kb3VibGVWYWx1ZSk7XHJcbiAgICAgICAgY29uc3QgbjIgPSBub3JtYWxpemVOdW1iZXIocmlnaHQuZG91YmxlVmFsdWUpO1xyXG4gICAgICAgIGlmIChuMSA9PT0gbjIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTmVnYXRpdmVaZXJvKG4xKSA9PT0gaXNOZWdhdGl2ZVplcm8objIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKG4xKSAmJiBpc05hTihuMik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIG9iamVjdEVxdWFscyhsZWZ0LCByaWdodCkge1xyXG4gICAgY29uc3QgbGVmdE1hcCA9IGxlZnQubWFwVmFsdWUuZmllbGRzIHx8IHt9O1xyXG4gICAgY29uc3QgcmlnaHRNYXAgPSByaWdodC5tYXBWYWx1ZS5maWVsZHMgfHwge307XHJcbiAgICBpZiAob2JqZWN0U2l6ZShsZWZ0TWFwKSAhPT0gb2JqZWN0U2l6ZShyaWdodE1hcCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBsZWZ0TWFwKSB7XHJcbiAgICAgICAgaWYgKGxlZnRNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICBpZiAocmlnaHRNYXBba2V5XSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgICAgICAhdmFsdWVFcXVhbHMobGVmdE1hcFtrZXldLCByaWdodE1hcFtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgQXJyYXlWYWx1ZSBjb250YWlucyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuICovXHJcbmZ1bmN0aW9uIGFycmF5VmFsdWVDb250YWlucyhoYXlzdGFjaywgbmVlZGxlKSB7XHJcbiAgICByZXR1cm4gKChoYXlzdGFjay52YWx1ZXMgfHwgW10pLmZpbmQodiA9PiB2YWx1ZUVxdWFscyh2LCBuZWVkbGUpKSAhPT0gdW5kZWZpbmVkKTtcclxufVxyXG5mdW5jdGlvbiB2YWx1ZUNvbXBhcmUobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0ID09PSByaWdodCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGVmdFR5cGUgPSB0eXBlT3JkZXIobGVmdCk7XHJcbiAgICBjb25zdCByaWdodFR5cGUgPSB0eXBlT3JkZXIocmlnaHQpO1xyXG4gICAgaWYgKGxlZnRUeXBlICE9PSByaWdodFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0VHlwZSwgcmlnaHRUeXBlKTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAobGVmdFR5cGUpIHtcclxuICAgICAgICBjYXNlIDAgLyogVHlwZU9yZGVyLk51bGxWYWx1ZSAqLzpcclxuICAgICAgICBjYXNlIDkwMDcxOTkyNTQ3NDA5OTEgLyogVHlwZU9yZGVyLk1heFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICBjYXNlIDEgLyogVHlwZU9yZGVyLkJvb2xlYW5WYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC5ib29sZWFuVmFsdWUsIHJpZ2h0LmJvb2xlYW5WYWx1ZSk7XHJcbiAgICAgICAgY2FzZSAyIC8qIFR5cGVPcmRlci5OdW1iZXJWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVOdW1iZXJzKGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICBjYXNlIDMgLyogVHlwZU9yZGVyLlRpbWVzdGFtcFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVRpbWVzdGFtcHMobGVmdC50aW1lc3RhbXBWYWx1ZSwgcmlnaHQudGltZXN0YW1wVmFsdWUpO1xyXG4gICAgICAgIGNhc2UgNCAvKiBUeXBlT3JkZXIuU2VydmVyVGltZXN0YW1wVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlVGltZXN0YW1wcyhnZXRMb2NhbFdyaXRlVGltZShsZWZ0KSwgZ2V0TG9jYWxXcml0ZVRpbWUocmlnaHQpKTtcclxuICAgICAgICBjYXNlIDUgLyogVHlwZU9yZGVyLlN0cmluZ1ZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LnN0cmluZ1ZhbHVlLCByaWdodC5zdHJpbmdWYWx1ZSk7XHJcbiAgICAgICAgY2FzZSA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlQmxvYnMobGVmdC5ieXRlc1ZhbHVlLCByaWdodC5ieXRlc1ZhbHVlKTtcclxuICAgICAgICBjYXNlIDcgLyogVHlwZU9yZGVyLlJlZlZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVJlZmVyZW5jZXMobGVmdC5yZWZlcmVuY2VWYWx1ZSwgcmlnaHQucmVmZXJlbmNlVmFsdWUpO1xyXG4gICAgICAgIGNhc2UgOCAvKiBUeXBlT3JkZXIuR2VvUG9pbnRWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVHZW9Qb2ludHMobGVmdC5nZW9Qb2ludFZhbHVlLCByaWdodC5nZW9Qb2ludFZhbHVlKTtcclxuICAgICAgICBjYXNlIDkgLyogVHlwZU9yZGVyLkFycmF5VmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlQXJyYXlzKGxlZnQuYXJyYXlWYWx1ZSwgcmlnaHQuYXJyYXlWYWx1ZSk7XHJcbiAgICAgICAgY2FzZSAxMCAvKiBUeXBlT3JkZXIuT2JqZWN0VmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlTWFwcyhsZWZ0Lm1hcFZhbHVlLCByaWdodC5tYXBWYWx1ZSk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBjb25zdCBsZWZ0TnVtYmVyID0gbm9ybWFsaXplTnVtYmVyKGxlZnQuaW50ZWdlclZhbHVlIHx8IGxlZnQuZG91YmxlVmFsdWUpO1xyXG4gICAgY29uc3QgcmlnaHROdW1iZXIgPSBub3JtYWxpemVOdW1iZXIocmlnaHQuaW50ZWdlclZhbHVlIHx8IHJpZ2h0LmRvdWJsZVZhbHVlKTtcclxuICAgIGlmIChsZWZ0TnVtYmVyIDwgcmlnaHROdW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChsZWZ0TnVtYmVyID4gcmlnaHROdW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxlZnROdW1iZXIgPT09IHJpZ2h0TnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBvbmUgb3IgYm90aCBhcmUgTmFOLlxyXG4gICAgICAgIGlmIChpc05hTihsZWZ0TnVtYmVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNOYU4ocmlnaHROdW1iZXIpID8gMCA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmVUaW1lc3RhbXBzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAodHlwZW9mIGxlZnQgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgdHlwZW9mIHJpZ2h0ID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgIGxlZnQubGVuZ3RoID09PSByaWdodC5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LCByaWdodCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsZWZ0VGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKGxlZnQpO1xyXG4gICAgY29uc3QgcmlnaHRUaW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAocmlnaHQpO1xyXG4gICAgY29uc3QgY29tcGFyaXNvbiA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFRpbWVzdGFtcC5zZWNvbmRzLCByaWdodFRpbWVzdGFtcC5zZWNvbmRzKTtcclxuICAgIGlmIChjb21wYXJpc29uICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmlzb247XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0VGltZXN0YW1wLm5hbm9zLCByaWdodFRpbWVzdGFtcC5uYW5vcyk7XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZVJlZmVyZW5jZXMobGVmdFBhdGgsIHJpZ2h0UGF0aCkge1xyXG4gICAgY29uc3QgbGVmdFNlZ21lbnRzID0gbGVmdFBhdGguc3BsaXQoJy8nKTtcclxuICAgIGNvbnN0IHJpZ2h0U2VnbWVudHMgPSByaWdodFBhdGguc3BsaXQoJy8nKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdFNlZ21lbnRzLmxlbmd0aCAmJiBpIDwgcmlnaHRTZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNvbXBhcmlzb24gPSBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRTZWdtZW50c1tpXSwgcmlnaHRTZWdtZW50c1tpXSk7XHJcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFNlZ21lbnRzLmxlbmd0aCwgcmlnaHRTZWdtZW50cy5sZW5ndGgpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmVHZW9Qb2ludHMobGVmdCwgcmlnaHQpIHtcclxuICAgIGNvbnN0IGNvbXBhcmlzb24gPSBwcmltaXRpdmVDb21wYXJhdG9yKG5vcm1hbGl6ZU51bWJlcihsZWZ0LmxhdGl0dWRlKSwgbm9ybWFsaXplTnVtYmVyKHJpZ2h0LmxhdGl0dWRlKSk7XHJcbiAgICBpZiAoY29tcGFyaXNvbiAhPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBjb21wYXJpc29uO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3Iobm9ybWFsaXplTnVtYmVyKGxlZnQubG9uZ2l0dWRlKSwgbm9ybWFsaXplTnVtYmVyKHJpZ2h0LmxvbmdpdHVkZSkpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmVCbG9icyhsZWZ0LCByaWdodCkge1xyXG4gICAgY29uc3QgbGVmdEJ5dGVzID0gbm9ybWFsaXplQnl0ZVN0cmluZyhsZWZ0KTtcclxuICAgIGNvbnN0IHJpZ2h0Qnl0ZXMgPSBub3JtYWxpemVCeXRlU3RyaW5nKHJpZ2h0KTtcclxuICAgIHJldHVybiBsZWZ0Qnl0ZXMuY29tcGFyZVRvKHJpZ2h0Qnl0ZXMpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmVBcnJheXMobGVmdCwgcmlnaHQpIHtcclxuICAgIGNvbnN0IGxlZnRBcnJheSA9IGxlZnQudmFsdWVzIHx8IFtdO1xyXG4gICAgY29uc3QgcmlnaHRBcnJheSA9IHJpZ2h0LnZhbHVlcyB8fCBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEFycmF5Lmxlbmd0aCAmJiBpIDwgcmlnaHRBcnJheS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IGNvbXBhcmUgPSB2YWx1ZUNvbXBhcmUobGVmdEFycmF5W2ldLCByaWdodEFycmF5W2ldKTtcclxuICAgICAgICBpZiAoY29tcGFyZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0QXJyYXkubGVuZ3RoLCByaWdodEFycmF5Lmxlbmd0aCk7XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZU1hcHMobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0ID09PSBNQVhfVkFMVUUubWFwVmFsdWUgJiYgcmlnaHQgPT09IE1BWF9WQUxVRS5tYXBWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGVmdCA9PT0gTUFYX1ZBTFVFLm1hcFZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyaWdodCA9PT0gTUFYX1ZBTFVFLm1hcFZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGVmdE1hcCA9IGxlZnQuZmllbGRzIHx8IHt9O1xyXG4gICAgY29uc3QgbGVmdEtleXMgPSBPYmplY3Qua2V5cyhsZWZ0TWFwKTtcclxuICAgIGNvbnN0IHJpZ2h0TWFwID0gcmlnaHQuZmllbGRzIHx8IHt9O1xyXG4gICAgY29uc3QgcmlnaHRLZXlzID0gT2JqZWN0LmtleXMocmlnaHRNYXApO1xyXG4gICAgLy8gRXZlbiB0aG91Z2ggTWFwVmFsdWVzIGFyZSBsaWtlbHkgc29ydGVkIGNvcnJlY3RseSBiYXNlZCBvbiB0aGVpciBpbnNlcnRpb25cclxuICAgIC8vIG9yZGVyIChlLmcuIHdoZW4gcmVjZWl2ZWQgZnJvbSB0aGUgYmFja2VuZCksIGxvY2FsIG1vZGlmaWNhdGlvbnMgY2FuIGJyaW5nXHJcbiAgICAvLyBlbGVtZW50cyBvdXQgb2Ygb3JkZXIuIFdlIG5lZWQgdG8gcmUtc29ydCB0aGUgZWxlbWVudHMgdG8gZW5zdXJlIHRoYXRcclxuICAgIC8vIGNhbm9uaWNhbCBJRHMgYXJlIGluZGVwZW5kZW50IG9mIGluc2VydGlvbiBvcmRlci5cclxuICAgIGxlZnRLZXlzLnNvcnQoKTtcclxuICAgIHJpZ2h0S2V5cy5zb3J0KCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnRLZXlzLmxlbmd0aCAmJiBpIDwgcmlnaHRLZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY29uc3Qga2V5Q29tcGFyZSA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdEtleXNbaV0sIHJpZ2h0S2V5c1tpXSk7XHJcbiAgICAgICAgaWYgKGtleUNvbXBhcmUgIT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGtleUNvbXBhcmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbXBhcmUgPSB2YWx1ZUNvbXBhcmUobGVmdE1hcFtsZWZ0S2V5c1tpXV0sIHJpZ2h0TWFwW3JpZ2h0S2V5c1tpXV0pO1xyXG4gICAgICAgIGlmIChjb21wYXJlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRLZXlzLmxlbmd0aCwgcmlnaHRLZXlzLmxlbmd0aCk7XHJcbn1cclxuLyoqIFJldHVybnMgYSByZWZlcmVuY2UgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBkYXRhYmFzZSBhbmQga2V5LiAqL1xyXG5mdW5jdGlvbiByZWZWYWx1ZShkYXRhYmFzZUlkLCBrZXkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVmZXJlbmNlVmFsdWU6IGBwcm9qZWN0cy8ke2RhdGFiYXNlSWQucHJvamVjdElkfS9kYXRhYmFzZXMvJHtkYXRhYmFzZUlkLmRhdGFiYXNlfS9kb2N1bWVudHMvJHtrZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKX1gXHJcbiAgICB9O1xyXG59XHJcbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBBcnJheVZhbHVlLiAqL1xyXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAnYXJyYXlWYWx1ZScgaW4gdmFsdWU7XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgTnVsbFZhbHVlLiAqL1xyXG5mdW5jdGlvbiBpc051bGxWYWx1ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhdmFsdWUgJiYgJ251bGxWYWx1ZScgaW4gdmFsdWU7XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIE5hTi4gKi9cclxuZnVuY3Rpb24gaXNOYW5WYWx1ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhdmFsdWUgJiYgJ2RvdWJsZVZhbHVlJyBpbiB2YWx1ZSAmJiBpc05hTihOdW1iZXIodmFsdWUuZG91YmxlVmFsdWUpKTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBNYXBWYWx1ZS4gKi9cclxuZnVuY3Rpb24gaXNNYXBWYWx1ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhdmFsdWUgJiYgJ21hcFZhbHVlJyBpbiB2YWx1ZTtcclxufVxyXG4vKiogQ3JlYXRlcyBhIGRlZXAgY29weSBvZiBgc291cmNlYC4gKi9cclxuZnVuY3Rpb24gZGVlcENsb25lKHNvdXJjZSkge1xyXG4gICAgaWYgKHNvdXJjZS5nZW9Qb2ludFZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgZ2VvUG9pbnRWYWx1ZTogT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLmdlb1BvaW50VmFsdWUpIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzb3VyY2UudGltZXN0YW1wVmFsdWUgJiZcclxuICAgICAgICB0eXBlb2Ygc291cmNlLnRpbWVzdGFtcFZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHJldHVybiB7IHRpbWVzdGFtcFZhbHVlOiBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UudGltZXN0YW1wVmFsdWUpIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzb3VyY2UubWFwVmFsdWUpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSB7IG1hcFZhbHVlOiB7IGZpZWxkczoge30gfSB9O1xyXG4gICAgICAgIGZvckVhY2goc291cmNlLm1hcFZhbHVlLmZpZWxkcywgKGtleSwgdmFsKSA9PiAodGFyZ2V0Lm1hcFZhbHVlLmZpZWxkc1trZXldID0gZGVlcENsb25lKHZhbCkpKTtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc291cmNlLmFycmF5VmFsdWUpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSB7IGFycmF5VmFsdWU6IHsgdmFsdWVzOiBbXSB9IH07XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAoc291cmNlLmFycmF5VmFsdWUudmFsdWVzIHx8IFtdKS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB0YXJnZXQuYXJyYXlWYWx1ZS52YWx1ZXNbaV0gPSBkZWVwQ2xvbmUoc291cmNlLmFycmF5VmFsdWUudmFsdWVzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UpO1xyXG4gICAgfVxyXG59XHJcbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIFZhbHVlIHJlcHJlc2VudHMgdGhlIGNhbm9uaWNhbCB7QGxpbmsgI01BWF9WQUxVRX0gLiAqL1xyXG5mdW5jdGlvbiBpc01heFZhbHVlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gKCgoKHZhbHVlLm1hcFZhbHVlIHx8IHt9KS5maWVsZHMgfHwge30pWydfX3R5cGVfXyddIHx8IHt9KS5zdHJpbmdWYWx1ZSA9PT1cclxuICAgICAgICBNQVhfVkFMVUVfVFlQRSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBib3VuZCBvZiBhIHF1ZXJ5LlxyXG4gKlxyXG4gKiBUaGUgYm91bmQgaXMgc3BlY2lmaWVkIHdpdGggdGhlIGdpdmVuIGNvbXBvbmVudHMgcmVwcmVzZW50aW5nIGEgcG9zaXRpb24gYW5kXHJcbiAqIHdoZXRoZXIgaXQncyBqdXN0IGJlZm9yZSBvciBqdXN0IGFmdGVyIHRoZSBwb3NpdGlvbiAocmVsYXRpdmUgdG8gd2hhdGV2ZXIgdGhlXHJcbiAqIHF1ZXJ5IG9yZGVyIGlzKS5cclxuICpcclxuICogVGhlIHBvc2l0aW9uIHJlcHJlc2VudHMgYSBsb2dpY2FsIGluZGV4IHBvc2l0aW9uIGZvciBhIHF1ZXJ5LiBJdCdzIGEgcHJlZml4XHJcbiAqIG9mIHZhbHVlcyBmb3IgdGhlIChwb3RlbnRpYWxseSBpbXBsaWNpdCkgb3JkZXIgYnkgY2xhdXNlcyBvZiBhIHF1ZXJ5LlxyXG4gKlxyXG4gKiBCb3VuZCBwcm92aWRlcyBhIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGV0aGVyIGEgZG9jdW1lbnQgY29tZXMgYmVmb3JlIG9yXHJcbiAqIGFmdGVyIGEgYm91bmQuIFRoaXMgaXMgaW5mbHVlbmNlZCBieSB3aGV0aGVyIHRoZSBwb3NpdGlvbiBpcyBqdXN0IGJlZm9yZSBvclxyXG4gKiBqdXN0IGFmdGVyIHRoZSBwcm92aWRlZCB2YWx1ZXMuXHJcbiAqL1xyXG5jbGFzcyBCb3VuZCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbiwgaW5jbHVzaXZlKSB7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMuaW5jbHVzaXZlID0gaW5jbHVzaXZlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGJvdW5kRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdCA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiByaWdodCA9PT0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJpZ2h0ID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQuaW5jbHVzaXZlICE9PSByaWdodC5pbmNsdXNpdmUgfHxcclxuICAgICAgICBsZWZ0LnBvc2l0aW9uLmxlbmd0aCAhPT0gcmlnaHQucG9zaXRpb24ubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0LnBvc2l0aW9uLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbGVmdFBvc2l0aW9uID0gbGVmdC5wb3NpdGlvbltpXTtcclxuICAgICAgICBjb25zdCByaWdodFBvc2l0aW9uID0gcmlnaHQucG9zaXRpb25baV07XHJcbiAgICAgICAgaWYgKCF2YWx1ZUVxdWFscyhsZWZ0UG9zaXRpb24sIHJpZ2h0UG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBGaWx0ZXIge1xyXG59XHJcbmNsYXNzIEZpZWxkRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBvcCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcclxuICAgICAgICB0aGlzLm9wID0gb3A7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZmlsdGVyIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBhcmd1bWVudHMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGUoZmllbGQsIG9wLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChmaWVsZC5pc0tleUZpZWxkKCkpIHtcclxuICAgICAgICAgICAgaWYgKG9wID09PSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8gfHwgb3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVLZXlGaWVsZEluRmlsdGVyKGZpZWxkLCBvcCwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBLZXlGaWVsZEZpbHRlcihmaWVsZCwgb3AsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcCA9PT0gXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlDb250YWluc0ZpbHRlcihmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5GaWx0ZXIoZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm90SW5GaWx0ZXIoZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3AgPT09IFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlDb250YWluc0FueUZpbHRlcihmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWVsZEZpbHRlcihmaWVsZCwgb3AsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlS2V5RmllbGRJbkZpbHRlcihmaWVsZCwgb3AsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wID09PSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi9cclxuICAgICAgICAgICAgPyBuZXcgS2V5RmllbGRJbkZpbHRlcihmaWVsZCwgdmFsdWUpXHJcbiAgICAgICAgICAgIDogbmV3IEtleUZpZWxkTm90SW5GaWx0ZXIoZmllbGQsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcclxuICAgICAgICAvLyBUeXBlcyBkbyBub3QgaGF2ZSB0byBtYXRjaCBpbiBOT1RfRVFVQUwgZmlsdGVycy5cclxuICAgICAgICBpZiAodGhpcy5vcCA9PT0gXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gKG90aGVyICE9PSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXNDb21wYXJpc29uKHZhbHVlQ29tcGFyZShvdGhlciwgdGhpcy52YWx1ZSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT25seSBjb21wYXJlIHR5cGVzIHdpdGggbWF0Y2hpbmcgYmFja2VuZCBvcmRlciAoc3VjaCBhcyBkb3VibGUgYW5kIGludCkuXHJcbiAgICAgICAgcmV0dXJuIChvdGhlciAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICB0eXBlT3JkZXIodGhpcy52YWx1ZSkgPT09IHR5cGVPcmRlcihvdGhlcikgJiZcclxuICAgICAgICAgICAgdGhpcy5tYXRjaGVzQ29tcGFyaXNvbih2YWx1ZUNvbXBhcmUob3RoZXIsIHRoaXMudmFsdWUpKSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzQ29tcGFyaXNvbihjb21wYXJpc29uKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLm9wKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCI8XCIgLyogT3BlcmF0b3IuTEVTU19USEFOICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPCAwO1xyXG4gICAgICAgICAgICBjYXNlIFwiPD1cIiAvKiBPcGVyYXRvci5MRVNTX1RIQU5fT1JfRVFVQUwgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA8PSAwO1xyXG4gICAgICAgICAgICBjYXNlIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uID09PSAwO1xyXG4gICAgICAgICAgICBjYXNlIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiAhPT0gMDtcclxuICAgICAgICAgICAgY2FzZSBcIj5cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU4gKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA+IDA7XHJcbiAgICAgICAgICAgIGNhc2UgXCI+PVwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTl9PUl9FUVVBTCAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uID49IDA7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzSW5lcXVhbGl0eSgpIHtcclxuICAgICAgICByZXR1cm4gKFtcclxuICAgICAgICAgICAgXCI8XCIgLyogT3BlcmF0b3IuTEVTU19USEFOICovLFxyXG4gICAgICAgICAgICBcIjw9XCIgLyogT3BlcmF0b3IuTEVTU19USEFOX09SX0VRVUFMICovLFxyXG4gICAgICAgICAgICBcIj5cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU4gKi8sXHJcbiAgICAgICAgICAgIFwiPj1cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU5fT1JfRVFVQUwgKi8sXHJcbiAgICAgICAgICAgIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi8sXHJcbiAgICAgICAgICAgIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovXHJcbiAgICAgICAgXS5pbmRleE9mKHRoaXMub3ApID49IDApO1xyXG4gICAgfVxyXG4gICAgZ2V0RmxhdHRlbmVkRmlsdGVycygpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXNdO1xyXG4gICAgfVxyXG4gICAgZ2V0RmlsdGVycygpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXNdO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENvbXBvc2l0ZUZpbHRlciBleHRlbmRzIEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJzLCBvcCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcclxuICAgICAgICB0aGlzLm9wID0gb3A7XHJcbiAgICAgICAgdGhpcy5tZW1vaXplZEZsYXR0ZW5lZEZpbHRlcnMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZmlsdGVyIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBhcmd1bWVudHMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGUoZmlsdGVycywgb3ApIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZUZpbHRlcihmaWx0ZXJzLCBvcCk7XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKGRvYykge1xyXG4gICAgICAgIGlmIChjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKHRoaXMpKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBjb25qdW5jdGlvbnMsIGFsbCBmaWx0ZXJzIG11c3QgbWF0Y2gsIHNvIHJldHVybiBmYWxzZSBpZiBhbnkgZmlsdGVyIGRvZXNuJ3QgbWF0Y2guXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcnMuZmluZChmaWx0ZXIgPT4gIWZpbHRlci5tYXRjaGVzKGRvYykpID09PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGb3IgZGlzanVuY3Rpb25zLCBhdCBsZWFzdCBvbmUgZmlsdGVyIHNob3VsZCBtYXRjaC5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVycy5maW5kKGZpbHRlciA9PiBmaWx0ZXIubWF0Y2hlcyhkb2MpKSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEZsYXR0ZW5lZEZpbHRlcnMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubWVtb2l6ZWRGbGF0dGVuZWRGaWx0ZXJzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbW9pemVkRmxhdHRlbmVkRmlsdGVycztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tZW1vaXplZEZsYXR0ZW5lZEZpbHRlcnMgPSB0aGlzLmZpbHRlcnMucmVkdWNlKChyZXN1bHQsIHN1YmZpbHRlcikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChzdWJmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpKTtcclxuICAgICAgICB9LCBbXSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtb2l6ZWRGbGF0dGVuZWRGaWx0ZXJzO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBhIG11dGFibGUgY29weSBvZiBgdGhpcy5maWx0ZXJzYFxyXG4gICAgZ2V0RmlsdGVycygpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihbXSwgdGhpcy5maWx0ZXJzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKGNvbXBvc2l0ZUZpbHRlcikge1xyXG4gICAgcmV0dXJuIGNvbXBvc2l0ZUZpbHRlci5vcCA9PT0gXCJhbmRcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5BTkQgKi87XHJcbn1cclxuZnVuY3Rpb24gZmlsdGVyRXF1YWxzKGYxLCBmMikge1xyXG4gICAgaWYgKGYxIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcclxuICAgICAgICByZXR1cm4gZmllbGRGaWx0ZXJFcXVhbHMoZjEsIGYyKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGYxIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUZpbHRlckVxdWFscyhmMSwgZjIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZpZWxkRmlsdGVyRXF1YWxzKGYxLCBmMikge1xyXG4gICAgcmV0dXJuIChmMiBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyICYmXHJcbiAgICAgICAgZjEub3AgPT09IGYyLm9wICYmXHJcbiAgICAgICAgZjEuZmllbGQuaXNFcXVhbChmMi5maWVsZCkgJiZcclxuICAgICAgICB2YWx1ZUVxdWFscyhmMS52YWx1ZSwgZjIudmFsdWUpKTtcclxufVxyXG5mdW5jdGlvbiBjb21wb3NpdGVGaWx0ZXJFcXVhbHMoZjEsIGYyKSB7XHJcbiAgICBpZiAoZjIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIgJiZcclxuICAgICAgICBmMS5vcCA9PT0gZjIub3AgJiZcclxuICAgICAgICBmMS5maWx0ZXJzLmxlbmd0aCA9PT0gZjIuZmlsdGVycy5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBzdWJGaWx0ZXJzTWF0Y2ggPSBmMS5maWx0ZXJzLnJlZHVjZSgocmVzdWx0LCBmMUZpbHRlciwgaW5kZXgpID0+IHJlc3VsdCAmJiBmaWx0ZXJFcXVhbHMoZjFGaWx0ZXIsIGYyLmZpbHRlcnNbaW5kZXhdKSwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHN1YkZpbHRlcnNNYXRjaDtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKiogRmlsdGVyIHRoYXQgbWF0Y2hlcyBvbiBrZXkgZmllbGRzIChpLmUuICdfX25hbWVfXycpLiAqL1xyXG5jbGFzcyBLZXlGaWVsZEZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBvcCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgb3AsIHZhbHVlKTtcclxuICAgICAgICB0aGlzLmtleSA9IERvY3VtZW50S2V5LmZyb21OYW1lKHZhbHVlLnJlZmVyZW5jZVZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgY29uc3QgY29tcGFyaXNvbiA9IERvY3VtZW50S2V5LmNvbXBhcmF0b3IoZG9jLmtleSwgdGhpcy5rZXkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoZXNDb21wYXJpc29uKGNvbXBhcmlzb24pO1xyXG4gICAgfVxyXG59XHJcbi8qKiBGaWx0ZXIgdGhhdCBtYXRjaGVzIG9uIGtleSBmaWVsZHMgd2l0aGluIGFuIGFycmF5LiAqL1xyXG5jbGFzcyBLZXlGaWVsZEluRmlsdGVyIGV4dGVuZHMgRmllbGRGaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgc3VwZXIoZmllbGQsIFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLywgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMua2V5cyA9IGV4dHJhY3REb2N1bWVudEtleXNGcm9tQXJyYXlWYWx1ZShcImluXCIgLyogT3BlcmF0b3IuSU4gKi8sIHZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cy5zb21lKGtleSA9PiBrZXkuaXNFcXVhbChkb2Mua2V5KSk7XHJcbiAgICB9XHJcbn1cclxuLyoqIEZpbHRlciB0aGF0IG1hdGNoZXMgb24ga2V5IGZpZWxkcyBub3QgcHJlc2VudCB3aXRoaW4gYW4gYXJyYXkuICovXHJcbmNsYXNzIEtleUZpZWxkTm90SW5GaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8sIHZhbHVlKTtcclxuICAgICAgICB0aGlzLmtleXMgPSBleHRyYWN0RG9jdW1lbnRLZXlzRnJvbUFycmF5VmFsdWUoXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8sIHZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmtleXMuc29tZShrZXkgPT4ga2V5LmlzRXF1YWwoZG9jLmtleSkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3REb2N1bWVudEtleXNGcm9tQXJyYXlWYWx1ZShvcCwgdmFsdWUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiAoKChfYSA9IHZhbHVlLmFycmF5VmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZXMpIHx8IFtdKS5tYXAodiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIERvY3VtZW50S2V5LmZyb21OYW1lKHYucmVmZXJlbmNlVmFsdWUpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqIEEgRmlsdGVyIHRoYXQgaW1wbGVtZW50cyB0aGUgYXJyYXktY29udGFpbnMgb3BlcmF0b3IuICovXHJcbmNsYXNzIEFycmF5Q29udGFpbnNGaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKGRvYykge1xyXG4gICAgICAgIGNvbnN0IG90aGVyID0gZG9jLmRhdGEuZmllbGQodGhpcy5maWVsZCk7XHJcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkob3RoZXIpICYmIGFycmF5VmFsdWVDb250YWlucyhvdGhlci5hcnJheVZhbHVlLCB0aGlzLnZhbHVlKTtcclxuICAgIH1cclxufVxyXG4vKiogQSBGaWx0ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBJTiBvcGVyYXRvci4gKi9cclxuY2xhc3MgSW5GaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgXCJpblwiIC8qIE9wZXJhdG9yLklOICovLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKGRvYykge1xyXG4gICAgICAgIGNvbnN0IG90aGVyID0gZG9jLmRhdGEuZmllbGQodGhpcy5maWVsZCk7XHJcbiAgICAgICAgcmV0dXJuIG90aGVyICE9PSBudWxsICYmIGFycmF5VmFsdWVDb250YWlucyh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIG90aGVyKTtcclxuICAgIH1cclxufVxyXG4vKiogQSBGaWx0ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBub3QtaW4gb3BlcmF0b3IuICovXHJcbmNsYXNzIE5vdEluRmlsdGVyIGV4dGVuZHMgRmllbGRGaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgc3VwZXIoZmllbGQsIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKGRvYykge1xyXG4gICAgICAgIGlmIChhcnJheVZhbHVlQ29udGFpbnModGhpcy52YWx1ZS5hcnJheVZhbHVlLCB7IG51bGxWYWx1ZTogJ05VTExfVkFMVUUnIH0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcclxuICAgICAgICByZXR1cm4gb3RoZXIgIT09IG51bGwgJiYgIWFycmF5VmFsdWVDb250YWlucyh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIG90aGVyKTtcclxuICAgIH1cclxufVxyXG4vKiogQSBGaWx0ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBhcnJheS1jb250YWlucy1hbnkgb3BlcmF0b3IuICovXHJcbmNsYXNzIEFycmF5Q29udGFpbnNBbnlGaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi8sIHZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcclxuICAgICAgICBpZiAoIWlzQXJyYXkob3RoZXIpIHx8ICFvdGhlci5hcnJheVZhbHVlLnZhbHVlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdGhlci5hcnJheVZhbHVlLnZhbHVlcy5zb21lKHZhbCA9PiBhcnJheVZhbHVlQ29udGFpbnModGhpcy52YWx1ZS5hcnJheVZhbHVlLCB2YWwpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gb3JkZXJpbmcgb24gYSBmaWVsZCwgaW4gc29tZSBEaXJlY3Rpb24uIERpcmVjdGlvbiBkZWZhdWx0cyB0byBBU0NFTkRJTkcuXHJcbiAqL1xyXG5jbGFzcyBPcmRlckJ5IHtcclxuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBkaXIgPSBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi8pIHtcclxuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XHJcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gb3JkZXJCeUVxdWFscyhsZWZ0LCByaWdodCkge1xyXG4gICAgcmV0dXJuIGxlZnQuZGlyID09PSByaWdodC5kaXIgJiYgbGVmdC5maWVsZC5pc0VxdWFsKHJpZ2h0LmZpZWxkKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSB2ZXJzaW9uIG9mIGEgZG9jdW1lbnQgaW4gRmlyZXN0b3JlLiBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSB2ZXJzaW9uXHJcbiAqIHRpbWVzdGFtcCwgc3VjaCBhcyB1cGRhdGVfdGltZSBvciByZWFkX3RpbWUuXHJcbiAqL1xyXG5jbGFzcyBTbmFwc2hvdFZlcnNpb24ge1xyXG4gICAgY29uc3RydWN0b3IodGltZXN0YW1wKSB7XHJcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVRpbWVzdGFtcCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU25hcHNob3RWZXJzaW9uKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBtaW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTbmFwc2hvdFZlcnNpb24obmV3IFRpbWVzdGFtcCgwLCAwKSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbWF4KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU25hcHNob3RWZXJzaW9uKG5ldyBUaW1lc3RhbXAoMjUzNDAyMzAwNzk5LCAxZTkgLSAxKSk7XHJcbiAgICB9XHJcbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXAuX2NvbXBhcmVUbyhvdGhlci50aW1lc3RhbXApO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcC5pc0VxdWFsKG90aGVyLnRpbWVzdGFtcCk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBhIG51bWJlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVyc2lvbiBmb3IgdXNlIGluIHNwZWMgdGVzdHMuICovXHJcbiAgICB0b01pY3Jvc2Vjb25kcygpIHtcclxuICAgICAgICAvLyBDb252ZXJ0IHRvIG1pY3Jvc2Vjb25kcy5cclxuICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXAuc2Vjb25kcyAqIDFlNiArIHRoaXMudGltZXN0YW1wLm5hbm9zZWNvbmRzIC8gMTAwMDtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnU25hcHNob3RWZXJzaW9uKCcgKyB0aGlzLnRpbWVzdGFtcC50b1N0cmluZygpICsgJyknO1xyXG4gICAgfVxyXG4gICAgdG9UaW1lc3RhbXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIEFuIGltbXV0YWJsZSBzb3J0ZWQgbWFwIGltcGxlbWVudGF0aW9uLCBiYXNlZCBvbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2tcclxuLy8gdHJlZS5cclxuY2xhc3MgU29ydGVkTWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3IsIHJvb3QpIHtcclxuICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xyXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3QgPyByb290IDogTExSQk5vZGUuRU1QVFk7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgbWFwLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5L3ZhbHVlIGFkZGVkIG9yIHJlcGxhY2VkLlxyXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3IsIHRoaXMucm9vdFxyXG4gICAgICAgICAgICAuaW5zZXJ0KGtleSwgdmFsdWUsIHRoaXMuY29tcGFyYXRvcilcclxuICAgICAgICAgICAgLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXAsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkgcmVtb3ZlZC5cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3IsIHRoaXMucm9vdFxyXG4gICAgICAgICAgICAucmVtb3ZlKGtleSwgdGhpcy5jb21wYXJhdG9yKVxyXG4gICAgICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4ga2V5LCBvciBudWxsLlxyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5yb290O1xyXG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgY29uc3QgY21wID0gdGhpcy5jb21wYXJhdG9yKGtleSwgbm9kZS5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhpcyBzb3J0ZWQgbWFwLCBvciAtMSBpZiBpdCBkb2Vzbid0XHJcbiAgICAvLyBleGlzdC5cclxuICAgIGluZGV4T2Yoa2V5KSB7XHJcbiAgICAgICAgLy8gTnVtYmVyIG9mIG5vZGVzIHRoYXQgd2VyZSBwcnVuZWQgd2hlbiBkZXNjZW5kaW5nIHJpZ2h0XHJcbiAgICAgICAgbGV0IHBydW5lZE5vZGVzID0gMDtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucm9vdDtcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNtcCA9IHRoaXMuY29tcGFyYXRvcihrZXksIG5vZGUua2V5KTtcclxuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBydW5lZE5vZGVzICsgbm9kZS5sZWZ0LnNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIENvdW50IGFsbCBub2RlcyBsZWZ0IG9mIHRoZSBub2RlIHBsdXMgdGhlIG5vZGUgaXRzZWxmXHJcbiAgICAgICAgICAgICAgICBwcnVuZWROb2RlcyArPSBub2RlLmxlZnQuc2l6ZSArIDE7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb2RlIG5vdCBmb3VuZFxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIG1hcC5cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Quc2l6ZTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIG1pbmltdW0ga2V5IGluIHRoZSBtYXAuXHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5taW5LZXkoKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIG1heGltdW0ga2V5IGluIHRoZSBtYXAuXHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5tYXhLZXkoKTtcclxuICAgIH1cclxuICAgIC8vIFRyYXZlcnNlcyB0aGUgbWFwIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgIC8vIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cclxuICAgIC8vIFJldHVybnMgdGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxyXG4gICAgLy8gdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLlxyXG4gICAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Lmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKTtcclxuICAgIH1cclxuICAgIGZvckVhY2goZm4pIHtcclxuICAgICAgICB0aGlzLmlub3JkZXJUcmF2ZXJzYWwoKGssIHYpID0+IHtcclxuICAgICAgICAgICAgZm4oaywgdik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaW5vcmRlclRyYXZlcnNhbCgoaywgdikgPT4ge1xyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbnMucHVzaChgJHtrfToke3Z9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYHske2Rlc2NyaXB0aW9ucy5qb2luKCcsICcpfX1gO1xyXG4gICAgfVxyXG4gICAgLy8gVHJhdmVyc2VzIHRoZSBtYXAgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uXHJcbiAgICAvLyBmdW5jdGlvbiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci4gSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzXHJcbiAgICAvLyBhYm9ydGVkLlxyXG4gICAgLy8gUmV0dXJucyB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXHJcbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBTb3J0ZWRNYXAuXHJcbiAgICBnZXRJdGVyYXRvcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdCwgbnVsbCwgdGhpcy5jb21wYXJhdG9yLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBnZXRJdGVyYXRvckZyb20oa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3QsIGtleSwgdGhpcy5jb21wYXJhdG9yLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3QsIG51bGwsIHRoaXMuY29tcGFyYXRvciwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGtleSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290LCBrZXksIHRoaXMuY29tcGFyYXRvciwgdHJ1ZSk7XHJcbiAgICB9XHJcbn0gLy8gZW5kIFNvcnRlZE1hcFxyXG4vLyBBbiBpdGVyYXRvciBvdmVyIGFuIExMUkJOb2RlLlxyXG5jbGFzcyBTb3J0ZWRNYXBJdGVyYXRvciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBzdGFydEtleSwgY29tcGFyYXRvciwgaXNSZXZlcnNlKSB7XHJcbiAgICAgICAgdGhpcy5pc1JldmVyc2UgPSBpc1JldmVyc2U7XHJcbiAgICAgICAgdGhpcy5ub2RlU3RhY2sgPSBbXTtcclxuICAgICAgICBsZXQgY21wID0gMTtcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IHN0YXJ0S2V5ID8gY29tcGFyYXRvcihub2RlLmtleSwgc3RhcnRLZXkpIDogMTtcclxuICAgICAgICAgICAgLy8gZmxpcCB0aGUgY29tcGFyaXNvbiBpZiB3ZSdyZSBnb2luZyBpbiByZXZlcnNlXHJcbiAgICAgICAgICAgIGlmIChzdGFydEtleSAmJiBpc1JldmVyc2UpIHtcclxuICAgICAgICAgICAgICAgIGNtcCAqPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGxlc3MgdGhhbiBvdXIgc3RhcnQga2V5LiBpZ25vcmUgaXRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBleGFjdGx5IGVxdWFsIHRvIG91ciBzdGFydCBrZXkuIFB1c2ggaXQgb24gdGhlIHN0YWNrLFxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IHN0b3AgaXRlcmF0aW5nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2sucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGdyZWF0ZXIgdGhhbiBvdXIgc3RhcnQga2V5LCBhZGQgaXQgdG8gdGhlIHN0YWNrIGFuZCBtb3ZlXHJcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgbmV4dCBvbmVcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1JldmVyc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXROZXh0KCkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlU3RhY2sucG9wKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBrZXk6IG5vZGUua2V5LCB2YWx1ZTogbm9kZS52YWx1ZSB9O1xyXG4gICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZSkge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFjay5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFjay5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaGFzTmV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlU3RhY2subGVuZ3RoID4gMDtcclxuICAgIH1cclxuICAgIHBlZWsoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubm9kZVN0YWNrLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZVN0YWNrW3RoaXMubm9kZVN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHJldHVybiB7IGtleTogbm9kZS5rZXksIHZhbHVlOiBub2RlLnZhbHVlIH07XHJcbiAgICB9XHJcbn0gLy8gZW5kIFNvcnRlZE1hcEl0ZXJhdG9yXHJcbi8vIFJlcHJlc2VudHMgYSBub2RlIGluIGEgTGVmdC1sZWFuaW5nIFJlZC1CbGFjayB0cmVlLlxyXG5jbGFzcyBMTFJCTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yICE9IG51bGwgPyBjb2xvciA6IExMUkJOb2RlLlJFRDtcclxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogTExSQk5vZGUuRU1QVFk7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IExMUkJOb2RlLkVNUFRZO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMubGVmdC5zaXplICsgMSArIHRoaXMucmlnaHQuc2l6ZTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG5vZGUsIG9wdGlvbmFsbHkgcmVwbGFjaW5nIHBpZWNlcyBvZiBpdC5cclxuICAgIGNvcHkoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXkgIT0gbnVsbCA/IGtleSA6IHRoaXMua2V5LCB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiB0aGlzLnZhbHVlLCBjb2xvciAhPSBudWxsID8gY29sb3IgOiB0aGlzLmNvbG9yLCBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogdGhpcy5sZWZ0LCByaWdodCAhPSBudWxsID8gcmlnaHQgOiB0aGlzLnJpZ2h0KTtcclxuICAgIH1cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gVHJhdmVyc2VzIHRoZSB0cmVlIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgIC8vIGZvciBlYWNoIG5vZGUuIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgLy8gUmV0dXJucyB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXHJcbiAgICBpbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sZWZ0Lmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB8fFxyXG4gICAgICAgICAgICBhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQuaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8vIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb25cclxuICAgIC8vIGZ1bmN0aW9uIGZvciBlYWNoIG5vZGUuIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgLy8gUmV0dXJucyB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXHJcbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5yaWdodC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikgfHxcclxuICAgICAgICAgICAgYWN0aW9uKHRoaXMua2V5LCB0aGlzLnZhbHVlKSB8fFxyXG4gICAgICAgICAgICB0aGlzLmxlZnQucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIG1pbmltdW0gbm9kZSBpbiB0aGUgdHJlZS5cclxuICAgIG1pbigpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQubWluKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKCkua2V5O1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0Lm1heEtleSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgbmV3IHRyZWUsIHdpdGggdGhlIGtleS92YWx1ZSBhZGRlZC5cclxuICAgIGluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgbGV0IG4gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmF0b3Ioa2V5LCBuLmtleSk7XHJcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBuLmxlZnQuaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgdmFsdWUsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0Lmluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuLmZpeFVwKCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVNaW4oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIExMUkJOb2RlLkVNUFRZO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbiA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFuLmxlZnQuaXNSZWQoKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICBuID0gbi5tb3ZlUmVkTGVmdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmVNaW4oKSwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIG4uZml4VXAoKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgbmV3IHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBpdGVtIHJlbW92ZWQuXHJcbiAgICByZW1vdmUoa2V5LCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgbGV0IHNtYWxsZXN0O1xyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKCFuLmxlZnQuaXNFbXB0eSgpICYmICFuLmxlZnQuaXNSZWQoKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgbiA9IG4ubW92ZVJlZExlZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobi5sZWZ0LmlzUmVkKCkpIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFuLnJpZ2h0LmlzRW1wdHkoKSAmJiAhbi5yaWdodC5pc1JlZCgpICYmICFuLnJpZ2h0LmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgbiA9IG4ubW92ZVJlZFJpZ2h0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3Ioa2V5LCBuLmtleSkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChuLnJpZ2h0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBMTFJCTm9kZS5FTVBUWTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0ID0gbi5yaWdodC5taW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBuID0gbi5jb3B5KHNtYWxsZXN0LmtleSwgc21hbGxlc3QudmFsdWUsIG51bGwsIG51bGwsIG4ucmlnaHQucmVtb3ZlTWluKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuLmZpeFVwKCk7XHJcbiAgICB9XHJcbiAgICBpc1JlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcjtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgbmV3IHRyZWUgYWZ0ZXIgcGVyZm9ybWluZyBhbnkgbmVlZGVkIHJvdGF0aW9ucy5cclxuICAgIGZpeFVwKCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBpZiAobi5yaWdodC5pc1JlZCgpICYmICFuLmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVMZWZ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWQoKSAmJiBuLmxlZnQubGVmdC5pc1JlZCgpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWQoKSAmJiBuLnJpZ2h0LmlzUmVkKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gICAgbW92ZVJlZExlZnQoKSB7XHJcbiAgICAgICAgbGV0IG4gPSB0aGlzLmNvbG9yRmxpcCgpO1xyXG4gICAgICAgIGlmIChuLnJpZ2h0LmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQucm90YXRlUmlnaHQoKSk7XHJcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZUxlZnQoKTtcclxuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gICAgbW92ZVJlZFJpZ2h0KCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcy5jb2xvckZsaXAoKTtcclxuICAgICAgICBpZiAobi5sZWZ0LmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodCgpO1xyXG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcbiAgICByb3RhdGVMZWZ0KCkge1xyXG4gICAgICAgIGNvbnN0IG5sID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLlJFRCwgbnVsbCwgdGhpcy5yaWdodC5sZWZ0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG5sLCBudWxsKTtcclxuICAgIH1cclxuICAgIHJvdGF0ZVJpZ2h0KCkge1xyXG4gICAgICAgIGNvbnN0IG5yID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLlJFRCwgdGhpcy5sZWZ0LnJpZ2h0LCBudWxsKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmNvcHkobnVsbCwgbnVsbCwgdGhpcy5jb2xvciwgbnVsbCwgbnIpO1xyXG4gICAgfVxyXG4gICAgY29sb3JGbGlwKCkge1xyXG4gICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmxlZnQuY29weShudWxsLCBudWxsLCAhdGhpcy5sZWZ0LmNvbG9yLCBudWxsLCBudWxsKTtcclxuICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucmlnaHQuY29weShudWxsLCBudWxsLCAhdGhpcy5yaWdodC5jb2xvciwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weShudWxsLCBudWxsLCAhdGhpcy5jb2xvciwgbGVmdCwgcmlnaHQpO1xyXG4gICAgfVxyXG4gICAgLy8gRm9yIHRlc3RpbmcuXHJcbiAgICBjaGVja01heERlcHRoKCkge1xyXG4gICAgICAgIGNvbnN0IGJsYWNrRGVwdGggPSB0aGlzLmNoZWNrKCk7XHJcbiAgICAgICAgaWYgKE1hdGgucG93KDIuMCwgYmxhY2tEZXB0aCkgPD0gdGhpcy5zaXplICsgMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBJbiBhIGJhbGFuY2VkIFJCIHRyZWUsIHRoZSBibGFjay1kZXB0aCAobnVtYmVyIG9mIGJsYWNrIG5vZGVzKSBmcm9tIHJvb3QgdG9cclxuICAgIC8vIGxlYXZlcyBpcyBlcXVhbCBvbiBib3RoIHNpZGVzLiAgVGhpcyBmdW5jdGlvbiB2ZXJpZmllcyB0aGF0IG9yIGFzc2VydHMuXHJcbiAgICBjaGVjaygpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1JlZCgpICYmIHRoaXMubGVmdC5pc1JlZCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJsYWNrRGVwdGggPSB0aGlzLmxlZnQuY2hlY2soKTtcclxuICAgICAgICBpZiAoYmxhY2tEZXB0aCAhPT0gdGhpcy5yaWdodC5jaGVjaygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBibGFja0RlcHRoICsgKHRoaXMuaXNSZWQoKSA/IDAgOiAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0gLy8gZW5kIExMUkJOb2RlXHJcbi8vIEVtcHR5IG5vZGUgaXMgc2hhcmVkIGJldHdlZW4gYWxsIExMUkIgdHJlZXMuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbkxMUkJOb2RlLkVNUFRZID0gbnVsbDtcclxuTExSQk5vZGUuUkVEID0gdHJ1ZTtcclxuTExSQk5vZGUuQkxBQ0sgPSBmYWxzZTtcclxuLy8gUmVwcmVzZW50cyBhbiBlbXB0eSBub2RlIChhIGxlYWYgbm9kZSBpbiB0aGUgUmVkLUJsYWNrIFRyZWUpLlxyXG5jbGFzcyBMTFJCRW1wdHlOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXQga2V5KCkge1xyXG4gICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgY29sb3IoKSB7XHJcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxlZnQoKSB7XHJcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHJpZ2h0KCkge1xyXG4gICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG5vZGUuXHJcbiAgICBjb3B5KGtleSwgdmFsdWUsIGNvbG9yLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQuXHJcbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxyXG4gICAgcmVtb3ZlKGtleSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBpc1JlZCgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBGb3IgdGVzdGluZy5cclxuICAgIGNoZWNrTWF4RGVwdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjaGVjaygpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxufSAvLyBlbmQgTExSQkVtcHR5Tm9kZVxyXG5MTFJCTm9kZS5FTVBUWSA9IG5ldyBMTFJCRW1wdHlOb2RlKCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBTb3J0ZWRTZXQgaXMgYW4gaW1tdXRhYmxlIChjb3B5LW9uLXdyaXRlKSBjb2xsZWN0aW9uIHRoYXQgaG9sZHMgZWxlbWVudHNcclxuICogaW4gb3JkZXIgc3BlY2lmaWVkIGJ5IHRoZSBwcm92aWRlZCBjb21wYXJhdG9yLlxyXG4gKlxyXG4gKiBOT1RFOiBpZiBwcm92aWRlZCBjb21wYXJhdG9yIHJldHVybnMgMCBmb3IgdHdvIGVsZW1lbnRzLCB3ZSBjb25zaWRlciB0aGVtIHRvXHJcbiAqIGJlIGVxdWFsIVxyXG4gKi9cclxuY2xhc3MgU29ydGVkU2V0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3IpIHtcclxuICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBTb3J0ZWRNYXAodGhpcy5jb21wYXJhdG9yKTtcclxuICAgIH1cclxuICAgIGhhcyhlbGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5nZXQoZWxlbSkgIT09IG51bGw7XHJcbiAgICB9XHJcbiAgICBmaXJzdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1pbktleSgpO1xyXG4gICAgfVxyXG4gICAgbGFzdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1heEtleSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zaXplO1xyXG4gICAgfVxyXG4gICAgaW5kZXhPZihlbGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5pbmRleE9mKGVsZW0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEl0ZXJhdGVzIGVsZW1lbnRzIGluIG9yZGVyIGRlZmluZWQgYnkgXCJjb21wYXJhdG9yXCIgKi9cclxuICAgIGZvckVhY2goY2IpIHtcclxuICAgICAgICB0aGlzLmRhdGEuaW5vcmRlclRyYXZlcnNhbCgoaywgdikgPT4ge1xyXG4gICAgICAgICAgICBjYihrKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEl0ZXJhdGVzIG92ZXIgYGVsZW1gcyBzdWNoIHRoYXQ6IHJhbmdlWzBdICZsdDs9IGVsZW0gJmx0OyByYW5nZVsxXS4gKi9cclxuICAgIGZvckVhY2hJblJhbmdlKHJhbmdlLCBjYikge1xyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3JGcm9tKHJhbmdlWzBdKTtcclxuICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbSA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb21wYXJhdG9yKGVsZW0ua2V5LCByYW5nZVsxXSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNiKGVsZW0ua2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIG92ZXIgYGVsZW1gcyBzdWNoIHRoYXQ6IHN0YXJ0ICZsdDs9IGVsZW0gdW50aWwgZmFsc2UgaXMgcmV0dXJuZWQuXHJcbiAgICAgKi9cclxuICAgIGZvckVhY2hXaGlsZShjYiwgc3RhcnQpIHtcclxuICAgICAgICBsZXQgaXRlcjtcclxuICAgICAgICBpZiAoc3RhcnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpdGVyID0gdGhpcy5kYXRhLmdldEl0ZXJhdG9yRnJvbShzdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpdGVyID0gdGhpcy5kYXRhLmdldEl0ZXJhdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpdGVyLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNiKGVsZW0ua2V5KTtcclxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBGaW5kcyB0aGUgbGVhc3QgZWxlbWVudCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYGVsZW1gLiAqL1xyXG4gICAgZmlyc3RBZnRlck9yRXF1YWwoZWxlbSkge1xyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3JGcm9tKGVsZW0pO1xyXG4gICAgICAgIHJldHVybiBpdGVyLmhhc05leHQoKSA/IGl0ZXIuZ2V0TmV4dCgpLmtleSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXRJdGVyYXRvcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZFNldEl0ZXJhdG9yKHRoaXMuZGF0YS5nZXRJdGVyYXRvcigpKTtcclxuICAgIH1cclxuICAgIGdldEl0ZXJhdG9yRnJvbShrZXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZFNldEl0ZXJhdG9yKHRoaXMuZGF0YS5nZXRJdGVyYXRvckZyb20oa2V5KSk7XHJcbiAgICB9XHJcbiAgICAvKiogSW5zZXJ0cyBvciB1cGRhdGVzIGFuIGVsZW1lbnQgKi9cclxuICAgIGFkZChlbGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmRhdGEucmVtb3ZlKGVsZW0pLmluc2VydChlbGVtLCB0cnVlKSk7XHJcbiAgICB9XHJcbiAgICAvKiogRGVsZXRlcyBhbiBlbGVtZW50ICovXHJcbiAgICBkZWxldGUoZWxlbSkge1xyXG4gICAgICAgIGlmICghdGhpcy5oYXMoZWxlbSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkodGhpcy5kYXRhLnJlbW92ZShlbGVtKSk7XHJcbiAgICB9XHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgdW5pb25XaXRoKG90aGVyKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXM7XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIGByZXN1bHRgIGFsd2F5cyByZWZlcnMgdG8gdGhlIGxhcmdlciBvbmUgb2YgdGhlIHR3byBzZXRzLlxyXG4gICAgICAgIGlmIChyZXN1bHQuc2l6ZSA8IG90aGVyLnNpemUpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gb3RoZXI7XHJcbiAgICAgICAgICAgIG90aGVyID0gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgb3RoZXIuZm9yRWFjaChlbGVtID0+IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChlbGVtKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU29ydGVkU2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNpemUgIT09IG90aGVyLnNpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0aGlzSXQgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3IoKTtcclxuICAgICAgICBjb25zdCBvdGhlckl0ID0gb3RoZXIuZGF0YS5nZXRJdGVyYXRvcigpO1xyXG4gICAgICAgIHdoaWxlICh0aGlzSXQuaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRoaXNFbGVtID0gdGhpc0l0LmdldE5leHQoKS5rZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IG90aGVyRWxlbSA9IG90aGVySXQuZ2V0TmV4dCgpLmtleTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyYXRvcih0aGlzRWxlbSwgb3RoZXJFbGVtKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgdG9BcnJheSgpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmZvckVhY2godGFyZ2V0SWQgPT4ge1xyXG4gICAgICAgICAgICByZXMucHVzaCh0YXJnZXRJZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaChlbGVtID0+IHJlc3VsdC5wdXNoKGVsZW0pKTtcclxuICAgICAgICByZXR1cm4gJ1NvcnRlZFNldCgnICsgcmVzdWx0LnRvU3RyaW5nKCkgKyAnKSc7XHJcbiAgICB9XHJcbiAgICBjb3B5KGRhdGEpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU29ydGVkU2V0KHRoaXMuY29tcGFyYXRvcik7XHJcbiAgICAgICAgcmVzdWx0LmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgU29ydGVkU2V0SXRlcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoaXRlcikge1xyXG4gICAgICAgIHRoaXMuaXRlciA9IGl0ZXI7XHJcbiAgICB9XHJcbiAgICBnZXROZXh0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZXIuZ2V0TmV4dCgpLmtleTtcclxuICAgIH1cclxuICAgIGhhc05leHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlci5oYXNOZXh0KCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGEgc2V0IG9mIGZpZWxkcyB0aGF0IGNhbiBiZSB1c2VkIHRvIHBhcnRpYWxseSBwYXRjaCBhIGRvY3VtZW50LlxyXG4gKiBGaWVsZE1hc2sgaXMgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIE9iamVjdFZhbHVlLlxyXG4gKiBFeGFtcGxlczpcclxuICogICBmb28gLSBPdmVyd3JpdGVzIGZvbyBlbnRpcmVseSB3aXRoIHRoZSBwcm92aWRlZCB2YWx1ZS4gSWYgZm9vIGlzIG5vdFxyXG4gKiAgICAgICAgIHByZXNlbnQgaW4gdGhlIGNvbXBhbmlvbiBPYmplY3RWYWx1ZSwgdGhlIGZpZWxkIGlzIGRlbGV0ZWQuXHJcbiAqICAgZm9vLmJhciAtIE92ZXJ3cml0ZXMgb25seSB0aGUgZmllbGQgYmFyIG9mIHRoZSBvYmplY3QgZm9vLlxyXG4gKiAgICAgICAgICAgICBJZiBmb28gaXMgbm90IGFuIG9iamVjdCwgZm9vIGlzIHJlcGxhY2VkIHdpdGggYW4gb2JqZWN0XHJcbiAqICAgICAgICAgICAgIGNvbnRhaW5pbmcgZm9vXHJcbiAqL1xyXG5jbGFzcyBGaWVsZE1hc2sge1xyXG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XHJcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XHJcbiAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiB2YWxpZGF0aW9uIG9mIEZpZWxkTWFza1xyXG4gICAgICAgIC8vIFNvcnQgdGhlIGZpZWxkIG1hc2sgdG8gc3VwcG9ydCBgRmllbGRNYXNrLmlzRXF1YWwoKWAgYW5kIGFzc2VydCBiZWxvdy5cclxuICAgICAgICBmaWVsZHMuc29ydChGaWVsZFBhdGgkMS5jb21wYXJhdG9yKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZpZWxkTWFzayhbXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgRmllbGRNYXNrIG9iamVjdCB0aGF0IGlzIHRoZSByZXN1bHQgb2YgYWRkaW5nIGFsbCB0aGUgZ2l2ZW5cclxuICAgICAqIGZpZWxkcyBwYXRocyB0byB0aGlzIGZpZWxkIG1hc2suXHJcbiAgICAgKi9cclxuICAgIHVuaW9uV2l0aChleHRyYUZpZWxkcykge1xyXG4gICAgICAgIGxldCBtZXJnZWRNYXNrU2V0ID0gbmV3IFNvcnRlZFNldChGaWVsZFBhdGgkMS5jb21wYXJhdG9yKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkUGF0aCBvZiB0aGlzLmZpZWxkcykge1xyXG4gICAgICAgICAgICBtZXJnZWRNYXNrU2V0ID0gbWVyZ2VkTWFza1NldC5hZGQoZmllbGRQYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZFBhdGggb2YgZXh0cmFGaWVsZHMpIHtcclxuICAgICAgICAgICAgbWVyZ2VkTWFza1NldCA9IG1lcmdlZE1hc2tTZXQuYWRkKGZpZWxkUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRNYXNrKG1lcmdlZE1hc2tTZXQudG9BcnJheSgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmVyaWZpZXMgdGhhdCBgZmllbGRQYXRoYCBpcyBpbmNsdWRlZCBieSBhdCBsZWFzdCBvbmUgZmllbGQgaW4gdGhpcyBmaWVsZFxyXG4gICAgICogbWFzay5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGlzIGFuIE8obikgb3BlcmF0aW9uLCB3aGVyZSBgbmAgaXMgdGhlIHNpemUgb2YgdGhlIGZpZWxkIG1hc2suXHJcbiAgICAgKi9cclxuICAgIGNvdmVycyhmaWVsZFBhdGgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTWFza1BhdGggb2YgdGhpcy5maWVsZHMpIHtcclxuICAgICAgICAgICAgaWYgKGZpZWxkTWFza1BhdGguaXNQcmVmaXhPZihmaWVsZFBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKHRoaXMuZmllbGRzLCBvdGhlci5maWVsZHMsIChsLCByKSA9PiBsLmlzRXF1YWwocikpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBPYmplY3RWYWx1ZSByZXByZXNlbnRzIGEgTWFwVmFsdWUgaW4gdGhlIEZpcmVzdG9yZSBQcm90byBhbmQgb2ZmZXJzIHRoZVxyXG4gKiBhYmlsaXR5IHRvIGFkZCBhbmQgcmVtb3ZlIGZpZWxkcyAodmlhIHRoZSBPYmplY3RWYWx1ZUJ1aWxkZXIpLlxyXG4gKi9cclxuY2xhc3MgT2JqZWN0VmFsdWUge1xyXG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RWYWx1ZSh7IG1hcFZhbHVlOiB7fSB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBhdGggb3IgbnVsbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIHRoZSBwYXRoIHRvIHNlYXJjaFxyXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIGF0IHRoZSBwYXRoIG9yIG51bGwgaWYgdGhlIHBhdGggaXMgbm90IHNldC5cclxuICAgICAqL1xyXG4gICAgZmllbGQocGF0aCkge1xyXG4gICAgICAgIGlmIChwYXRoLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSAoY3VycmVudExldmVsLm1hcFZhbHVlLmZpZWxkcyB8fCB7fSlbcGF0aC5nZXQoaSldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc01hcFZhbHVlKGN1cnJlbnRMZXZlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSAoY3VycmVudExldmVsLm1hcFZhbHVlLmZpZWxkcyB8fCB7fSlbcGF0aC5sYXN0U2VnbWVudCgpXTtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbCB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZmllbGQgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGZpZWxkIHBhdGggdG8gc2V0LlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldC5cclxuICAgICAqL1xyXG4gICAgc2V0KHBhdGgsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgZmllbGRzTWFwID0gdGhpcy5nZXRGaWVsZHNNYXAocGF0aC5wb3BMYXN0KCkpO1xyXG4gICAgICAgIGZpZWxkc01hcFtwYXRoLmxhc3RTZWdtZW50KCldID0gZGVlcENsb25lKHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcHJvdmlkZWQgZmllbGRzIHRvIHRoZSBwcm92aWRlZCB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBBIG1hcCBvZiBmaWVsZHMgdG8gdmFsdWVzIChvciBudWxsIGZvciBkZWxldGVzKS5cclxuICAgICAqL1xyXG4gICAgc2V0QWxsKGRhdGEpIHtcclxuICAgICAgICBsZXQgcGFyZW50ID0gRmllbGRQYXRoJDEuZW1wdHlQYXRoKCk7XHJcbiAgICAgICAgbGV0IHVwc2VydHMgPSB7fTtcclxuICAgICAgICBsZXQgZGVsZXRlcyA9IFtdO1xyXG4gICAgICAgIGRhdGEuZm9yRWFjaCgodmFsdWUsIHBhdGgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFwYXJlbnQuaXNJbW1lZGlhdGVQYXJlbnRPZihwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBhY2N1bXVsYXRlZCBjaGFuZ2VzIGF0IHRoaXMgcGFyZW50IGxvY2F0aW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHNNYXAgPSB0aGlzLmdldEZpZWxkc01hcChwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUNoYW5nZXMoZmllbGRzTWFwLCB1cHNlcnRzLCBkZWxldGVzKTtcclxuICAgICAgICAgICAgICAgIHVwc2VydHMgPSB7fTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGgucG9wTGFzdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdXBzZXJ0c1twYXRoLmxhc3RTZWdtZW50KCldID0gZGVlcENsb25lKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZXMucHVzaChwYXRoLmxhc3RTZWdtZW50KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgZmllbGRzTWFwID0gdGhpcy5nZXRGaWVsZHNNYXAocGFyZW50KTtcclxuICAgICAgICB0aGlzLmFwcGx5Q2hhbmdlcyhmaWVsZHNNYXAsIHVwc2VydHMsIGRlbGV0ZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBmaWVsZCBhdCB0aGUgc3BlY2lmaWVkIHBhdGguIElmIHRoZXJlIGlzIG5vIGZpZWxkIGF0IHRoZVxyXG4gICAgICogc3BlY2lmaWVkIHBhdGgsIG5vdGhpbmcgaXMgY2hhbmdlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBmaWVsZCBwYXRoIHRvIHJlbW92ZS5cclxuICAgICAqL1xyXG4gICAgZGVsZXRlKHBhdGgpIHtcclxuICAgICAgICBjb25zdCBuZXN0ZWRWYWx1ZSA9IHRoaXMuZmllbGQocGF0aC5wb3BMYXN0KCkpO1xyXG4gICAgICAgIGlmIChpc01hcFZhbHVlKG5lc3RlZFZhbHVlKSAmJiBuZXN0ZWRWYWx1ZS5tYXBWYWx1ZS5maWVsZHMpIHtcclxuICAgICAgICAgICAgZGVsZXRlIG5lc3RlZFZhbHVlLm1hcFZhbHVlLmZpZWxkc1twYXRoLmxhc3RTZWdtZW50KCldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWVFcXVhbHModGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXAgdGhhdCBjb250YWlucyB0aGUgbGVhZiBlbGVtZW50IG9mIGBwYXRoYC4gSWYgdGhlIHBhcmVudFxyXG4gICAgICogZW50cnkgZG9lcyBub3QgeWV0IGV4aXN0LCBvciBpZiBpdCBpcyBub3QgYSBtYXAsIGEgbmV3IG1hcCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgKi9cclxuICAgIGdldEZpZWxkc01hcChwYXRoKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmICghY3VycmVudC5tYXBWYWx1ZS5maWVsZHMpIHtcclxuICAgICAgICAgICAgY3VycmVudC5tYXBWYWx1ZSA9IHsgZmllbGRzOiB7fSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgbGV0IG5leHQgPSBjdXJyZW50Lm1hcFZhbHVlLmZpZWxkc1twYXRoLmdldChpKV07XHJcbiAgICAgICAgICAgIGlmICghaXNNYXBWYWx1ZShuZXh0KSB8fCAhbmV4dC5tYXBWYWx1ZS5maWVsZHMpIHtcclxuICAgICAgICAgICAgICAgIG5leHQgPSB7IG1hcFZhbHVlOiB7IGZpZWxkczoge30gfSB9O1xyXG4gICAgICAgICAgICAgICAgY3VycmVudC5tYXBWYWx1ZS5maWVsZHNbcGF0aC5nZXQoaSldID0gbmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQubWFwVmFsdWUuZmllbGRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb2RpZmllcyBgZmllbGRzTWFwYCBieSBhZGRpbmcsIHJlcGxhY2luZyBvciBkZWxldGluZyB0aGUgc3BlY2lmaWVkXHJcbiAgICAgKiBlbnRyaWVzLlxyXG4gICAgICovXHJcbiAgICBhcHBseUNoYW5nZXMoZmllbGRzTWFwLCBpbnNlcnRzLCBkZWxldGVzKSB7XHJcbiAgICAgICAgZm9yRWFjaChpbnNlcnRzLCAoa2V5LCB2YWwpID0+IChmaWVsZHNNYXBba2V5XSA9IHZhbCkpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgZGVsZXRlcykge1xyXG4gICAgICAgICAgICBkZWxldGUgZmllbGRzTWFwW2ZpZWxkXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE9iamVjdFZhbHVlKGRlZXBDbG9uZSh0aGlzLnZhbHVlKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBkb2N1bWVudCBpbiBGaXJlc3RvcmUgd2l0aCBhIGtleSwgdmVyc2lvbiwgZGF0YSBhbmQgd2hldGhlciBpdFxyXG4gKiBoYXMgbG9jYWwgbXV0YXRpb25zIGFwcGxpZWQgdG8gaXQuXHJcbiAqXHJcbiAqIERvY3VtZW50cyBjYW4gdHJhbnNpdGlvbiBiZXR3ZWVuIHN0YXRlcyB2aWEgYGNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQoKWAsXHJcbiAqIGBjb252ZXJ0VG9Ob0RvY3VtZW50KClgIGFuZCBgY29udmVydFRvVW5rbm93bkRvY3VtZW50KClgLiBJZiBhIGRvY3VtZW50IGRvZXNcclxuICogbm90IHRyYW5zaXRpb24gdG8gb25lIG9mIHRoZXNlIHN0YXRlcyBldmVuIGFmdGVyIGFsbCBtdXRhdGlvbnMgaGF2ZSBiZWVuXHJcbiAqIGFwcGxpZWQsIGBpc1ZhbGlkRG9jdW1lbnQoKWAgcmV0dXJucyBmYWxzZSBhbmQgdGhlIGRvY3VtZW50IHNob3VsZCBiZSByZW1vdmVkXHJcbiAqIGZyb20gYWxsIHZpZXdzLlxyXG4gKi9cclxuY2xhc3MgTXV0YWJsZURvY3VtZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGtleSwgZG9jdW1lbnRUeXBlLCB2ZXJzaW9uLCByZWFkVGltZSwgY3JlYXRlVGltZSwgZGF0YSwgZG9jdW1lbnRTdGF0ZSkge1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID0gZG9jdW1lbnRUeXBlO1xyXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICAgICAgdGhpcy5yZWFkVGltZSA9IHJlYWRUaW1lO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlVGltZSA9IGNyZWF0ZVRpbWU7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSBkb2N1bWVudFN0YXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZG9jdW1lbnQgd2l0aCBubyBrbm93biB2ZXJzaW9uIG9yIGRhdGEsIGJ1dCB3aGljaCBjYW4gc2VydmUgYXNcclxuICAgICAqIGJhc2UgZG9jdW1lbnQgZm9yIG11dGF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIG5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZURvY3VtZW50KGRvY3VtZW50S2V5LCAwIC8qIERvY3VtZW50VHlwZS5JTlZBTElEICovLCBcclxuICAgICAgICAvKiB2ZXJzaW9uICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXHJcbiAgICAgICAgLyogcmVhZFRpbWUgKi8gU25hcHNob3RWZXJzaW9uLm1pbigpLCBcclxuICAgICAgICAvKiBjcmVhdGVUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgT2JqZWN0VmFsdWUuZW1wdHkoKSwgMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZG9jdW1lbnQgdGhhdCBpcyBrbm93biB0byBleGlzdCB3aXRoIHRoZSBnaXZlbiBkYXRhIGF0IHRoZVxyXG4gICAgICogZ2l2ZW4gdmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIG5ld0ZvdW5kRG9jdW1lbnQoZG9jdW1lbnRLZXksIHZlcnNpb24sIGNyZWF0ZVRpbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlRG9jdW1lbnQoZG9jdW1lbnRLZXksIDEgLyogRG9jdW1lbnRUeXBlLkZPVU5EX0RPQ1VNRU5UICovLCBcclxuICAgICAgICAvKiB2ZXJzaW9uICovIHZlcnNpb24sIFxyXG4gICAgICAgIC8qIHJlYWRUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXHJcbiAgICAgICAgLyogY3JlYXRlVGltZSAqLyBjcmVhdGVUaW1lLCB2YWx1ZSwgMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLyk7XHJcbiAgICB9XHJcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBkb2N1bWVudCB0aGF0IGlzIGtub3duIHRvIG5vdCBleGlzdCBhdCB0aGUgZ2l2ZW4gdmVyc2lvbi4gKi9cclxuICAgIHN0YXRpYyBuZXdOb0RvY3VtZW50KGRvY3VtZW50S2V5LCB2ZXJzaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlRG9jdW1lbnQoZG9jdW1lbnRLZXksIDIgLyogRG9jdW1lbnRUeXBlLk5PX0RPQ1VNRU5UICovLCBcclxuICAgICAgICAvKiB2ZXJzaW9uICovIHZlcnNpb24sIFxyXG4gICAgICAgIC8qIHJlYWRUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXHJcbiAgICAgICAgLyogY3JlYXRlVGltZSAqLyBTbmFwc2hvdFZlcnNpb24ubWluKCksIE9iamVjdFZhbHVlLmVtcHR5KCksIDAgLyogRG9jdW1lbnRTdGF0ZS5TWU5DRUQgKi8pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGRvY3VtZW50IHRoYXQgaXMga25vd24gdG8gZXhpc3QgYXQgdGhlIGdpdmVuIHZlcnNpb24gYnV0XHJcbiAgICAgKiB3aG9zZSBkYXRhIGlzIG5vdCBrbm93biAoZS5nLiBhIGRvY3VtZW50IHRoYXQgd2FzIHVwZGF0ZWQgd2l0aG91dCBhIGtub3duXHJcbiAgICAgKiBiYXNlIGRvY3VtZW50KS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIG5ld1Vua25vd25Eb2N1bWVudChkb2N1bWVudEtleSwgdmVyc2lvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZURvY3VtZW50KGRvY3VtZW50S2V5LCAzIC8qIERvY3VtZW50VHlwZS5VTktOT1dOX0RPQ1VNRU5UICovLCBcclxuICAgICAgICAvKiB2ZXJzaW9uICovIHZlcnNpb24sIFxyXG4gICAgICAgIC8qIHJlYWRUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXHJcbiAgICAgICAgLyogY3JlYXRlVGltZSAqLyBTbmFwc2hvdFZlcnNpb24ubWluKCksIE9iamVjdFZhbHVlLmVtcHR5KCksIDIgLyogRG9jdW1lbnRTdGF0ZS5IQVNfQ09NTUlUVEVEX01VVEFUSU9OUyAqLyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIGRvY3VtZW50IHR5cGUgdG8gaW5kaWNhdGUgdGhhdCBpdCBleGlzdHMgYW5kIHRoYXQgaXRzIHZlcnNpb25cclxuICAgICAqIGFuZCBkYXRhIGFyZSBrbm93bi5cclxuICAgICAqL1xyXG4gICAgY29udmVydFRvRm91bmREb2N1bWVudCh2ZXJzaW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIC8vIElmIGEgZG9jdW1lbnQgaXMgc3dpdGNoaW5nIHN0YXRlIGZyb20gYmVpbmcgYW4gaW52YWxpZCBvciBkZWxldGVkXHJcbiAgICAgICAgLy8gZG9jdW1lbnQgdG8gYSB2YWxpZCAoRk9VTkRfRE9DVU1FTlQpIGRvY3VtZW50LCBlaXRoZXIgZHVlIHRvIHJlY2VpdmluZyBhblxyXG4gICAgICAgIC8vIHVwZGF0ZSBmcm9tIFdhdGNoIG9yIGR1ZSB0byBhcHBseWluZyBhIGxvY2FsIHNldCBtdXRhdGlvbiBvbiB0b3BcclxuICAgICAgICAvLyBvZiBhIGRlbGV0ZWQgZG9jdW1lbnQsIG91ciBiZXN0IGd1ZXNzIGFib3V0IGl0cyBjcmVhdGVUaW1lIHdvdWxkIGJlIHRoZVxyXG4gICAgICAgIC8vIHZlcnNpb24gYXQgd2hpY2ggdGhlIGRvY3VtZW50IHRyYW5zaXRpb25lZCB0byBhIEZPVU5EX0RPQ1VNRU5ULlxyXG4gICAgICAgIGlmICh0aGlzLmNyZWF0ZVRpbWUuaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpICYmXHJcbiAgICAgICAgICAgICh0aGlzLmRvY3VtZW50VHlwZSA9PT0gMiAvKiBEb2N1bWVudFR5cGUuTk9fRE9DVU1FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID09PSAwIC8qIERvY3VtZW50VHlwZS5JTlZBTElEICovKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRpbWUgPSB2ZXJzaW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID0gMSAvKiBEb2N1bWVudFR5cGUuRk9VTkRfRE9DVU1FTlQgKi87XHJcbiAgICAgICAgdGhpcy5kYXRhID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID0gMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgZG9jdW1lbnQgdHlwZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGRvZXNuJ3QgZXhpc3QgYXQgdGhlIGdpdmVuXHJcbiAgICAgKiB2ZXJzaW9uLlxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0VG9Ob0RvY3VtZW50KHZlcnNpb24pIHtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID0gMiAvKiBEb2N1bWVudFR5cGUuTk9fRE9DVU1FTlQgKi87XHJcbiAgICAgICAgdGhpcy5kYXRhID0gT2JqZWN0VmFsdWUuZW1wdHkoKTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSAwIC8qIERvY3VtZW50U3RhdGUuU1lOQ0VEICovO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBkb2N1bWVudCB0eXBlIHRvIGluZGljYXRlIHRoYXQgaXQgZXhpc3RzIGF0IGEgZ2l2ZW4gdmVyc2lvbiBidXRcclxuICAgICAqIHRoYXQgaXRzIGRhdGEgaXMgbm90IGtub3duIChlLmcuIGEgZG9jdW1lbnQgdGhhdCB3YXMgdXBkYXRlZCB3aXRob3V0IGEga25vd25cclxuICAgICAqIGJhc2UgZG9jdW1lbnQpLlxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0VG9Vbmtub3duRG9jdW1lbnQodmVyc2lvbikge1xyXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFR5cGUgPSAzIC8qIERvY3VtZW50VHlwZS5VTktOT1dOX0RPQ1VNRU5UICovO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IE9iamVjdFZhbHVlLmVtcHR5KCk7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID0gMiAvKiBEb2N1bWVudFN0YXRlLkhBU19DT01NSVRURURfTVVUQVRJT05TICovO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCkge1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9IDIgLyogRG9jdW1lbnRTdGF0ZS5IQVNfQ09NTUlUVEVEX01VVEFUSU9OUyAqLztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHNldEhhc0xvY2FsTXV0YXRpb25zKCkge1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9IDEgLyogRG9jdW1lbnRTdGF0ZS5IQVNfTE9DQUxfTVVUQVRJT05TICovO1xyXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHNldFJlYWRUaW1lKHJlYWRUaW1lKSB7XHJcbiAgICAgICAgdGhpcy5yZWFkVGltZSA9IHJlYWRUaW1lO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhhc0xvY2FsTXV0YXRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50U3RhdGUgPT09IDEgLyogRG9jdW1lbnRTdGF0ZS5IQVNfTE9DQUxfTVVUQVRJT05TICovO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhhc0NvbW1pdHRlZE11dGF0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFN0YXRlID09PSAyIC8qIERvY3VtZW50U3RhdGUuSEFTX0NPTU1JVFRFRF9NVVRBVElPTlMgKi87XHJcbiAgICB9XHJcbiAgICBnZXQgaGFzUGVuZGluZ1dyaXRlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oYXNMb2NhbE11dGF0aW9ucyB8fCB0aGlzLmhhc0NvbW1pdHRlZE11dGF0aW9ucztcclxuICAgIH1cclxuICAgIGlzVmFsaWREb2N1bWVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFR5cGUgIT09IDAgLyogRG9jdW1lbnRUeXBlLklOVkFMSUQgKi87XHJcbiAgICB9XHJcbiAgICBpc0ZvdW5kRG9jdW1lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUeXBlID09PSAxIC8qIERvY3VtZW50VHlwZS5GT1VORF9ET0NVTUVOVCAqLztcclxuICAgIH1cclxuICAgIGlzTm9Eb2N1bWVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFR5cGUgPT09IDIgLyogRG9jdW1lbnRUeXBlLk5PX0RPQ1VNRU5UICovO1xyXG4gICAgfVxyXG4gICAgaXNVbmtub3duRG9jdW1lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUeXBlID09PSAzIC8qIERvY3VtZW50VHlwZS5VTktOT1dOX0RPQ1VNRU5UICovO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBNdXRhYmxlRG9jdW1lbnQgJiZcclxuICAgICAgICAgICAgdGhpcy5rZXkuaXNFcXVhbChvdGhlci5rZXkpICYmXHJcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbi5pc0VxdWFsKG90aGVyLnZlcnNpb24pICYmXHJcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID09PSBvdGhlci5kb2N1bWVudFR5cGUgJiZcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID09PSBvdGhlci5kb2N1bWVudFN0YXRlICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5pc0VxdWFsKG90aGVyLmRhdGEpKTtcclxuICAgIH1cclxuICAgIG11dGFibGVDb3B5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZURvY3VtZW50KHRoaXMua2V5LCB0aGlzLmRvY3VtZW50VHlwZSwgdGhpcy52ZXJzaW9uLCB0aGlzLnJlYWRUaW1lLCB0aGlzLmNyZWF0ZVRpbWUsIHRoaXMuZGF0YS5jbG9uZSgpLCB0aGlzLmRvY3VtZW50U3RhdGUpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIChgRG9jdW1lbnQoJHt0aGlzLmtleX0sICR7dGhpcy52ZXJzaW9ufSwgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEudmFsdWUpfSwgYCArXHJcbiAgICAgICAgICAgIGB7Y3JlYXRlVGltZTogJHt0aGlzLmNyZWF0ZVRpbWV9fSksIGAgK1xyXG4gICAgICAgICAgICBge2RvY3VtZW50VHlwZTogJHt0aGlzLmRvY3VtZW50VHlwZX19KSwgYCArXHJcbiAgICAgICAgICAgIGB7ZG9jdW1lbnRTdGF0ZTogJHt0aGlzLmRvY3VtZW50U3RhdGV9fSlgKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nXHJcbmNsYXNzIFRhcmdldEltcGwge1xyXG4gICAgY29uc3RydWN0b3IocGF0aCwgY29sbGVjdGlvbkdyb3VwID0gbnVsbCwgb3JkZXJCeSA9IFtdLCBmaWx0ZXJzID0gW10sIGxpbWl0ID0gbnVsbCwgc3RhcnRBdCA9IG51bGwsIGVuZEF0ID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXAgPSBjb2xsZWN0aW9uR3JvdXA7XHJcbiAgICAgICAgdGhpcy5vcmRlckJ5ID0gb3JkZXJCeTtcclxuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xyXG4gICAgICAgIHRoaXMubGltaXQgPSBsaW1pdDtcclxuICAgICAgICB0aGlzLnN0YXJ0QXQgPSBzdGFydEF0O1xyXG4gICAgICAgIHRoaXMuZW5kQXQgPSBlbmRBdDtcclxuICAgICAgICB0aGlzLm1lbW9pemVkQ2Fub25pY2FsSWQgPSBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJbml0aWFsaXplcyBhIFRhcmdldCB3aXRoIGEgcGF0aCBhbmQgb3B0aW9uYWwgYWRkaXRpb25hbCBxdWVyeSBjb25zdHJhaW50cy5cclxuICogUGF0aCBtdXN0IGN1cnJlbnRseSBiZSBlbXB0eSBpZiB0aGlzIGlzIGEgY29sbGVjdGlvbiBncm91cCBxdWVyeS5cclxuICpcclxuICogTk9URTogeW91IHNob3VsZCBhbHdheXMgY29uc3RydWN0IGBUYXJnZXRgIGZyb20gYFF1ZXJ5LnRvVGFyZ2V0YCBpbnN0ZWFkIG9mXHJcbiAqIHVzaW5nIHRoaXMgZmFjdG9yeSBtZXRob2QsIGJlY2F1c2UgYFF1ZXJ5YCBwcm92aWRlcyBhbiBpbXBsaWNpdCBgb3JkZXJCeWBcclxuICogcHJvcGVydHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdUYXJnZXQocGF0aCwgY29sbGVjdGlvbkdyb3VwID0gbnVsbCwgb3JkZXJCeSA9IFtdLCBmaWx0ZXJzID0gW10sIGxpbWl0ID0gbnVsbCwgc3RhcnRBdCA9IG51bGwsIGVuZEF0ID0gbnVsbCkge1xyXG4gICAgcmV0dXJuIG5ldyBUYXJnZXRJbXBsKHBhdGgsIGNvbGxlY3Rpb25Hcm91cCwgb3JkZXJCeSwgZmlsdGVycywgbGltaXQsIHN0YXJ0QXQsIGVuZEF0KTtcclxufVxyXG5mdW5jdGlvbiB0YXJnZXRFcXVhbHMobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0LmxpbWl0ICE9PSByaWdodC5saW1pdCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChsZWZ0Lm9yZGVyQnkubGVuZ3RoICE9PSByaWdodC5vcmRlckJ5Lmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5vcmRlckJ5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCFvcmRlckJ5RXF1YWxzKGxlZnQub3JkZXJCeVtpXSwgcmlnaHQub3JkZXJCeVtpXSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChsZWZ0LmZpbHRlcnMubGVuZ3RoICE9PSByaWdodC5maWx0ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCFmaWx0ZXJFcXVhbHMobGVmdC5maWx0ZXJzW2ldLCByaWdodC5maWx0ZXJzW2ldKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQuY29sbGVjdGlvbkdyb3VwICE9PSByaWdodC5jb2xsZWN0aW9uR3JvdXApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIWxlZnQucGF0aC5pc0VxdWFsKHJpZ2h0LnBhdGgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKCFib3VuZEVxdWFscyhsZWZ0LnN0YXJ0QXQsIHJpZ2h0LnN0YXJ0QXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJvdW5kRXF1YWxzKGxlZnQuZW5kQXQsIHJpZ2h0LmVuZEF0KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUXVlcnkgZW5jYXBzdWxhdGVzIGFsbCB0aGUgcXVlcnkgYXR0cmlidXRlcyB3ZSBzdXBwb3J0IGluIHRoZSBTREsuIEl0IGNhblxyXG4gKiBiZSBydW4gYWdhaW5zdCB0aGUgTG9jYWxTdG9yZSwgYXMgd2VsbCBhcyBiZSBjb252ZXJ0ZWQgdG8gYSBgVGFyZ2V0YCB0b1xyXG4gKiBxdWVyeSB0aGUgUmVtb3RlU3RvcmUgcmVzdWx0cy5cclxuICpcclxuICogVmlzaWJsZSBmb3IgdGVzdGluZy5cclxuICovXHJcbmNsYXNzIFF1ZXJ5SW1wbCB7XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIGEgUXVlcnkgd2l0aCBhIHBhdGggYW5kIG9wdGlvbmFsIGFkZGl0aW9uYWwgcXVlcnkgY29uc3RyYWludHMuXHJcbiAgICAgKiBQYXRoIG11c3QgY3VycmVudGx5IGJlIGVtcHR5IGlmIHRoaXMgaXMgYSBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJ5LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoLCBjb2xsZWN0aW9uR3JvdXAgPSBudWxsLCBleHBsaWNpdE9yZGVyQnkgPSBbXSwgZmlsdGVycyA9IFtdLCBsaW1pdCA9IG51bGwsIGxpbWl0VHlwZSA9IFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqLywgc3RhcnRBdCA9IG51bGwsIGVuZEF0ID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXAgPSBjb2xsZWN0aW9uR3JvdXA7XHJcbiAgICAgICAgdGhpcy5leHBsaWNpdE9yZGVyQnkgPSBleHBsaWNpdE9yZGVyQnk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcclxuICAgICAgICB0aGlzLmxpbWl0ID0gbGltaXQ7XHJcbiAgICAgICAgdGhpcy5saW1pdFR5cGUgPSBsaW1pdFR5cGU7XHJcbiAgICAgICAgdGhpcy5zdGFydEF0ID0gc3RhcnRBdDtcclxuICAgICAgICB0aGlzLmVuZEF0ID0gZW5kQXQ7XHJcbiAgICAgICAgdGhpcy5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5ID0gbnVsbDtcclxuICAgICAgICAvLyBUaGUgY29ycmVzcG9uZGluZyBgVGFyZ2V0YCBvZiB0aGlzIGBRdWVyeWAgaW5zdGFuY2UsIGZvciB1c2Ugd2l0aFxyXG4gICAgICAgIC8vIG5vbi1hZ2dyZWdhdGUgcXVlcmllcy5cclxuICAgICAgICB0aGlzLm1lbW9pemVkVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICAvLyBUaGUgY29ycmVzcG9uZGluZyBgVGFyZ2V0YCBvZiB0aGlzIGBRdWVyeWAgaW5zdGFuY2UsIGZvciB1c2Ugd2l0aFxyXG4gICAgICAgIC8vIGFnZ3JlZ2F0ZSBxdWVyaWVzLiBVbmxpa2UgdGFyZ2V0cyBmb3Igbm9uLWFnZ3JlZ2F0ZSBxdWVyaWVzLFxyXG4gICAgICAgIC8vIGFnZ3JlZ2F0ZSBxdWVyeSB0YXJnZXRzIGRvIG5vdCBjb250YWluIG5vcm1hbGl6ZWQgb3JkZXItYnlzLCB0aGV5IG9ubHlcclxuICAgICAgICAvLyBjb250YWluIGV4cGxpY2l0IG9yZGVyLWJ5cy5cclxuICAgICAgICB0aGlzLm1lbW9pemVkQWdncmVnYXRlVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5zdGFydEF0KSA7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kQXQpIDtcclxuICAgIH1cclxufVxyXG4vKiogQ3JlYXRlcyBhIG5ldyBRdWVyeSBmb3IgYSBxdWVyeSB0aGF0IG1hdGNoZXMgYWxsIGRvY3VtZW50cyBhdCBgcGF0aGAgKi9cclxuZnVuY3Rpb24gbmV3UXVlcnlGb3JQYXRoKHBhdGgpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHBhdGgpO1xyXG59XHJcbi8vIFJldHVybnMgdGhlIHNvcnRlZCBzZXQgb2YgaW5lcXVhbGl0eSBmaWx0ZXIgZmllbGRzIHVzZWQgaW4gdGhpcyBxdWVyeS5cclxuZnVuY3Rpb24gZ2V0SW5lcXVhbGl0eUZpbHRlckZpZWxkcyhxdWVyeSkge1xyXG4gICAgbGV0IHJlc3VsdCA9IG5ldyBTb3J0ZWRTZXQoRmllbGRQYXRoJDEuY29tcGFyYXRvcik7XHJcbiAgICBxdWVyeS5maWx0ZXJzLmZvckVhY2goKGZpbHRlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN1YkZpbHRlcnMgPSBmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpO1xyXG4gICAgICAgIHN1YkZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXIuaXNJbmVxdWFsaXR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZmlsdGVyLmZpZWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IFF1ZXJ5IGZvciBhIGNvbGxlY3Rpb24gZ3JvdXAgcXVlcnkgdGhhdCBtYXRjaGVzIGFsbCBkb2N1bWVudHNcclxuICogd2l0aGluIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9uIGdyb3VwLlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3UXVlcnlGb3JDb2xsZWN0aW9uR3JvdXAoY29sbGVjdGlvbklkKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCksIGNvbGxlY3Rpb25JZCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcXVlcnkgbWF0Y2hlcyBhIGNvbGxlY3Rpb24gZ3JvdXAgcmF0aGVyIHRoYW4gYSBzcGVjaWZpY1xyXG4gKiBjb2xsZWN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNDb2xsZWN0aW9uR3JvdXBRdWVyeShxdWVyeSkge1xyXG4gICAgcmV0dXJuIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCAhPT0gbnVsbDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbm9ybWFsaXplZCBvcmRlci1ieSBjb25zdHJhaW50IHRoYXQgaXMgdXNlZCB0byBleGVjdXRlIHRoZSBRdWVyeSxcclxuICogd2hpY2ggY2FuIGJlIGRpZmZlcmVudCBmcm9tIHRoZSBvcmRlci1ieSBjb25zdHJhaW50cyB0aGUgdXNlciBwcm92aWRlZCAoZS5nLlxyXG4gKiB0aGUgU0RLIGFuZCBiYWNrZW5kIGFsd2F5cyBvcmRlcnMgYnkgYF9fbmFtZV9fYCkuIFRoZSBub3JtYWxpemVkIG9yZGVyLWJ5XHJcbiAqIGluY2x1ZGVzIGltcGxpY2l0IG9yZGVyLWJ5cyBpbiBhZGRpdGlvbiB0byB0aGUgZXhwbGljaXQgdXNlciBwcm92aWRlZFxyXG4gKiBvcmRlci1ieXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5KHF1ZXJ5KSB7XHJcbiAgICBjb25zdCBxdWVyeUltcGwgPSBkZWJ1Z0Nhc3QocXVlcnkpO1xyXG4gICAgaWYgKHF1ZXJ5SW1wbC5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5ID09PSBudWxsKSB7XHJcbiAgICAgICAgcXVlcnlJbXBsLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnkgPSBbXTtcclxuICAgICAgICBjb25zdCBmaWVsZHNOb3JtYWxpemVkID0gbmV3IFNldCgpO1xyXG4gICAgICAgIC8vIEFueSBleHBsaWNpdCBvcmRlciBieSBmaWVsZHMgc2hvdWxkIGJlIGFkZGVkIGFzIGlzLlxyXG4gICAgICAgIGZvciAoY29uc3Qgb3JkZXJCeSBvZiBxdWVyeUltcGwuZXhwbGljaXRPcmRlckJ5KSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5SW1wbC5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5LnB1c2gob3JkZXJCeSk7XHJcbiAgICAgICAgICAgIGZpZWxkc05vcm1hbGl6ZWQuYWRkKG9yZGVyQnkuZmllbGQuY2Fub25pY2FsU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGUgb3JkZXIgb2YgdGhlIGltcGxpY2l0IG9yZGVyaW5nIGFsd2F5cyBtYXRjaGVzIHRoZSBsYXN0IGV4cGxpY2l0IG9yZGVyIGJ5LlxyXG4gICAgICAgIGNvbnN0IGxhc3REaXJlY3Rpb24gPSBxdWVyeUltcGwuZXhwbGljaXRPcmRlckJ5Lmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgPyBxdWVyeUltcGwuZXhwbGljaXRPcmRlckJ5W3F1ZXJ5SW1wbC5leHBsaWNpdE9yZGVyQnkubGVuZ3RoIC0gMV0uZGlyXHJcbiAgICAgICAgICAgIDogXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovO1xyXG4gICAgICAgIC8vIEFueSBpbmVxdWFsaXR5IGZpZWxkcyBub3QgZXhwbGljaXRseSBvcmRlcmVkIHNob3VsZCBiZSBpbXBsaWNpdGx5IG9yZGVyZWQgaW4gYSBsZXhpY29ncmFwaGljYWxcclxuICAgICAgICAvLyBvcmRlci4gV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaW5lcXVhbGl0eSBmaWx0ZXJzIG9uIHRoZSBzYW1lIGZpZWxkLCB0aGUgZmllbGQgc2hvdWxkIGJlIGFkZGVkXHJcbiAgICAgICAgLy8gb25seSBvbmNlLlxyXG4gICAgICAgIC8vIE5vdGU6IGBTb3J0ZWRTZXQ8RmllbGRQYXRoPmAgc29ydHMgdGhlIGtleSBmaWVsZCBiZWZvcmUgb3RoZXIgZmllbGRzLiBIb3dldmVyLCB3ZSB3YW50IHRoZSBrZXlcclxuICAgICAgICAvLyBmaWVsZCB0byBiZSBzb3J0ZWQgbGFzdC5cclxuICAgICAgICBjb25zdCBpbmVxdWFsaXR5RmllbGRzID0gZ2V0SW5lcXVhbGl0eUZpbHRlckZpZWxkcyhxdWVyeUltcGwpO1xyXG4gICAgICAgIGluZXF1YWxpdHlGaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZmllbGRzTm9ybWFsaXplZC5oYXMoZmllbGQuY2Fub25pY2FsU3RyaW5nKCkpICYmXHJcbiAgICAgICAgICAgICAgICAhZmllbGQuaXNLZXlGaWVsZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWROb3JtYWxpemVkT3JkZXJCeS5wdXNoKG5ldyBPcmRlckJ5KGZpZWxkLCBsYXN0RGlyZWN0aW9uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBBZGQgdGhlIGRvY3VtZW50IGtleSBmaWVsZCB0byB0aGUgbGFzdCBpZiBpdCBpcyBub3QgZXhwbGljaXRseSBvcmRlcmVkLlxyXG4gICAgICAgIGlmICghZmllbGRzTm9ybWFsaXplZC5oYXMoRmllbGRQYXRoJDEua2V5RmllbGQoKS5jYW5vbmljYWxTdHJpbmcoKSkpIHtcclxuICAgICAgICAgICAgcXVlcnlJbXBsLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnkucHVzaChuZXcgT3JkZXJCeShGaWVsZFBhdGgkMS5rZXlGaWVsZCgpLCBsYXN0RGlyZWN0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHF1ZXJ5SW1wbC5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5O1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIGBRdWVyeWAgaW5zdGFuY2UgdG8gaXRzIGNvcnJlc3BvbmRpbmcgYFRhcmdldGAgcmVwcmVzZW50YXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeVRvVGFyZ2V0KHF1ZXJ5KSB7XHJcbiAgICBjb25zdCBxdWVyeUltcGwgPSBkZWJ1Z0Nhc3QocXVlcnkpO1xyXG4gICAgaWYgKCFxdWVyeUltcGwubWVtb2l6ZWRUYXJnZXQpIHtcclxuICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWRUYXJnZXQgPSBfcXVlcnlUb1RhcmdldChxdWVyeUltcGwsIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBxdWVyeUltcGwubWVtb2l6ZWRUYXJnZXQ7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgYFF1ZXJ5YCBpbnN0YW5jZSB0byBpdHMgY29ycmVzcG9uZGluZyBgVGFyZ2V0YCByZXByZXNlbnRhdGlvbixcclxuICogZm9yIHVzZSB3aXRoaW4gYW4gYWdncmVnYXRlIHF1ZXJ5LiBVbmxpa2UgdGFyZ2V0cyBmb3Igbm9uLWFnZ3JlZ2F0ZSBxdWVyaWVzLFxyXG4gKiBhZ2dyZWdhdGUgcXVlcnkgdGFyZ2V0cyBkbyBub3QgY29udGFpbiBub3JtYWxpemVkIG9yZGVyLWJ5cywgdGhleSBvbmx5XHJcbiAqIGNvbnRhaW4gZXhwbGljaXQgb3JkZXItYnlzLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlUb0FnZ3JlZ2F0ZVRhcmdldChxdWVyeSkge1xyXG4gICAgY29uc3QgcXVlcnlJbXBsID0gZGVidWdDYXN0KHF1ZXJ5KTtcclxuICAgIGlmICghcXVlcnlJbXBsLm1lbW9pemVkQWdncmVnYXRlVGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gRG8gbm90IGluY2x1ZGUgaW1wbGljaXQgb3JkZXItYnlzIGZvciBhZ2dyZWdhdGUgcXVlcmllcy5cclxuICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWRBZ2dyZWdhdGVUYXJnZXQgPSBfcXVlcnlUb1RhcmdldChxdWVyeUltcGwsIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcXVlcnlJbXBsLm1lbW9pemVkQWdncmVnYXRlVGFyZ2V0O1xyXG59XHJcbmZ1bmN0aW9uIF9xdWVyeVRvVGFyZ2V0KHF1ZXJ5SW1wbCwgb3JkZXJCeXMpIHtcclxuICAgIGlmIChxdWVyeUltcGwubGltaXRUeXBlID09PSBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8pIHtcclxuICAgICAgICByZXR1cm4gbmV3VGFyZ2V0KHF1ZXJ5SW1wbC5wYXRoLCBxdWVyeUltcGwuY29sbGVjdGlvbkdyb3VwLCBvcmRlckJ5cywgcXVlcnlJbXBsLmZpbHRlcnMsIHF1ZXJ5SW1wbC5saW1pdCwgcXVlcnlJbXBsLnN0YXJ0QXQsIHF1ZXJ5SW1wbC5lbmRBdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBGbGlwIHRoZSBvcmRlckJ5IGRpcmVjdGlvbnMgc2luY2Ugd2Ugd2FudCB0aGUgbGFzdCByZXN1bHRzXHJcbiAgICAgICAgb3JkZXJCeXMgPSBvcmRlckJ5cy5tYXAob3JkZXJCeSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IG9yZGVyQnkuZGlyID09PSBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqL1xyXG4gICAgICAgICAgICAgICAgPyBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi9cclxuICAgICAgICAgICAgICAgIDogXCJkZXNjXCIgLyogRGlyZWN0aW9uLkRFU0NFTkRJTkcgKi87XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3JkZXJCeShvcmRlckJ5LmZpZWxkLCBkaXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gc3dhcCB0aGUgY3Vyc29ycyB0byBtYXRjaCB0aGUgbm93LWZsaXBwZWQgcXVlcnkgb3JkZXJpbmcuXHJcbiAgICAgICAgY29uc3Qgc3RhcnRBdCA9IHF1ZXJ5SW1wbC5lbmRBdFxyXG4gICAgICAgICAgICA/IG5ldyBCb3VuZChxdWVyeUltcGwuZW5kQXQucG9zaXRpb24sIHF1ZXJ5SW1wbC5lbmRBdC5pbmNsdXNpdmUpXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICBjb25zdCBlbmRBdCA9IHF1ZXJ5SW1wbC5zdGFydEF0XHJcbiAgICAgICAgICAgID8gbmV3IEJvdW5kKHF1ZXJ5SW1wbC5zdGFydEF0LnBvc2l0aW9uLCBxdWVyeUltcGwuc3RhcnRBdC5pbmNsdXNpdmUpXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAvLyBOb3cgcmV0dXJuIGFzIGEgTGltaXRUeXBlLkZpcnN0IHF1ZXJ5LlxyXG4gICAgICAgIHJldHVybiBuZXdUYXJnZXQocXVlcnlJbXBsLnBhdGgsIHF1ZXJ5SW1wbC5jb2xsZWN0aW9uR3JvdXAsIG9yZGVyQnlzLCBxdWVyeUltcGwuZmlsdGVycywgcXVlcnlJbXBsLmxpbWl0LCBzdGFydEF0LCBlbmRBdCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlXaXRoQWRkZWRGaWx0ZXIocXVlcnksIGZpbHRlcikge1xyXG4gICAgY29uc3QgbmV3RmlsdGVycyA9IHF1ZXJ5LmZpbHRlcnMuY29uY2F0KFtmaWx0ZXJdKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5LnBhdGgsIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5LnNsaWNlKCksIG5ld0ZpbHRlcnMsIHF1ZXJ5LmxpbWl0LCBxdWVyeS5saW1pdFR5cGUsIHF1ZXJ5LnN0YXJ0QXQsIHF1ZXJ5LmVuZEF0KTtcclxufVxyXG5mdW5jdGlvbiBxdWVyeVdpdGhBZGRlZE9yZGVyQnkocXVlcnksIG9yZGVyQnkpIHtcclxuICAgIC8vIFRPRE8oZGltb25kKTogdmFsaWRhdGUgdGhhdCBvcmRlckJ5IGRvZXMgbm90IGxpc3QgdGhlIHNhbWUga2V5IHR3aWNlLlxyXG4gICAgY29uc3QgbmV3T3JkZXJCeSA9IHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5jb25jYXQoW29yZGVyQnldKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5LnBhdGgsIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCwgbmV3T3JkZXJCeSwgcXVlcnkuZmlsdGVycy5zbGljZSgpLCBxdWVyeS5saW1pdCwgcXVlcnkubGltaXRUeXBlLCBxdWVyeS5zdGFydEF0LCBxdWVyeS5lbmRBdCk7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlXaXRoTGltaXQocXVlcnksIGxpbWl0LCBsaW1pdFR5cGUpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5LnBhdGgsIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5LnNsaWNlKCksIHF1ZXJ5LmZpbHRlcnMuc2xpY2UoKSwgbGltaXQsIGxpbWl0VHlwZSwgcXVlcnkuc3RhcnRBdCwgcXVlcnkuZW5kQXQpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5V2l0aFN0YXJ0QXQocXVlcnksIGJvdW5kKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5wYXRoLCBxdWVyeS5jb2xsZWN0aW9uR3JvdXAsIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5zbGljZSgpLCBxdWVyeS5maWx0ZXJzLnNsaWNlKCksIHF1ZXJ5LmxpbWl0LCBxdWVyeS5saW1pdFR5cGUsIGJvdW5kLCBxdWVyeS5lbmRBdCk7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlXaXRoRW5kQXQocXVlcnksIGJvdW5kKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5wYXRoLCBxdWVyeS5jb2xsZWN0aW9uR3JvdXAsIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5zbGljZSgpLCBxdWVyeS5maWx0ZXJzLnNsaWNlKCksIHF1ZXJ5LmxpbWl0LCBxdWVyeS5saW1pdFR5cGUsIHF1ZXJ5LnN0YXJ0QXQsIGJvdW5kKTtcclxufVxyXG5mdW5jdGlvbiBxdWVyeUVxdWFscyhsZWZ0LCByaWdodCkge1xyXG4gICAgcmV0dXJuICh0YXJnZXRFcXVhbHMocXVlcnlUb1RhcmdldChsZWZ0KSwgcXVlcnlUb1RhcmdldChyaWdodCkpICYmXHJcbiAgICAgICAgbGVmdC5saW1pdFR5cGUgPT09IHJpZ2h0LmxpbWl0VHlwZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gRG91YmxlVmFsdWUgZm9yIGB2YWx1ZWAgdGhhdCBpcyBlbmNvZGVkIGJhc2VkIHRoZSBzZXJpYWxpemVyJ3NcclxuICogYHVzZVByb3RvM0pzb25gIHNldHRpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0RvdWJsZShzZXJpYWxpemVyLCB2YWx1ZSkge1xyXG4gICAgaWYgKHNlcmlhbGl6ZXIudXNlUHJvdG8zSnNvbikge1xyXG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6ICdOYU4nIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBkb3VibGVWYWx1ZTogJ0luZmluaXR5JyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiAnLUluZmluaXR5JyB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiBpc05lZ2F0aXZlWmVybyh2YWx1ZSkgPyAnLTAnIDogdmFsdWUgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhbiBJbnRlZ2VyVmFsdWUgZm9yIGB2YWx1ZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcclxuICAgIHJldHVybiB7IGludGVnZXJWYWx1ZTogJycgKyB2YWx1ZSB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgdmFsdWUgZm9yIGEgbnVtYmVyIHRoYXQncyBhcHByb3ByaWF0ZSB0byBwdXQgaW50byBhIHByb3RvLlxyXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIEludGVnZXJWYWx1ZSBpZiBpdCBjYW4gc2FmZWx5IHJlcHJlc2VudCB0aGUgdmFsdWUsXHJcbiAqIG90aGVyd2lzZSBhIERvdWJsZVZhbHVlIGlzIHJldHVybmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9OdW1iZXIoc2VyaWFsaXplciwgdmFsdWUpIHtcclxuICAgIHJldHVybiBpc1NhZmVJbnRlZ2VyKHZhbHVlKSA/IHRvSW50ZWdlcih2YWx1ZSkgOiB0b0RvdWJsZShzZXJpYWxpemVyLCB2YWx1ZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIFVzZWQgdG8gcmVwcmVzZW50IGEgZmllbGQgdHJhbnNmb3JtIG9uIGEgbXV0YXRpb24uICovXHJcbmNsYXNzIFRyYW5zZm9ybU9wZXJhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgc3RydWN0dXJhbCB0eXBlIG9mIGBUcmFuc2Zvcm1PcGVyYXRpb25gIGlzIHVuaXF1ZS5cclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy81NDUxXHJcbiAgICAgICAgdGhpcy5fID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbi8qKiBUcmFuc2Zvcm1zIGEgdmFsdWUgaW50byBhIHNlcnZlci1nZW5lcmF0ZWQgdGltZXN0YW1wLiAqL1xyXG5jbGFzcyBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0gZXh0ZW5kcyBUcmFuc2Zvcm1PcGVyYXRpb24ge1xyXG59XHJcbi8qKiBUcmFuc2Zvcm1zIGFuIGFycmF5IHZhbHVlIHZpYSBhIHVuaW9uIG9wZXJhdGlvbi4gKi9cclxuY2xhc3MgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbiBleHRlbmRzIFRyYW5zZm9ybU9wZXJhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xyXG4gICAgfVxyXG59XHJcbi8qKiBUcmFuc2Zvcm1zIGFuIGFycmF5IHZhbHVlIHZpYSBhIHJlbW92ZSBvcGVyYXRpb24uICovXHJcbmNsYXNzIEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uIGV4dGVuZHMgVHJhbnNmb3JtT3BlcmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdGhlIGJhY2tlbmQgc2VtYW50aWNzIGZvciBsb2NhbGx5IGNvbXB1dGVkIE5VTUVSSUNfQUREIChpbmNyZW1lbnQpXHJcbiAqIHRyYW5zZm9ybXMuIENvbnZlcnRzIGFsbCBmaWVsZCB2YWx1ZXMgdG8gaW50ZWdlcnMgb3IgZG91YmxlcywgYnV0IHVubGlrZSB0aGVcclxuICogYmFja2VuZCBkb2VzIG5vdCBjYXAgaW50ZWdlciB2YWx1ZXMgYXQgMl42My4gSW5zdGVhZCwgSmF2YVNjcmlwdCBudW1iZXJcclxuICogYXJpdGhtZXRpYyBpcyB1c2VkIGFuZCBwcmVjaXNpb24gbG9zcyBjYW4gb2NjdXIgZm9yIHZhbHVlcyBncmVhdGVyIHRoYW4gMl41My5cclxuICovXHJcbmNsYXNzIE51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb24gZXh0ZW5kcyBUcmFuc2Zvcm1PcGVyYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplciwgb3BlcmFuZCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcclxuICAgICAgICB0aGlzLm9wZXJhbmQgPSBvcGVyYW5kO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBBIGZpZWxkIHBhdGggYW5kIHRoZSBUcmFuc2Zvcm1PcGVyYXRpb24gdG8gcGVyZm9ybSB1cG9uIGl0LiAqL1xyXG5jbGFzcyBGaWVsZFRyYW5zZm9ybSB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdHJhbnNmb3JtKSB7XHJcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgcHJlY29uZGl0aW9uIGZvciBhIG11dGF0aW9uLiBUaGlzIGZvbGxvd3MgdGhlIG1vZGVsIHRoYXQgdGhlXHJcbiAqIGJhY2tlbmQgYWNjZXB0cyB3aXRoIHRoZSBzcGVjaWFsIGNhc2Ugb2YgYW4gZXhwbGljaXQgXCJlbXB0eVwiIHByZWNvbmRpdGlvblxyXG4gKiAobWVhbmluZyBubyBwcmVjb25kaXRpb24pLlxyXG4gKi9cclxuY2xhc3MgUHJlY29uZGl0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKHVwZGF0ZVRpbWUsIGV4aXN0cykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGltZSA9IHVwZGF0ZVRpbWU7XHJcbiAgICAgICAgdGhpcy5leGlzdHMgPSBleGlzdHM7XHJcbiAgICB9XHJcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBlbXB0eSBQcmVjb25kaXRpb24uICovXHJcbiAgICBzdGF0aWMgbm9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZWNvbmRpdGlvbigpO1xyXG4gICAgfVxyXG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgUHJlY29uZGl0aW9uIHdpdGggYW4gZXhpc3RzIGZsYWcuICovXHJcbiAgICBzdGF0aWMgZXhpc3RzKGV4aXN0cykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlY29uZGl0aW9uKHVuZGVmaW5lZCwgZXhpc3RzKTtcclxuICAgIH1cclxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IFByZWNvbmRpdGlvbiBiYXNlZCBvbiBhIHZlcnNpb24gYSBkb2N1bWVudCBleGlzdHMgYXQuICovXHJcbiAgICBzdGF0aWMgdXBkYXRlVGltZSh2ZXJzaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVjb25kaXRpb24odmVyc2lvbik7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB3aGV0aGVyIHRoaXMgUHJlY29uZGl0aW9uIGlzIGVtcHR5LiAqL1xyXG4gICAgZ2V0IGlzTm9uZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVUaW1lID09PSB1bmRlZmluZWQgJiYgdGhpcy5leGlzdHMgPT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZXhpc3RzID09PSBvdGhlci5leGlzdHMgJiZcclxuICAgICAgICAgICAgKHRoaXMudXBkYXRlVGltZVxyXG4gICAgICAgICAgICAgICAgPyAhIW90aGVyLnVwZGF0ZVRpbWUgJiYgdGhpcy51cGRhdGVUaW1lLmlzRXF1YWwob3RoZXIudXBkYXRlVGltZSlcclxuICAgICAgICAgICAgICAgIDogIW90aGVyLnVwZGF0ZVRpbWUpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBtdXRhdGlvbiBkZXNjcmliZXMgYSBzZWxmLWNvbnRhaW5lZCBjaGFuZ2UgdG8gYSBkb2N1bWVudC4gTXV0YXRpb25zIGNhblxyXG4gKiBjcmVhdGUsIHJlcGxhY2UsIGRlbGV0ZSwgYW5kIHVwZGF0ZSBzdWJzZXRzIG9mIGRvY3VtZW50cy5cclxuICpcclxuICogTXV0YXRpb25zIG5vdCBvbmx5IGFjdCBvbiB0aGUgdmFsdWUgb2YgdGhlIGRvY3VtZW50IGJ1dCBhbHNvIGl0cyB2ZXJzaW9uLlxyXG4gKlxyXG4gKiBGb3IgbG9jYWwgbXV0YXRpb25zIChtdXRhdGlvbnMgdGhhdCBoYXZlbid0IGJlZW4gY29tbWl0dGVkIHlldCksIHdlIHByZXNlcnZlXHJcbiAqIHRoZSBleGlzdGluZyB2ZXJzaW9uIGZvciBTZXQgYW5kIFBhdGNoIG11dGF0aW9ucy4gRm9yIERlbGV0ZSBtdXRhdGlvbnMsIHdlXHJcbiAqIHJlc2V0IHRoZSB2ZXJzaW9uIHRvIDAuXHJcbiAqXHJcbiAqIEhlcmUncyB0aGUgZXhwZWN0ZWQgdHJhbnNpdGlvbiB0YWJsZS5cclxuICpcclxuICogTVVUQVRJT04gICAgICAgICAgIEFQUExJRUQgVE8gICAgICAgICAgICBSRVNVTFRTIElOXHJcbiAqXHJcbiAqIFNldE11dGF0aW9uICAgICAgICBEb2N1bWVudCh2MykgICAgICAgICAgRG9jdW1lbnQodjMpXHJcbiAqIFNldE11dGF0aW9uICAgICAgICBOb0RvY3VtZW50KHYzKSAgICAgICAgRG9jdW1lbnQodjApXHJcbiAqIFNldE11dGF0aW9uICAgICAgICBJbnZhbGlkRG9jdW1lbnQodjApICAgRG9jdW1lbnQodjApXHJcbiAqIFBhdGNoTXV0YXRpb24gICAgICBEb2N1bWVudCh2MykgICAgICAgICAgRG9jdW1lbnQodjMpXHJcbiAqIFBhdGNoTXV0YXRpb24gICAgICBOb0RvY3VtZW50KHYzKSAgICAgICAgTm9Eb2N1bWVudCh2MylcclxuICogUGF0Y2hNdXRhdGlvbiAgICAgIEludmFsaWREb2N1bWVudCh2MCkgICBVbmtub3duRG9jdW1lbnQodjMpXHJcbiAqIERlbGV0ZU11dGF0aW9uICAgICBEb2N1bWVudCh2MykgICAgICAgICAgTm9Eb2N1bWVudCh2MClcclxuICogRGVsZXRlTXV0YXRpb24gICAgIE5vRG9jdW1lbnQodjMpICAgICAgICBOb0RvY3VtZW50KHYwKVxyXG4gKiBEZWxldGVNdXRhdGlvbiAgICAgSW52YWxpZERvY3VtZW50KHYwKSAgIE5vRG9jdW1lbnQodjApXHJcbiAqXHJcbiAqIEZvciBhY2tub3dsZWRnZWQgbXV0YXRpb25zLCB3ZSB1c2UgdGhlIHVwZGF0ZVRpbWUgb2YgdGhlIFdyaXRlUmVzcG9uc2UgYXNcclxuICogdGhlIHJlc3VsdGluZyB2ZXJzaW9uIGZvciBTZXQgYW5kIFBhdGNoIG11dGF0aW9ucy4gQXMgZGVsZXRlcyBoYXZlIG5vXHJcbiAqIGV4cGxpY2l0IHVwZGF0ZSB0aW1lLCB3ZSB1c2UgdGhlIGNvbW1pdFRpbWUgb2YgdGhlIFdyaXRlUmVzcG9uc2UgZm9yXHJcbiAqIERlbGV0ZSBtdXRhdGlvbnMuXHJcbiAqXHJcbiAqIElmIGEgbXV0YXRpb24gaXMgYWNrbm93bGVkZ2VkIGJ5IHRoZSBiYWNrZW5kIGJ1dCBmYWlscyB0aGUgcHJlY29uZGl0aW9uIGNoZWNrXHJcbiAqIGxvY2FsbHksIHdlIHRyYW5zaXRpb24gdG8gYW4gYFVua25vd25Eb2N1bWVudGAgYW5kIHJlbHkgb24gV2F0Y2ggdG8gc2VuZCB1c1xyXG4gKiB0aGUgdXBkYXRlZCB2ZXJzaW9uLlxyXG4gKlxyXG4gKiBGaWVsZCB0cmFuc2Zvcm1zIGFyZSB1c2VkIG9ubHkgd2l0aCBQYXRjaCBhbmQgU2V0IE11dGF0aW9ucy4gV2UgdXNlIHRoZVxyXG4gKiBgdXBkYXRlVHJhbnNmb3Jtc2AgbWVzc2FnZSB0byBzdG9yZSB0cmFuc2Zvcm1zLCByYXRoZXIgdGhhbiB0aGUgYHRyYW5zZm9ybXNgc1xyXG4gKiBtZXNzYWdlcy5cclxuICpcclxuICogIyMgU3ViY2xhc3NpbmcgTm90ZXNcclxuICpcclxuICogRXZlcnkgdHlwZSBvZiBtdXRhdGlvbiBuZWVkcyB0byBpbXBsZW1lbnQgaXRzIG93biBhcHBseVRvUmVtb3RlRG9jdW1lbnQoKSBhbmRcclxuICogYXBwbHlUb0xvY2FsVmlldygpIHRvIGltcGxlbWVudCB0aGUgYWN0dWFsIGJlaGF2aW9yIG9mIGFwcGx5aW5nIHRoZSBtdXRhdGlvblxyXG4gKiB0byBzb21lIHNvdXJjZSBkb2N1bWVudCAoc2VlIGBzZXRNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudCgpYCBmb3IgYW5cclxuICogZXhhbXBsZSkuXHJcbiAqL1xyXG5jbGFzcyBNdXRhdGlvbiB7XHJcbn1cclxuLyoqXHJcbiAqIEEgbXV0YXRpb24gdGhhdCBjcmVhdGVzIG9yIHJlcGxhY2VzIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4ga2V5IHdpdGggdGhlXHJcbiAqIG9iamVjdCB2YWx1ZSBjb250ZW50cy5cclxuICovXHJcbmNsYXNzIFNldE11dGF0aW9uIGV4dGVuZHMgTXV0YXRpb24ge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSwgcHJlY29uZGl0aW9uLCBmaWVsZFRyYW5zZm9ybXMgPSBbXSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMucHJlY29uZGl0aW9uID0gcHJlY29uZGl0aW9uO1xyXG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gZmllbGRUcmFuc2Zvcm1zO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IDAgLyogTXV0YXRpb25UeXBlLlNldCAqLztcclxuICAgIH1cclxuICAgIGdldEZpZWxkTWFzaygpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBtdXRhdGlvbiB0aGF0IG1vZGlmaWVzIGZpZWxkcyBvZiB0aGUgZG9jdW1lbnQgYXQgdGhlIGdpdmVuIGtleSB3aXRoIHRoZVxyXG4gKiBnaXZlbiB2YWx1ZXMuIFRoZSB2YWx1ZXMgYXJlIGFwcGxpZWQgdGhyb3VnaCBhIGZpZWxkIG1hc2s6XHJcbiAqXHJcbiAqICAqIFdoZW4gYSBmaWVsZCBpcyBpbiBib3RoIHRoZSBtYXNrIGFuZCB0aGUgdmFsdWVzLCB0aGUgY29ycmVzcG9uZGluZyBmaWVsZFxyXG4gKiAgICBpcyB1cGRhdGVkLlxyXG4gKiAgKiBXaGVuIGEgZmllbGQgaXMgaW4gbmVpdGhlciB0aGUgbWFzayBub3IgdGhlIHZhbHVlcywgdGhlIGNvcnJlc3BvbmRpbmdcclxuICogICAgZmllbGQgaXMgdW5tb2RpZmllZC5cclxuICogICogV2hlbiBhIGZpZWxkIGlzIGluIHRoZSBtYXNrIGJ1dCBub3QgaW4gdGhlIHZhbHVlcywgdGhlIGNvcnJlc3BvbmRpbmcgZmllbGRcclxuICogICAgaXMgZGVsZXRlZC5cclxuICogICogV2hlbiBhIGZpZWxkIGlzIG5vdCBpbiB0aGUgbWFzayBidXQgaXMgaW4gdGhlIHZhbHVlcywgdGhlIHZhbHVlcyBtYXAgaXNcclxuICogICAgaWdub3JlZC5cclxuICovXHJcbmNsYXNzIFBhdGNoTXV0YXRpb24gZXh0ZW5kcyBNdXRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIGRhdGEsIGZpZWxkTWFzaywgcHJlY29uZGl0aW9uLCBmaWVsZFRyYW5zZm9ybXMgPSBbXSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLmZpZWxkTWFzayA9IGZpZWxkTWFzaztcclxuICAgICAgICB0aGlzLnByZWNvbmRpdGlvbiA9IHByZWNvbmRpdGlvbjtcclxuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IGZpZWxkVHJhbnNmb3JtcztcclxuICAgICAgICB0aGlzLnR5cGUgPSAxIC8qIE11dGF0aW9uVHlwZS5QYXRjaCAqLztcclxuICAgIH1cclxuICAgIGdldEZpZWxkTWFzaygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWVsZE1hc2s7XHJcbiAgICB9XHJcbn1cclxuLyoqIEEgbXV0YXRpb24gdGhhdCBkZWxldGVzIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4ga2V5LiAqL1xyXG5jbGFzcyBEZWxldGVNdXRhdGlvbiBleHRlbmRzIE11dGF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGtleSwgcHJlY29uZGl0aW9uKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnByZWNvbmRpdGlvbiA9IHByZWNvbmRpdGlvbjtcclxuICAgICAgICB0aGlzLnR5cGUgPSAyIC8qIE11dGF0aW9uVHlwZS5EZWxldGUgKi87XHJcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBbXTtcclxuICAgIH1cclxuICAgIGdldEZpZWxkTWFzaygpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBtdXRhdGlvbiB0aGF0IHZlcmlmaWVzIHRoZSBleGlzdGVuY2Ugb2YgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBrZXkgd2l0aFxyXG4gKiB0aGUgcHJvdmlkZWQgcHJlY29uZGl0aW9uLlxyXG4gKlxyXG4gKiBUaGUgYHZlcmlmeWAgb3BlcmF0aW9uIGlzIG9ubHkgdXNlZCBpbiBUcmFuc2FjdGlvbnMsIGFuZCB0aGlzIGNsYXNzIHNlcnZlc1xyXG4gKiBwcmltYXJpbHkgdG8gZmFjaWxpdGF0ZSBzZXJpYWxpemF0aW9uIGludG8gcHJvdG9zLlxyXG4gKi9cclxuY2xhc3MgVmVyaWZ5TXV0YXRpb24gZXh0ZW5kcyBNdXRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHByZWNvbmRpdGlvbikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5wcmVjb25kaXRpb24gPSBwcmVjb25kaXRpb247XHJcbiAgICAgICAgdGhpcy50eXBlID0gMyAvKiBNdXRhdGlvblR5cGUuVmVyaWZ5ICovO1xyXG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gW107XHJcbiAgICB9XHJcbiAgICBnZXRGaWVsZE1hc2soKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgRElSRUNUSU9OUyA9ICgoKSA9PiB7XHJcbiAgICBjb25zdCBkaXJzID0ge307XHJcbiAgICBkaXJzW1wiYXNjXCIgLyogRGlyZWN0aW9uLkFTQ0VORElORyAqL10gPSAnQVNDRU5ESU5HJztcclxuICAgIGRpcnNbXCJkZXNjXCIgLyogRGlyZWN0aW9uLkRFU0NFTkRJTkcgKi9dID0gJ0RFU0NFTkRJTkcnO1xyXG4gICAgcmV0dXJuIGRpcnM7XHJcbn0pKCk7XHJcbmNvbnN0IE9QRVJBVE9SUyA9ICgoKSA9PiB7XHJcbiAgICBjb25zdCBvcHMgPSB7fTtcclxuICAgIG9wc1tcIjxcIiAvKiBPcGVyYXRvci5MRVNTX1RIQU4gKi9dID0gJ0xFU1NfVEhBTic7XHJcbiAgICBvcHNbXCI8PVwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTl9PUl9FUVVBTCAqL10gPSAnTEVTU19USEFOX09SX0VRVUFMJztcclxuICAgIG9wc1tcIj5cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU4gKi9dID0gJ0dSRUFURVJfVEhBTic7XHJcbiAgICBvcHNbXCI+PVwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTl9PUl9FUVVBTCAqL10gPSAnR1JFQVRFUl9USEFOX09SX0VRVUFMJztcclxuICAgIG9wc1tcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi9dID0gJ0VRVUFMJztcclxuICAgIG9wc1tcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovXSA9ICdOT1RfRVFVQUwnO1xyXG4gICAgb3BzW1wiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqL10gPSAnQVJSQVlfQ09OVEFJTlMnO1xyXG4gICAgb3BzW1wiaW5cIiAvKiBPcGVyYXRvci5JTiAqL10gPSAnSU4nO1xyXG4gICAgb3BzW1wibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovXSA9ICdOT1RfSU4nO1xyXG4gICAgb3BzW1wiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovXSA9ICdBUlJBWV9DT05UQUlOU19BTlknO1xyXG4gICAgcmV0dXJuIG9wcztcclxufSkoKTtcclxuY29uc3QgQ09NUE9TSVRFX09QRVJBVE9SUyA9ICgoKSA9PiB7XHJcbiAgICBjb25zdCBvcHMgPSB7fTtcclxuICAgIG9wc1tcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqL10gPSAnQU5EJztcclxuICAgIG9wc1tcIm9yXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuT1IgKi9dID0gJ09SJztcclxuICAgIHJldHVybiBvcHM7XHJcbn0pKCk7XHJcbmZ1bmN0aW9uIGFzc2VydFByZXNlbnQodmFsdWUsIGRlc2NyaXB0aW9uKSB7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgZ2VuZXJhdGVzIEpzb25PYmplY3QgdmFsdWVzIGZvciB0aGUgRGF0YXN0b3JlIEFQSSBzdWl0YWJsZSBmb3JcclxuICogc2VuZGluZyB0byBlaXRoZXIgR1JQQyBzdHViIG1ldGhvZHMgb3IgdmlhIHRoZSBKU09OL0hUVFAgUkVTVCBBUEkuXHJcbiAqXHJcbiAqIFRoZSBzZXJpYWxpemVyIHN1cHBvcnRzIGJvdGggUHJvdG9idWYuanMgYW5kIFByb3RvMyBKU09OIGZvcm1hdHMuIEJ5XHJcbiAqIHNldHRpbmcgYHVzZVByb3RvM0pzb25gIHRvIHRydWUsIHRoZSBzZXJpYWxpemVyIHdpbGwgdXNlIHRoZSBQcm90bzMgSlNPTlxyXG4gKiBmb3JtYXQuXHJcbiAqXHJcbiAqIEZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBQcm90bzMgSlNPTiBmb3JtYXQgY2hlY2tcclxuICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL3Byb3RvMyNqc29uXHJcbiAqXHJcbiAqIFRPRE8oa2xpbXQpOiBXZSBjYW4gcmVtb3ZlIHRoZSBkYXRhYmFzZUlkIGFyZ3VtZW50IGlmIHdlIGtlZXAgdGhlIGZ1bGxcclxuICogcmVzb3VyY2UgbmFtZSBpbiBkb2N1bWVudHMuXHJcbiAqL1xyXG5jbGFzcyBKc29uUHJvdG9TZXJpYWxpemVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGFiYXNlSWQsIHVzZVByb3RvM0pzb24pIHtcclxuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBkYXRhYmFzZUlkO1xyXG4gICAgICAgIHRoaXMudXNlUHJvdG8zSnNvbiA9IHVzZVByb3RvM0pzb247XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSB2YWx1ZSBmb3IgYSBudW1iZXIgKG9yIG51bGwpIHRoYXQncyBhcHByb3ByaWF0ZSB0byBwdXQgaW50b1xyXG4gKiBhIGdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlIHByb3RvLlxyXG4gKiBETyBOT1QgVVNFIFRISVMgRk9SIEFOWVRISU5HIEVMU0UuXHJcbiAqIFRoaXMgbWV0aG9kIGNoZWF0cy4gSXQncyB0eXBlZCBhcyByZXR1cm5pbmcgXCJudW1iZXJcIiBiZWNhdXNlIHRoYXQncyB3aGF0XHJcbiAqIG91ciBnZW5lcmF0ZWQgcHJvdG8gaW50ZXJmYWNlcyBzYXkgSW50MzJWYWx1ZSBtdXN0IGJlLiBCdXQgR1JQQyBhY3R1YWxseVxyXG4gKiBleHBlY3RzIGEgeyB2YWx1ZTogPG51bWJlcj4gfSBzdHJ1Y3QuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0ludDMyUHJvdG8oc2VyaWFsaXplciwgdmFsKSB7XHJcbiAgICBpZiAoc2VyaWFsaXplci51c2VQcm90bzNKc29uIHx8IGlzTnVsbE9yVW5kZWZpbmVkKHZhbCkpIHtcclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbCB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgdmFsdWUgZm9yIGEgRGF0ZSB0aGF0J3MgYXBwcm9wcmlhdGUgdG8gcHV0IGludG8gYSBwcm90by5cclxuICovXHJcbmZ1bmN0aW9uIHRvVGltZXN0YW1wKHNlcmlhbGl6ZXIsIHRpbWVzdGFtcCkge1xyXG4gICAgaWYgKHNlcmlhbGl6ZXIudXNlUHJvdG8zSnNvbikge1xyXG4gICAgICAgIC8vIFNlcmlhbGl6ZSB0byBJU08tODYwMSBkYXRlIGZvcm1hdCwgYnV0IHdpdGggZnVsbCBuYW5vIHJlc29sdXRpb24uXHJcbiAgICAgICAgLy8gU2luY2UgSlMgRGF0ZSBoYXMgb25seSBtaWxsaXMsIGxldCdzIG9ubHkgdXNlIGl0IGZvciB0aGUgc2Vjb25kcyBhbmRcclxuICAgICAgICAvLyB0aGVuIG1hbnVhbGx5IGFkZCB0aGUgZnJhY3Rpb25zIHRvIHRoZSBlbmQuXHJcbiAgICAgICAgY29uc3QganNEYXRlU3RyID0gbmV3IERhdGUodGltZXN0YW1wLnNlY29uZHMgKiAxMDAwKS50b0lTT1N0cmluZygpO1xyXG4gICAgICAgIC8vIFJlbW92ZSAueHh4IGZyYWMgcGFydCBhbmQgWiBpbiB0aGUgZW5kLlxyXG4gICAgICAgIGNvbnN0IHN0clVudGlsU2Vjb25kcyA9IGpzRGF0ZVN0ci5yZXBsYWNlKC9cXC5cXGQqLywgJycpLnJlcGxhY2UoJ1onLCAnJyk7XHJcbiAgICAgICAgLy8gUGFkIHRoZSBmcmFjdGlvbiBvdXQgdG8gOSBkaWdpdHMgKG5hbm9zKS5cclxuICAgICAgICBjb25zdCBuYW5vU3RyID0gKCcwMDAwMDAwMDAnICsgdGltZXN0YW1wLm5hbm9zZWNvbmRzKS5zbGljZSgtOSk7XHJcbiAgICAgICAgcmV0dXJuIGAke3N0clVudGlsU2Vjb25kc30uJHtuYW5vU3RyfVpgO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2Vjb25kczogJycgKyB0aW1lc3RhbXAuc2Vjb25kcyxcclxuICAgICAgICAgICAgbmFub3M6IHRpbWVzdGFtcC5uYW5vc2Vjb25kc1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZnJvbVRpbWVzdGFtcChkYXRlKSB7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAoZGF0ZSk7XHJcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCh0aW1lc3RhbXAuc2Vjb25kcywgdGltZXN0YW1wLm5hbm9zKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHZhbHVlIGZvciBieXRlcyB0aGF0J3MgYXBwcm9wcmlhdGUgdG8gcHV0IGluIGEgcHJvdG8uXHJcbiAqXHJcbiAqIFZpc2libGUgZm9yIHRlc3RpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0J5dGVzKHNlcmlhbGl6ZXIsIGJ5dGVzKSB7XHJcbiAgICBpZiAoc2VyaWFsaXplci51c2VQcm90bzNKc29uKSB7XHJcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvQmFzZTY0KCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYnl0ZXMudG9VaW50OEFycmF5KCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9WZXJzaW9uKHNlcmlhbGl6ZXIsIHZlcnNpb24pIHtcclxuICAgIHJldHVybiB0b1RpbWVzdGFtcChzZXJpYWxpemVyLCB2ZXJzaW9uLnRvVGltZXN0YW1wKCkpO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21WZXJzaW9uKHZlcnNpb24pIHtcclxuICAgIGhhcmRBc3NlcnQoISF2ZXJzaW9uKTtcclxuICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24uZnJvbVRpbWVzdGFtcChmcm9tVGltZXN0YW1wKHZlcnNpb24pKTtcclxufVxyXG5mdW5jdGlvbiB0b1Jlc291cmNlTmFtZShkYXRhYmFzZUlkLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gdG9SZXNvdXJjZVBhdGgoZGF0YWJhc2VJZCwgcGF0aCkuY2Fub25pY2FsU3RyaW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gdG9SZXNvdXJjZVBhdGgoZGF0YWJhc2VJZCwgcGF0aCkge1xyXG4gICAgY29uc3QgcmVzb3VyY2VQYXRoID0gZnVsbHlRdWFsaWZpZWRQcmVmaXhQYXRoKGRhdGFiYXNlSWQpLmNoaWxkKCdkb2N1bWVudHMnKTtcclxuICAgIHJldHVybiBwYXRoID09PSB1bmRlZmluZWQgPyByZXNvdXJjZVBhdGggOiByZXNvdXJjZVBhdGguY2hpbGQocGF0aCk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbVJlc291cmNlTmFtZShuYW1lKSB7XHJcbiAgICBjb25zdCByZXNvdXJjZSA9IFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKG5hbWUpO1xyXG4gICAgaGFyZEFzc2VydChpc1ZhbGlkUmVzb3VyY2VOYW1lKHJlc291cmNlKSk7XHJcbiAgICByZXR1cm4gcmVzb3VyY2U7XHJcbn1cclxuZnVuY3Rpb24gdG9OYW1lKHNlcmlhbGl6ZXIsIGtleSkge1xyXG4gICAgcmV0dXJuIHRvUmVzb3VyY2VOYW1lKHNlcmlhbGl6ZXIuZGF0YWJhc2VJZCwga2V5LnBhdGgpO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21OYW1lKHNlcmlhbGl6ZXIsIG5hbWUpIHtcclxuICAgIGNvbnN0IHJlc291cmNlID0gZnJvbVJlc291cmNlTmFtZShuYW1lKTtcclxuICAgIGlmIChyZXNvdXJjZS5nZXQoMSkgIT09IHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5wcm9qZWN0SWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVHJpZWQgdG8gZGVzZXJpYWxpemUga2V5IGZyb20gZGlmZmVyZW50IHByb2plY3Q6ICcgK1xyXG4gICAgICAgICAgICByZXNvdXJjZS5nZXQoMSkgK1xyXG4gICAgICAgICAgICAnIHZzICcgK1xyXG4gICAgICAgICAgICBzZXJpYWxpemVyLmRhdGFiYXNlSWQucHJvamVjdElkKTtcclxuICAgIH1cclxuICAgIGlmIChyZXNvdXJjZS5nZXQoMykgIT09IHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5kYXRhYmFzZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdUcmllZCB0byBkZXNlcmlhbGl6ZSBrZXkgZnJvbSBkaWZmZXJlbnQgZGF0YWJhc2U6ICcgK1xyXG4gICAgICAgICAgICByZXNvdXJjZS5nZXQoMykgK1xyXG4gICAgICAgICAgICAnIHZzICcgK1xyXG4gICAgICAgICAgICBzZXJpYWxpemVyLmRhdGFiYXNlSWQuZGF0YWJhc2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShleHRyYWN0TG9jYWxQYXRoRnJvbVJlc291cmNlTmFtZShyZXNvdXJjZSkpO1xyXG59XHJcbmZ1bmN0aW9uIHRvUXVlcnlQYXRoKHNlcmlhbGl6ZXIsIHBhdGgpIHtcclxuICAgIHJldHVybiB0b1Jlc291cmNlTmFtZShzZXJpYWxpemVyLmRhdGFiYXNlSWQsIHBhdGgpO1xyXG59XHJcbmZ1bmN0aW9uIGZ1bGx5UXVhbGlmaWVkUHJlZml4UGF0aChkYXRhYmFzZUlkKSB7XHJcbiAgICByZXR1cm4gbmV3IFJlc291cmNlUGF0aChbXHJcbiAgICAgICAgJ3Byb2plY3RzJyxcclxuICAgICAgICBkYXRhYmFzZUlkLnByb2plY3RJZCxcclxuICAgICAgICAnZGF0YWJhc2VzJyxcclxuICAgICAgICBkYXRhYmFzZUlkLmRhdGFiYXNlXHJcbiAgICBdKTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0TG9jYWxQYXRoRnJvbVJlc291cmNlTmFtZShyZXNvdXJjZU5hbWUpIHtcclxuICAgIGhhcmRBc3NlcnQocmVzb3VyY2VOYW1lLmxlbmd0aCA+IDQgJiYgcmVzb3VyY2VOYW1lLmdldCg0KSA9PT0gJ2RvY3VtZW50cycpO1xyXG4gICAgcmV0dXJuIHJlc291cmNlTmFtZS5wb3BGaXJzdCg1KTtcclxufVxyXG4vKiogQ3JlYXRlcyBhIERvY3VtZW50IHByb3RvIGZyb20ga2V5IGFuZCBmaWVsZHMgKGJ1dCBubyBjcmVhdGUvdXBkYXRlIHRpbWUpICovXHJcbmZ1bmN0aW9uIHRvTXV0YXRpb25Eb2N1bWVudChzZXJpYWxpemVyLCBrZXksIGZpZWxkcykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiB0b05hbWUoc2VyaWFsaXplciwga2V5KSxcclxuICAgICAgICBmaWVsZHM6IGZpZWxkcy52YWx1ZS5tYXBWYWx1ZS5maWVsZHNcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZnJvbURvY3VtZW50KHNlcmlhbGl6ZXIsIGRvY3VtZW50LCBoYXNDb21taXR0ZWRNdXRhdGlvbnMpIHtcclxuICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIGRvY3VtZW50Lm5hbWUpO1xyXG4gICAgY29uc3QgdmVyc2lvbiA9IGZyb21WZXJzaW9uKGRvY3VtZW50LnVwZGF0ZVRpbWUpO1xyXG4gICAgLy8gSWYgd2UgcmVhZCBhIGRvY3VtZW50IGZyb20gcGVyc2lzdGVuY2UgdGhhdCBpcyBtaXNzaW5nIGNyZWF0ZVRpbWUsIGl0J3MgZHVlXHJcbiAgICAvLyB0byBvbGRlciBTREsgdmVyc2lvbnMgbm90IHN0b3JpbmcgdGhpcyBpbmZvcm1hdGlvbi4gSW4gc3VjaCBjYXNlcywgd2UnbGxcclxuICAgIC8vIHNldCB0aGUgY3JlYXRlVGltZSB0byB6ZXJvLiBUaGlzIGNhbiBiZSByZW1vdmVkIGluIHRoZSBsb25nIHRlcm0uXHJcbiAgICBjb25zdCBjcmVhdGVUaW1lID0gZG9jdW1lbnQuY3JlYXRlVGltZVxyXG4gICAgICAgID8gZnJvbVZlcnNpb24oZG9jdW1lbnQuY3JlYXRlVGltZSlcclxuICAgICAgICA6IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgIGNvbnN0IGRhdGEgPSBuZXcgT2JqZWN0VmFsdWUoeyBtYXBWYWx1ZTogeyBmaWVsZHM6IGRvY3VtZW50LmZpZWxkcyB9IH0pO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gTXV0YWJsZURvY3VtZW50Lm5ld0ZvdW5kRG9jdW1lbnQoa2V5LCB2ZXJzaW9uLCBjcmVhdGVUaW1lLCBkYXRhKTtcclxuICAgIGlmIChoYXNDb21taXR0ZWRNdXRhdGlvbnMpIHtcclxuICAgICAgICByZXN1bHQuc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzQ29tbWl0dGVkTXV0YXRpb25zID8gcmVzdWx0LnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpIDogcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGZyb21Gb3VuZChzZXJpYWxpemVyLCBkb2MpIHtcclxuICAgIGhhcmRBc3NlcnQoISFkb2MuZm91bmQpO1xyXG4gICAgYXNzZXJ0UHJlc2VudChkb2MuZm91bmQubmFtZSk7XHJcbiAgICBhc3NlcnRQcmVzZW50KGRvYy5mb3VuZC51cGRhdGVUaW1lKTtcclxuICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIGRvYy5mb3VuZC5uYW1lKTtcclxuICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tVmVyc2lvbihkb2MuZm91bmQudXBkYXRlVGltZSk7XHJcbiAgICBjb25zdCBjcmVhdGVUaW1lID0gZG9jLmZvdW5kLmNyZWF0ZVRpbWVcclxuICAgICAgICA/IGZyb21WZXJzaW9uKGRvYy5mb3VuZC5jcmVhdGVUaW1lKVxyXG4gICAgICAgIDogU25hcHNob3RWZXJzaW9uLm1pbigpO1xyXG4gICAgY29uc3QgZGF0YSA9IG5ldyBPYmplY3RWYWx1ZSh7IG1hcFZhbHVlOiB7IGZpZWxkczogZG9jLmZvdW5kLmZpZWxkcyB9IH0pO1xyXG4gICAgcmV0dXJuIE11dGFibGVEb2N1bWVudC5uZXdGb3VuZERvY3VtZW50KGtleSwgdmVyc2lvbiwgY3JlYXRlVGltZSwgZGF0YSk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbU1pc3Npbmcoc2VyaWFsaXplciwgcmVzdWx0KSB7XHJcbiAgICBoYXJkQXNzZXJ0KCEhcmVzdWx0Lm1pc3NpbmcpO1xyXG4gICAgaGFyZEFzc2VydCghIXJlc3VsdC5yZWFkVGltZSk7XHJcbiAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCByZXN1bHQubWlzc2luZyk7XHJcbiAgICBjb25zdCB2ZXJzaW9uID0gZnJvbVZlcnNpb24ocmVzdWx0LnJlYWRUaW1lKTtcclxuICAgIHJldHVybiBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudChrZXksIHZlcnNpb24pO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21CYXRjaEdldERvY3VtZW50c1Jlc3BvbnNlKHNlcmlhbGl6ZXIsIHJlc3VsdCkge1xyXG4gICAgaWYgKCdmb3VuZCcgaW4gcmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21Gb3VuZChzZXJpYWxpemVyLCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ21pc3NpbmcnIGluIHJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiBmcm9tTWlzc2luZyhzZXJpYWxpemVyLCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhaWwoKTtcclxufVxyXG5mdW5jdGlvbiB0b011dGF0aW9uKHNlcmlhbGl6ZXIsIG11dGF0aW9uKSB7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgU2V0TXV0YXRpb24pIHtcclxuICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZTogdG9NdXRhdGlvbkRvY3VtZW50KHNlcmlhbGl6ZXIsIG11dGF0aW9uLmtleSwgbXV0YXRpb24udmFsdWUpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgRGVsZXRlTXV0YXRpb24pIHtcclxuICAgICAgICByZXN1bHQgPSB7IGRlbGV0ZTogdG9OYW1lKHNlcmlhbGl6ZXIsIG11dGF0aW9uLmtleSkgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgUGF0Y2hNdXRhdGlvbikge1xyXG4gICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgdXBkYXRlOiB0b011dGF0aW9uRG9jdW1lbnQoc2VyaWFsaXplciwgbXV0YXRpb24ua2V5LCBtdXRhdGlvbi5kYXRhKSxcclxuICAgICAgICAgICAgdXBkYXRlTWFzazogdG9Eb2N1bWVudE1hc2sobXV0YXRpb24uZmllbGRNYXNrKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtdXRhdGlvbiBpbnN0YW5jZW9mIFZlcmlmeU11dGF0aW9uKSB7XHJcbiAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICB2ZXJpZnk6IHRvTmFtZShzZXJpYWxpemVyLCBtdXRhdGlvbi5rZXkpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbiAgICBpZiAobXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICByZXN1bHQudXBkYXRlVHJhbnNmb3JtcyA9IG11dGF0aW9uLmZpZWxkVHJhbnNmb3Jtcy5tYXAodHJhbnNmb3JtID0+IHRvRmllbGRUcmFuc2Zvcm0oc2VyaWFsaXplciwgdHJhbnNmb3JtKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIW11dGF0aW9uLnByZWNvbmRpdGlvbi5pc05vbmUpIHtcclxuICAgICAgICByZXN1bHQuY3VycmVudERvY3VtZW50ID0gdG9QcmVjb25kaXRpb24oc2VyaWFsaXplciwgbXV0YXRpb24ucHJlY29uZGl0aW9uKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gdG9QcmVjb25kaXRpb24oc2VyaWFsaXplciwgcHJlY29uZGl0aW9uKSB7XHJcbiAgICBpZiAocHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVwZGF0ZVRpbWU6IHRvVmVyc2lvbihzZXJpYWxpemVyLCBwcmVjb25kaXRpb24udXBkYXRlVGltZSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJlY29uZGl0aW9uLmV4aXN0cyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgZXhpc3RzOiBwcmVjb25kaXRpb24uZXhpc3RzIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvRmllbGRUcmFuc2Zvcm0oc2VyaWFsaXplciwgZmllbGRUcmFuc2Zvcm0pIHtcclxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGZpZWxkVHJhbnNmb3JtLnRyYW5zZm9ybTtcclxuICAgIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWVsZFBhdGg6IGZpZWxkVHJhbnNmb3JtLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpLFxyXG4gICAgICAgICAgICBzZXRUb1NlcnZlclZhbHVlOiAnUkVRVUVTVF9USU1FJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmllbGRQYXRoOiBmaWVsZFRyYW5zZm9ybS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSxcclxuICAgICAgICAgICAgYXBwZW5kTWlzc2luZ0VsZW1lbnRzOiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHRyYW5zZm9ybS5lbGVtZW50c1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmllbGRQYXRoOiBmaWVsZFRyYW5zZm9ybS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSxcclxuICAgICAgICAgICAgcmVtb3ZlQWxsRnJvbUFycmF5OiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHRyYW5zZm9ybS5lbGVtZW50c1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIE51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWVsZFBhdGg6IGZpZWxkVHJhbnNmb3JtLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpLFxyXG4gICAgICAgICAgICBpbmNyZW1lbnQ6IHRyYW5zZm9ybS5vcGVyYW5kXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b1F1ZXJ5VGFyZ2V0KHNlcmlhbGl6ZXIsIHRhcmdldCkge1xyXG4gICAgLy8gRGlzc2VjdCB0aGUgcGF0aCBpbnRvIHBhcmVudCwgY29sbGVjdGlvbklkLCBhbmQgb3B0aW9uYWwga2V5IGZpbHRlci5cclxuICAgIGNvbnN0IHF1ZXJ5VGFyZ2V0ID0geyBzdHJ1Y3R1cmVkUXVlcnk6IHt9IH07XHJcbiAgICBjb25zdCBwYXRoID0gdGFyZ2V0LnBhdGg7XHJcbiAgICBsZXQgcGFyZW50O1xyXG4gICAgaWYgKHRhcmdldC5jb2xsZWN0aW9uR3JvdXAgIT09IG51bGwpIHtcclxuICAgICAgICBwYXJlbnQgPSBwYXRoO1xyXG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS5mcm9tID0gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uSWQ6IHRhcmdldC5jb2xsZWN0aW9uR3JvdXAsXHJcbiAgICAgICAgICAgICAgICBhbGxEZXNjZW5kYW50czogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHBhcmVudCA9IHBhdGgucG9wTGFzdCgpO1xyXG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS5mcm9tID0gW3sgY29sbGVjdGlvbklkOiBwYXRoLmxhc3RTZWdtZW50KCkgfV07XHJcbiAgICB9XHJcbiAgICBxdWVyeVRhcmdldC5wYXJlbnQgPSB0b1F1ZXJ5UGF0aChzZXJpYWxpemVyLCBwYXJlbnQpO1xyXG4gICAgY29uc3Qgd2hlcmUgPSB0b0ZpbHRlcnModGFyZ2V0LmZpbHRlcnMpO1xyXG4gICAgaWYgKHdoZXJlKSB7XHJcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5LndoZXJlID0gd2hlcmU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvcmRlckJ5ID0gdG9PcmRlcih0YXJnZXQub3JkZXJCeSk7XHJcbiAgICBpZiAob3JkZXJCeSkge1xyXG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS5vcmRlckJ5ID0gb3JkZXJCeTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxpbWl0ID0gdG9JbnQzMlByb3RvKHNlcmlhbGl6ZXIsIHRhcmdldC5saW1pdCk7XHJcbiAgICBpZiAobGltaXQgIT09IG51bGwpIHtcclxuICAgICAgICBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnkubGltaXQgPSBsaW1pdDtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQuc3RhcnRBdCkge1xyXG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS5zdGFydEF0ID0gdG9TdGFydEF0Q3Vyc29yKHRhcmdldC5zdGFydEF0KTtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQuZW5kQXQpIHtcclxuICAgICAgICBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnkuZW5kQXQgPSB0b0VuZEF0Q3Vyc29yKHRhcmdldC5lbmRBdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBxdWVyeVRhcmdldCwgcGFyZW50IH07XHJcbn1cclxuZnVuY3Rpb24gdG9SdW5BZ2dyZWdhdGlvblF1ZXJ5UmVxdWVzdChzZXJpYWxpemVyLCB0YXJnZXQsIGFnZ3JlZ2F0ZXMpIHtcclxuICAgIGNvbnN0IHsgcXVlcnlUYXJnZXQsIHBhcmVudCB9ID0gdG9RdWVyeVRhcmdldChzZXJpYWxpemVyLCB0YXJnZXQpO1xyXG4gICAgY29uc3QgYWxpYXNNYXAgPSB7fTtcclxuICAgIGNvbnN0IGFnZ3JlZ2F0aW9ucyA9IFtdO1xyXG4gICAgbGV0IGFnZ3JlZ2F0aW9uTnVtID0gMDtcclxuICAgIGFnZ3JlZ2F0ZXMuZm9yRWFjaChhZ2dyZWdhdGUgPT4ge1xyXG4gICAgICAgIC8vIE1hcCBhbGwgY2xpZW50LXNpZGUgYWxpYXNlcyB0byBhIHVuaXF1ZSBzaG9ydC1mb3JtXHJcbiAgICAgICAgLy8gYWxpYXMuIFRoaXMgYXZvaWRzIGlzc3VlcyB3aXRoIGNsaWVudC1zaWRlIGFsaWFzZXMgdGhhdFxyXG4gICAgICAgIC8vIGV4Y2VlZCB0aGUgMTUwMC1ieXRlIHN0cmluZyBzaXplIGxpbWl0LlxyXG4gICAgICAgIGNvbnN0IHNlcnZlckFsaWFzID0gYGFnZ3JlZ2F0ZV8ke2FnZ3JlZ2F0aW9uTnVtKyt9YDtcclxuICAgICAgICBhbGlhc01hcFtzZXJ2ZXJBbGlhc10gPSBhZ2dyZWdhdGUuYWxpYXM7XHJcbiAgICAgICAgaWYgKGFnZ3JlZ2F0ZS5hZ2dyZWdhdGVUeXBlID09PSAnY291bnQnKSB7XHJcbiAgICAgICAgICAgIGFnZ3JlZ2F0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGFsaWFzOiBzZXJ2ZXJBbGlhcyxcclxuICAgICAgICAgICAgICAgIGNvdW50OiB7fVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWdncmVnYXRlLmFnZ3JlZ2F0ZVR5cGUgPT09ICdhdmcnKSB7XHJcbiAgICAgICAgICAgIGFnZ3JlZ2F0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGFsaWFzOiBzZXJ2ZXJBbGlhcyxcclxuICAgICAgICAgICAgICAgIGF2Zzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShhZ2dyZWdhdGUuZmllbGRQYXRoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWdncmVnYXRlLmFnZ3JlZ2F0ZVR5cGUgPT09ICdzdW0nKSB7XHJcbiAgICAgICAgICAgIGFnZ3JlZ2F0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGFsaWFzOiBzZXJ2ZXJBbGlhcyxcclxuICAgICAgICAgICAgICAgIHN1bToge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShhZ2dyZWdhdGUuZmllbGRQYXRoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVxdWVzdDoge1xyXG4gICAgICAgICAgICBzdHJ1Y3R1cmVkQWdncmVnYXRpb25RdWVyeToge1xyXG4gICAgICAgICAgICAgICAgYWdncmVnYXRpb25zLFxyXG4gICAgICAgICAgICAgICAgc3RydWN0dXJlZFF1ZXJ5OiBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGFyZW50OiBxdWVyeVRhcmdldC5wYXJlbnRcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFsaWFzTWFwLFxyXG4gICAgICAgIHBhcmVudFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0b0ZpbHRlcnMoZmlsdGVycykge1xyXG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvRmlsdGVyKENvbXBvc2l0ZUZpbHRlci5jcmVhdGUoZmlsdGVycywgXCJhbmRcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5BTkQgKi8pKTtcclxufVxyXG5mdW5jdGlvbiB0b09yZGVyKG9yZGVyQnlzKSB7XHJcbiAgICBpZiAob3JkZXJCeXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9yZGVyQnlzLm1hcChvcmRlciA9PiB0b1Byb3BlcnR5T3JkZXIob3JkZXIpKTtcclxufVxyXG5mdW5jdGlvbiB0b1N0YXJ0QXRDdXJzb3IoY3Vyc29yKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGJlZm9yZTogY3Vyc29yLmluY2x1c2l2ZSxcclxuICAgICAgICB2YWx1ZXM6IGN1cnNvci5wb3NpdGlvblxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0b0VuZEF0Q3Vyc29yKGN1cnNvcikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBiZWZvcmU6ICFjdXJzb3IuaW5jbHVzaXZlLFxyXG4gICAgICAgIHZhbHVlczogY3Vyc29yLnBvc2l0aW9uXHJcbiAgICB9O1xyXG59XHJcbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcclxuZnVuY3Rpb24gdG9EaXJlY3Rpb24oZGlyKSB7XHJcbiAgICByZXR1cm4gRElSRUNUSU9OU1tkaXJdO1xyXG59XHJcbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcclxuZnVuY3Rpb24gdG9PcGVyYXRvck5hbWUob3ApIHtcclxuICAgIHJldHVybiBPUEVSQVRPUlNbb3BdO1xyXG59XHJcbmZ1bmN0aW9uIHRvQ29tcG9zaXRlT3BlcmF0b3JOYW1lKG9wKSB7XHJcbiAgICByZXR1cm4gQ09NUE9TSVRFX09QRVJBVE9SU1tvcF07XHJcbn1cclxuZnVuY3Rpb24gdG9GaWVsZFBhdGhSZWZlcmVuY2UocGF0aCkge1xyXG4gICAgcmV0dXJuIHsgZmllbGRQYXRoOiBwYXRoLmNhbm9uaWNhbFN0cmluZygpIH07XHJcbn1cclxuLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xyXG5mdW5jdGlvbiB0b1Byb3BlcnR5T3JkZXIob3JkZXJCeSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmaWVsZDogdG9GaWVsZFBhdGhSZWZlcmVuY2Uob3JkZXJCeS5maWVsZCksXHJcbiAgICAgICAgZGlyZWN0aW9uOiB0b0RpcmVjdGlvbihvcmRlckJ5LmRpcilcclxuICAgIH07XHJcbn1cclxuLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xyXG5mdW5jdGlvbiB0b0ZpbHRlcihmaWx0ZXIpIHtcclxuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcikge1xyXG4gICAgICAgIHJldHVybiB0b1VuYXJ5T3JGaWVsZEZpbHRlcihmaWx0ZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvQ29tcG9zaXRlRmlsdGVyKGZpbHRlcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvQ29tcG9zaXRlRmlsdGVyKGZpbHRlcikge1xyXG4gICAgY29uc3QgcHJvdG9zID0gZmlsdGVyLmdldEZpbHRlcnMoKS5tYXAoZmlsdGVyID0+IHRvRmlsdGVyKGZpbHRlcikpO1xyXG4gICAgaWYgKHByb3Rvcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gcHJvdG9zWzBdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjb21wb3NpdGVGaWx0ZXI6IHtcclxuICAgICAgICAgICAgb3A6IHRvQ29tcG9zaXRlT3BlcmF0b3JOYW1lKGZpbHRlci5vcCksXHJcbiAgICAgICAgICAgIGZpbHRlcnM6IHByb3Rvc1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdG9VbmFyeU9yRmllbGRGaWx0ZXIoZmlsdGVyKSB7XHJcbiAgICBpZiAoZmlsdGVyLm9wID09PSBcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi8pIHtcclxuICAgICAgICBpZiAoaXNOYW5WYWx1ZShmaWx0ZXIudmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB1bmFyeUZpbHRlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wOiAnSVNfTkFOJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc051bGxWYWx1ZShmaWx0ZXIudmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB1bmFyeUZpbHRlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wOiAnSVNfTlVMTCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmaWx0ZXIub3AgPT09IFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi8pIHtcclxuICAgICAgICBpZiAoaXNOYW5WYWx1ZShmaWx0ZXIudmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB1bmFyeUZpbHRlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wOiAnSVNfTk9UX05BTidcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNOdWxsVmFsdWUoZmlsdGVyLnZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdW5hcnlGaWx0ZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogdG9GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLmZpZWxkKSxcclxuICAgICAgICAgICAgICAgICAgICBvcDogJ0lTX05PVF9OVUxMJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZmllbGRGaWx0ZXI6IHtcclxuICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZCksXHJcbiAgICAgICAgICAgIG9wOiB0b09wZXJhdG9yTmFtZShmaWx0ZXIub3ApLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmlsdGVyLnZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0b0RvY3VtZW50TWFzayhmaWVsZE1hc2spIHtcclxuICAgIGNvbnN0IGNhbm9uaWNhbEZpZWxkcyA9IFtdO1xyXG4gICAgZmllbGRNYXNrLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IGNhbm9uaWNhbEZpZWxkcy5wdXNoKGZpZWxkLmNhbm9uaWNhbFN0cmluZygpKSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZpZWxkUGF0aHM6IGNhbm9uaWNhbEZpZWxkc1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc1ZhbGlkUmVzb3VyY2VOYW1lKHBhdGgpIHtcclxuICAgIC8vIFJlc291cmNlIG5hbWVzIGhhdmUgYXQgbGVhc3QgNCBjb21wb25lbnRzIChwcm9qZWN0IElELCBkYXRhYmFzZSBJRClcclxuICAgIHJldHVybiAocGF0aC5sZW5ndGggPj0gNCAmJlxyXG4gICAgICAgIHBhdGguZ2V0KDApID09PSAncHJvamVjdHMnICYmXHJcbiAgICAgICAgcGF0aC5nZXQoMikgPT09ICdkYXRhYmFzZXMnKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdTZXJpYWxpemVyKGRhdGFiYXNlSWQpIHtcclxuICAgIHJldHVybiBuZXcgSnNvblByb3RvU2VyaWFsaXplcihkYXRhYmFzZUlkLCAvKiB1c2VQcm90bzNKc29uPSAqLyB0cnVlKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBMT0dfVEFHJDIgPSAnRXhwb25lbnRpYWxCYWNrb2ZmJztcclxuLyoqXHJcbiAqIEluaXRpYWwgYmFja29mZiB0aW1lIGluIG1pbGxpc2Vjb25kcyBhZnRlciBhbiBlcnJvci5cclxuICogU2V0IHRvIDFzIGFjY29yZGluZyB0byBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYXBpcy9kZXNpZ24vZXJyb3JzLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9CQUNLT0ZGX0lOSVRJQUxfREVMQVlfTVMgPSAxMDAwO1xyXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SID0gMS41O1xyXG4vKiogTWF4aW11bSBiYWNrb2ZmIHRpbWUgaW4gbWlsbGlzZWNvbmRzICovXHJcbmNvbnN0IERFRkFVTFRfQkFDS09GRl9NQVhfREVMQVlfTVMgPSA2MCAqIDEwMDA7XHJcbi8qKlxyXG4gKiBBIGhlbHBlciBmb3IgcnVubmluZyBkZWxheWVkIHRhc2tzIGZvbGxvd2luZyBhbiBleHBvbmVudGlhbCBiYWNrb2ZmIGN1cnZlXHJcbiAqIGJldHdlZW4gYXR0ZW1wdHMuXHJcbiAqXHJcbiAqIEVhY2ggZGVsYXkgaXMgbWFkZSB1cCBvZiBhIFwiYmFzZVwiIGRlbGF5IHdoaWNoIGZvbGxvd3MgdGhlIGV4cG9uZW50aWFsXHJcbiAqIGJhY2tvZmYgY3VydmUsIGFuZCBhICsvLSA1MCUgXCJqaXR0ZXJcIiB0aGF0IGlzIGNhbGN1bGF0ZWQgYW5kIGFkZGVkIHRvIHRoZVxyXG4gKiBiYXNlIGRlbGF5LiBUaGlzIHByZXZlbnRzIGNsaWVudHMgZnJvbSBhY2NpZGVudGFsbHkgc3luY2hyb25pemluZyB0aGVpclxyXG4gKiBkZWxheXMgY2F1c2luZyBzcGlrZXMgb2YgbG9hZCB0byB0aGUgYmFja2VuZC5cclxuICovXHJcbmNsYXNzIEV4cG9uZW50aWFsQmFja29mZiB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgICogVGhlIEFzeW5jUXVldWUgdG8gcnVuIGJhY2tvZmYgb3BlcmF0aW9ucyBvbi5cclxuICAgICAqL1xyXG4gICAgcXVldWUsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgSUQgdG8gdXNlIHdoZW4gc2NoZWR1bGluZyBiYWNrb2ZmIG9wZXJhdGlvbnMgb24gdGhlIEFzeW5jUXVldWUuXHJcbiAgICAgKi9cclxuICAgIHRpbWVySWQsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5pdGlhbCBkZWxheSAodXNlZCBhcyB0aGUgYmFzZSBkZWxheSBvbiB0aGUgZmlyc3QgcmV0cnkgYXR0ZW1wdCkuXHJcbiAgICAgKiBOb3RlIHRoYXQgaml0dGVyIHdpbGwgc3RpbGwgYmUgYXBwbGllZCwgc28gdGhlIGFjdHVhbCBkZWxheSBjb3VsZCBiZSBhc1xyXG4gICAgICogbGl0dGxlIGFzIDAuNSppbml0aWFsRGVsYXlNcy5cclxuICAgICAqL1xyXG4gICAgaW5pdGlhbERlbGF5TXMgPSBERUZBVUxUX0JBQ0tPRkZfSU5JVElBTF9ERUxBWV9NUywgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtdWx0aXBsaWVyIHRvIHVzZSB0byBkZXRlcm1pbmUgdGhlIGV4dGVuZGVkIGJhc2UgZGVsYXkgYWZ0ZXIgZWFjaFxyXG4gICAgICogYXR0ZW1wdC5cclxuICAgICAqL1xyXG4gICAgYmFja29mZkZhY3RvciA9IERFRkFVTFRfQkFDS09GRl9GQUNUT1IsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF4aW11bSBiYXNlIGRlbGF5IGFmdGVyIHdoaWNoIG5vIGZ1cnRoZXIgYmFja29mZiBpcyBwZXJmb3JtZWQuXHJcbiAgICAgKiBOb3RlIHRoYXQgaml0dGVyIHdpbGwgc3RpbGwgYmUgYXBwbGllZCwgc28gdGhlIGFjdHVhbCBkZWxheSBjb3VsZCBiZSBhc1xyXG4gICAgICogbXVjaCBhcyAxLjUqbWF4RGVsYXlNcy5cclxuICAgICAqL1xyXG4gICAgbWF4RGVsYXlNcyA9IERFRkFVTFRfQkFDS09GRl9NQVhfREVMQVlfTVMpIHtcclxuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XHJcbiAgICAgICAgdGhpcy50aW1lcklkID0gdGltZXJJZDtcclxuICAgICAgICB0aGlzLmluaXRpYWxEZWxheU1zID0gaW5pdGlhbERlbGF5TXM7XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmRmFjdG9yID0gYmFja29mZkZhY3RvcjtcclxuICAgICAgICB0aGlzLm1heERlbGF5TXMgPSBtYXhEZWxheU1zO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyA9IDA7XHJcbiAgICAgICAgdGhpcy50aW1lclByb21pc2UgPSBudWxsO1xyXG4gICAgICAgIC8qKiBUaGUgbGFzdCBiYWNrb2ZmIGF0dGVtcHQsIGFzIGVwb2NoIG1pbGxpc2Vjb25kcy4gKi9cclxuICAgICAgICB0aGlzLmxhc3RBdHRlbXB0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGJhY2tvZmYgZGVsYXkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHZlcnkgbmV4dCBiYWNrb2ZmQW5kV2FpdCgpIHdpbGwgaGF2ZSBubyBkZWxheS4gSWYgaXQgaXMgY2FsbGVkIGFnYWluXHJcbiAgICAgKiAoaS5lLiBkdWUgdG8gYW4gZXJyb3IpLCBpbml0aWFsRGVsYXlNcyAocGx1cyBqaXR0ZXIpIHdpbGwgYmUgdXNlZCwgYW5kXHJcbiAgICAgKiBzdWJzZXF1ZW50IG9uZXMgd2lsbCBpbmNyZWFzZSBhY2NvcmRpbmcgdG8gdGhlIGJhY2tvZmZGYWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgYmFja29mZiBkZWxheSB0byB0aGUgbWF4aW11bSBkZWxheSAoZS5nLiBmb3IgdXNlIGFmdGVyIGFcclxuICAgICAqIFJFU09VUkNFX0VYSEFVU1RFRCBlcnJvcikuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0VG9NYXgoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QmFzZU1zID0gdGhpcy5tYXhEZWxheU1zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIGN1cnJlbnREZWxheU1zLCBhbmQgaW5jcmVhc2VzIHRoZVxyXG4gICAgICogZGVsYXkgZm9yIGFueSBzdWJzZXF1ZW50IGF0dGVtcHRzLiBJZiB0aGVyZSB3YXMgYSBwZW5kaW5nIGJhY2tvZmYgb3BlcmF0aW9uXHJcbiAgICAgKiBhbHJlYWR5LCBpdCB3aWxsIGJlIGNhbmNlbGVkLlxyXG4gICAgICovXHJcbiAgICBiYWNrb2ZmQW5kUnVuKG9wKSB7XHJcbiAgICAgICAgLy8gQ2FuY2VsIGFueSBwZW5kaW5nIGJhY2tvZmYgb3BlcmF0aW9uLlxyXG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XHJcbiAgICAgICAgLy8gRmlyc3Qgc2NoZWR1bGUgdXNpbmcgdGhlIGN1cnJlbnQgYmFzZSAod2hpY2ggbWF5IGJlIDAgYW5kIHNob3VsZCBiZVxyXG4gICAgICAgIC8vIGhvbm9yZWQgYXMgc3VjaCkuXHJcbiAgICAgICAgY29uc3QgZGVzaXJlZERlbGF5V2l0aEppdHRlck1zID0gTWF0aC5mbG9vcih0aGlzLmN1cnJlbnRCYXNlTXMgKyB0aGlzLmppdHRlckRlbGF5TXMoKSk7XHJcbiAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCBsYXN0QXR0ZW1wdFRpbWUgYmVpbmcgaW4gdGhlIGZ1dHVyZSBkdWUgdG8gYSBjbG9jayBjaGFuZ2UuXHJcbiAgICAgICAgY29uc3QgZGVsYXlTb0Zhck1zID0gTWF0aC5tYXgoMCwgRGF0ZS5ub3coKSAtIHRoaXMubGFzdEF0dGVtcHRUaW1lKTtcclxuICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSBiYWNrb2ZmIGRlbGF5IGFscmVhZHkgYmVpbmcgcGFzdC5cclxuICAgICAgICBjb25zdCByZW1haW5pbmdEZWxheU1zID0gTWF0aC5tYXgoMCwgZGVzaXJlZERlbGF5V2l0aEppdHRlck1zIC0gZGVsYXlTb0Zhck1zKTtcclxuICAgICAgICBpZiAocmVtYWluaW5nRGVsYXlNcyA+IDApIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQyLCBgQmFja2luZyBvZmYgZm9yICR7cmVtYWluaW5nRGVsYXlNc30gbXMgYCArXHJcbiAgICAgICAgICAgICAgICBgKGJhc2UgZGVsYXk6ICR7dGhpcy5jdXJyZW50QmFzZU1zfSBtcywgYCArXHJcbiAgICAgICAgICAgICAgICBgZGVsYXkgd2l0aCBqaXR0ZXI6ICR7ZGVzaXJlZERlbGF5V2l0aEppdHRlck1zfSBtcywgYCArXHJcbiAgICAgICAgICAgICAgICBgbGFzdCBhdHRlbXB0OiAke2RlbGF5U29GYXJNc30gbXMgYWdvKWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZSA9IHRoaXMucXVldWUuZW5xdWV1ZUFmdGVyRGVsYXkodGhpcy50aW1lcklkLCByZW1haW5pbmdEZWxheU1zLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEF0dGVtcHRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgcmV0dXJuIG9wKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gQXBwbHkgYmFja29mZiBmYWN0b3IgdG8gZGV0ZXJtaW5lIG5leHQgZGVsYXkgYW5kIGVuc3VyZSBpdCBpcyB3aXRoaW5cclxuICAgICAgICAvLyBib3VuZHMuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50QmFzZU1zICo9IHRoaXMuYmFja29mZkZhY3RvcjtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QmFzZU1zIDwgdGhpcy5pbml0aWFsRGVsYXlNcykge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRCYXNlTXMgPSB0aGlzLmluaXRpYWxEZWxheU1zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QmFzZU1zID4gdGhpcy5tYXhEZWxheU1zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyA9IHRoaXMubWF4RGVsYXlNcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBza2lwQmFja29mZigpIHtcclxuICAgICAgICBpZiAodGhpcy50aW1lclByb21pc2UgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lclByb21pc2Uuc2tpcERlbGF5KCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXJQcm9taXNlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZXJQcm9taXNlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXJQcm9taXNlLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYSByYW5kb20gdmFsdWUgaW4gdGhlIHJhbmdlIFstY3VycmVudEJhc2VNcy8yLCBjdXJyZW50QmFzZU1zLzJdICovXHJcbiAgICBqaXR0ZXJEZWxheU1zKCkge1xyXG4gICAgICAgIHJldHVybiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiB0aGlzLmN1cnJlbnRCYXNlTXM7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIERhdGFzdG9yZSBhbmQgaXRzIHJlbGF0ZWQgbWV0aG9kcyBhcmUgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZXh0ZXJuYWwgR29vZ2xlXHJcbiAqIENsb3VkIERhdGFzdG9yZSBncnBjIEFQSSwgd2hpY2ggcHJvdmlkZXMgYW4gaW50ZXJmYWNlIHRoYXQgaXMgbW9yZSBjb252ZW5pZW50XHJcbiAqIGZvciB0aGUgcmVzdCBvZiB0aGUgY2xpZW50IFNESyBhcmNoaXRlY3R1cmUgdG8gY29uc3VtZS5cclxuICovXHJcbmNsYXNzIERhdGFzdG9yZSB7XHJcbn1cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIERhdGFzdG9yZSB0aGF0IGV4cG9zZXMgYWRkaXRpb25hbCBzdGF0ZSBmb3IgaW50ZXJuYWxcclxuICogY29uc3VtcHRpb24uXHJcbiAqL1xyXG5jbGFzcyBEYXRhc3RvcmVJbXBsIGV4dGVuZHMgRGF0YXN0b3JlIHtcclxuICAgIGNvbnN0cnVjdG9yKGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMgPSBhdXRoQ3JlZGVudGlhbHM7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzID0gYXBwQ2hlY2tDcmVkZW50aWFscztcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XHJcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2ZXJpZnlJbml0aWFsaXplZCgpIHtcclxuICAgICAgICBpZiAodGhpcy50ZXJtaW5hdGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdUaGUgY2xpZW50IGhhcyBhbHJlYWR5IGJlZW4gdGVybWluYXRlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogSW52b2tlcyB0aGUgcHJvdmlkZWQgUlBDIHdpdGggYXV0aCBhbmQgQXBwQ2hlY2sgdG9rZW5zLiAqL1xyXG4gICAgaW52b2tlUlBDKHJwY05hbWUsIGRhdGFiYXNlSWQsIHJlc291cmNlUGF0aCwgcmVxdWVzdCkge1xyXG4gICAgICAgIHRoaXMudmVyaWZ5SW5pdGlhbGl6ZWQoKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscy5nZXRUb2tlbigpLFxyXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuZ2V0VG9rZW4oKVxyXG4gICAgICAgIF0pXHJcbiAgICAgICAgICAgIC50aGVuKChbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmludm9rZVJQQyhycGNOYW1lLCB0b1Jlc291cmNlUGF0aChkYXRhYmFzZUlkLCByZXNvdXJjZVBhdGgpLCByZXF1ZXN0LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdGaXJlYmFzZUVycm9yJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IENvZGUuVU5BVVRIRU5USUNBVEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuaW52YWxpZGF0ZVRva2VuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmludmFsaWRhdGVUb2tlbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTktOT1dOLCBlcnJvci50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEludm9rZXMgdGhlIHByb3ZpZGVkIFJQQyB3aXRoIHN0cmVhbWVkIHJlc3VsdHMgd2l0aCBhdXRoIGFuZCBBcHBDaGVjayB0b2tlbnMuICovXHJcbiAgICBpbnZva2VTdHJlYW1pbmdSUEMocnBjTmFtZSwgZGF0YWJhc2VJZCwgcmVzb3VyY2VQYXRoLCByZXF1ZXN0LCBleHBlY3RlZFJlc3BvbnNlQ291bnQpIHtcclxuICAgICAgICB0aGlzLnZlcmlmeUluaXRpYWxpemVkKCk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuZ2V0VG9rZW4oKSxcclxuICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmdldFRva2VuKClcclxuICAgICAgICBdKVxyXG4gICAgICAgICAgICAudGhlbigoW2F1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbl0pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5pbnZva2VTdHJlYW1pbmdSUEMocnBjTmFtZSwgdG9SZXNvdXJjZVBhdGgoZGF0YWJhc2VJZCwgcmVzb3VyY2VQYXRoKSwgcmVxdWVzdCwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuLCBleHBlY3RlZFJlc3BvbnNlQ291bnQpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdGaXJlYmFzZUVycm9yJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IENvZGUuVU5BVVRIRU5USUNBVEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuaW52YWxpZGF0ZVRva2VuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmludmFsaWRhdGVUb2tlbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTktOT1dOLCBlcnJvci50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdGVybWluYXRlKCkge1xyXG4gICAgICAgIHRoaXMudGVybWluYXRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnRlcm1pbmF0ZSgpO1xyXG4gICAgfVxyXG59XHJcbi8vIFRPRE8oZmlyZXN0b3JleHApOiBNYWtlIHN1cmUgdGhlcmUgaXMgb25seSBvbmUgRGF0YXN0b3JlIGluc3RhbmNlIHBlclxyXG4vLyBmaXJlc3RvcmUtZXhwIGNsaWVudC5cclxuZnVuY3Rpb24gbmV3RGF0YXN0b3JlKGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcikge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRhc3RvcmVJbXBsKGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcik7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaW52b2tlQ29tbWl0UnBjKGRhdGFzdG9yZSwgbXV0YXRpb25zKSB7XHJcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XHJcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgIHdyaXRlczogbXV0YXRpb25zLm1hcChtID0+IHRvTXV0YXRpb24oZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBtKSlcclxuICAgIH07XHJcbiAgICBhd2FpdCBkYXRhc3RvcmVJbXBsLmludm9rZVJQQygnQ29tbWl0JywgZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLmRhdGFiYXNlSWQsIFJlc291cmNlUGF0aC5lbXB0eVBhdGgoKSwgcmVxdWVzdCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaW52b2tlQmF0Y2hHZXREb2N1bWVudHNScGMoZGF0YXN0b3JlLCBrZXlzKSB7XHJcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XHJcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgIGRvY3VtZW50czoga2V5cy5tYXAoayA9PiB0b05hbWUoZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBrKSlcclxuICAgIH07XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRhdGFzdG9yZUltcGwuaW52b2tlU3RyZWFtaW5nUlBDKCdCYXRjaEdldERvY3VtZW50cycsIGRhdGFzdG9yZUltcGwuc2VyaWFsaXplci5kYXRhYmFzZUlkLCBSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCksIHJlcXVlc3QsIGtleXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IGRvY3MgPSBuZXcgTWFwKCk7XHJcbiAgICByZXNwb25zZS5mb3JFYWNoKHByb3RvID0+IHtcclxuICAgICAgICBjb25zdCBkb2MgPSBmcm9tQmF0Y2hHZXREb2N1bWVudHNSZXNwb25zZShkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIsIHByb3RvKTtcclxuICAgICAgICBkb2NzLnNldChkb2Mua2V5LnRvU3RyaW5nKCksIGRvYyk7XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgY29uc3QgZG9jID0gZG9jcy5nZXQoa2V5LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIGhhcmRBc3NlcnQoISFkb2MpO1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKGRvYyk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaW52b2tlUnVuUXVlcnlScGMoZGF0YXN0b3JlLCBxdWVyeSkge1xyXG4gICAgY29uc3QgZGF0YXN0b3JlSW1wbCA9IGRlYnVnQ2FzdChkYXRhc3RvcmUpO1xyXG4gICAgY29uc3QgeyBxdWVyeVRhcmdldCwgcGFyZW50IH0gPSB0b1F1ZXJ5VGFyZ2V0KGRhdGFzdG9yZUltcGwuc2VyaWFsaXplciwgcXVlcnlUb1RhcmdldChxdWVyeSkpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkYXRhc3RvcmVJbXBsLmludm9rZVN0cmVhbWluZ1JQQygnUnVuUXVlcnknLCBkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIuZGF0YWJhc2VJZCwgcGFyZW50LCB7XHJcbiAgICAgICAgc3RydWN0dXJlZFF1ZXJ5OiBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnlcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIChyZXNwb25zZVxyXG4gICAgICAgIC8vIE9taXQgUnVuUXVlcnlSZXNwb25zZXMgdGhhdCBvbmx5IGNvbnRhaW4gcmVhZFRpbWVzLlxyXG4gICAgICAgIC5maWx0ZXIocHJvdG8gPT4gISFwcm90by5kb2N1bWVudClcclxuICAgICAgICAubWFwKHByb3RvID0+IGZyb21Eb2N1bWVudChkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIsIHByb3RvLmRvY3VtZW50LCB1bmRlZmluZWQpKSk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaW52b2tlUnVuQWdncmVnYXRpb25RdWVyeVJwYyhkYXRhc3RvcmUsIHF1ZXJ5LCBhZ2dyZWdhdGVzKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XHJcbiAgICBjb25zdCB7IHJlcXVlc3QsIGFsaWFzTWFwLCBwYXJlbnQgfSA9IHRvUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3QoZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBxdWVyeVRvQWdncmVnYXRlVGFyZ2V0KHF1ZXJ5KSwgYWdncmVnYXRlcyk7XHJcbiAgICBpZiAoIWRhdGFzdG9yZUltcGwuY29ubmVjdGlvbi5zaG91bGRSZXNvdXJjZVBhdGhCZUluY2x1ZGVkSW5SZXF1ZXN0KSB7XHJcbiAgICAgICAgZGVsZXRlIHJlcXVlc3QucGFyZW50O1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkYXRhc3RvcmVJbXBsLmludm9rZVN0cmVhbWluZ1JQQygnUnVuQWdncmVnYXRpb25RdWVyeScsIGRhdGFzdG9yZUltcGwuc2VyaWFsaXplci5kYXRhYmFzZUlkLCBwYXJlbnQsIHJlcXVlc3QsIFxyXG4gICAgLypleHBlY3RlZFJlc3BvbnNlQ291bnQ9Ki8gMSk7XHJcbiAgICAvLyBPbWl0IFJ1bkFnZ3JlZ2F0aW9uUXVlcnlSZXNwb25zZSB0aGF0IG9ubHkgY29udGFpbiByZWFkVGltZXMuXHJcbiAgICBjb25zdCBmaWx0ZXJlZFJlc3VsdCA9IHJlc3BvbnNlLmZpbHRlcihwcm90byA9PiAhIXByb3RvLnJlc3VsdCk7XHJcbiAgICBoYXJkQXNzZXJ0KGZpbHRlcmVkUmVzdWx0Lmxlbmd0aCA9PT0gMSk7XHJcbiAgICAvLyBSZW1hcCB0aGUgc2hvcnQtZm9ybSBhbGlhc2VzIHRoYXQgd2VyZSBzZW50IHRvIHRoZSBzZXJ2ZXJcclxuICAgIC8vIHRvIHRoZSBjbGllbnQtc2lkZSBhbGlhc2VzLiBVc2VycyB3aWxsIGFjY2VzcyB0aGUgcmVzdWx0c1xyXG4gICAgLy8gdXNpbmcgdGhlIGNsaWVudC1zaWRlIGFsaWFzLlxyXG4gICAgY29uc3QgdW5tYXBwZWRBZ2dyZWdhdGVGaWVsZHMgPSAoX2EgPSBmaWx0ZXJlZFJlc3VsdFswXS5yZXN1bHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZ2dyZWdhdGVGaWVsZHM7XHJcbiAgICBjb25zdCByZW1hcHBlZEZpZWxkcyA9IE9iamVjdC5rZXlzKHVubWFwcGVkQWdncmVnYXRlRmllbGRzKS5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBrZXkpID0+IHtcclxuICAgICAgICBhY2N1bXVsYXRvclthbGlhc01hcFtrZXldXSA9IHVubWFwcGVkQWdncmVnYXRlRmllbGRzW2tleV07XHJcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xyXG4gICAgfSwge30pO1xyXG4gICAgcmV0dXJuIHJlbWFwcGVkRmllbGRzO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckMSA9ICdDb21wb25lbnRQcm92aWRlcic7XHJcbi8qKlxyXG4gKiBBbiBpbnN0YW5jZSBtYXAgdGhhdCBlbnN1cmVzIG9ubHkgb25lIERhdGFzdG9yZSBleGlzdHMgcGVyIEZpcmVzdG9yZVxyXG4gKiBpbnN0YW5jZS5cclxuICovXHJcbmNvbnN0IGRhdGFzdG9yZUluc3RhbmNlcyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIFJldHVybnMgYW4gaW5pdGlhbGl6ZWQgYW5kIHN0YXJ0ZWQgRGF0YXN0b3JlIGZvciB0aGUgZ2l2ZW4gRmlyZXN0b3JlXHJcbiAqIGluc3RhbmNlLiBDYWxsZXJzIG11c3QgaW52b2tlIHJlbW92ZUNvbXBvbmVudHMoKSB3aGVuIHRoZSBGaXJlc3RvcmVcclxuICogaW5zdGFuY2UgaXMgdGVybWluYXRlZC5cclxuICovXHJcbmZ1bmN0aW9uIGdldERhdGFzdG9yZShmaXJlc3RvcmUpIHtcclxuICAgIGlmIChmaXJlc3RvcmUuX3Rlcm1pbmF0ZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnVGhlIGNsaWVudCBoYXMgYWxyZWFkeSBiZWVuIHRlcm1pbmF0ZWQuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWRhdGFzdG9yZUluc3RhbmNlcy5oYXMoZmlyZXN0b3JlKSkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMSwgJ0luaXRpYWxpemluZyBEYXRhc3RvcmUnKTtcclxuICAgICAgICBjb25zdCBkYXRhYmFzZUluZm8gPSBtYWtlRGF0YWJhc2VJbmZvKGZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgZmlyZXN0b3JlLmFwcC5vcHRpb25zLmFwcElkIHx8ICcnLCBmaXJlc3RvcmUuX3BlcnNpc3RlbmNlS2V5LCBmaXJlc3RvcmUuX2ZyZWV6ZVNldHRpbmdzKCkpO1xyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXdDb25uZWN0aW9uKGRhdGFiYXNlSW5mbyk7XHJcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplciA9IG5ld1NlcmlhbGl6ZXIoZmlyZXN0b3JlLl9kYXRhYmFzZUlkKTtcclxuICAgICAgICBjb25zdCBkYXRhc3RvcmUgPSBuZXdEYXRhc3RvcmUoZmlyZXN0b3JlLl9hdXRoQ3JlZGVudGlhbHMsIGZpcmVzdG9yZS5fYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcik7XHJcbiAgICAgICAgZGF0YXN0b3JlSW5zdGFuY2VzLnNldChmaXJlc3RvcmUsIGRhdGFzdG9yZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YXN0b3JlSW5zdGFuY2VzLmdldChmaXJlc3RvcmUpO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFsbCBjb21wb25lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgaW5zdGFuY2UuIE11c3QgYmUgY2FsbGVkXHJcbiAqIHdoZW4gdGhlIGBGaXJlc3RvcmVgIGluc3RhbmNlIGlzIHRlcm1pbmF0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmVDb21wb25lbnRzKGZpcmVzdG9yZSkge1xyXG4gICAgY29uc3QgZGF0YXN0b3JlID0gZGF0YXN0b3JlSW5zdGFuY2VzLmdldChmaXJlc3RvcmUpO1xyXG4gICAgaWYgKGRhdGFzdG9yZSkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMSwgJ1JlbW92aW5nIERhdGFzdG9yZScpO1xyXG4gICAgICAgIGRhdGFzdG9yZUluc3RhbmNlcy5kZWxldGUoZmlyZXN0b3JlKTtcclxuICAgICAgICBkYXRhc3RvcmUudGVybWluYXRlKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbWFrZURhdGFiYXNlSW5mbyhkYXRhYmFzZUlkLCBhcHBJZCwgcGVyc2lzdGVuY2VLZXksIHNldHRpbmdzKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGFiYXNlSW5mbyhkYXRhYmFzZUlkLCBhcHBJZCwgcGVyc2lzdGVuY2VLZXksIHNldHRpbmdzLmhvc3QsIHNldHRpbmdzLnNzbCwgc2V0dGluZ3MuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZywgc2V0dGluZ3MuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nLCBjbG9uZUxvbmdQb2xsaW5nT3B0aW9ucyhzZXR0aW5ncy5leHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMpLCBzZXR0aW5ncy51c2VGZXRjaFN0cmVhbXMpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExSVV9DT0xMRUNUSU9OX0RJU0FCTEVEID0gLTE7XHJcbmNvbnN0IExSVV9ERUZBVUxUX0NBQ0hFX1NJWkVfQllURVMgPSA0MCAqIDEwMjQgKiAxMDI0O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogVmVyaWZpZXMgd2hldGhlciBgZWAgaXMgYW4gSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvci4gKi9cclxuZnVuY3Rpb24gaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpIHtcclxuICAgIC8vIFVzZSBuYW1lIGVxdWFsaXR5LCBhcyBpbnN0YW5jZW9mIGNoZWNrcyBvbiBlcnJvcnMgZG9uJ3Qgd29yayB3aXRoIGVycm9yc1xyXG4gICAgLy8gdGhhdCB3cmFwIG90aGVyIGVycm9ycy5cclxuICAgIHJldHVybiBlLm5hbWUgPT09ICdJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yJztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBMUlVfTUlOSU1VTV9DQUNIRV9TSVpFX0JZVEVTID0gMSAqIDEwMjQgKiAxMDI0O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBzZXR0aW5ncygpIGRlZmF1bHRzOlxyXG5jb25zdCBERUZBVUxUX0hPU1QgPSAnZmlyZXN0b3JlLmdvb2dsZWFwaXMuY29tJztcclxuY29uc3QgREVGQVVMVF9TU0wgPSB0cnVlO1xyXG4vLyBUaGUgbWluaW11bSBsb25nLXBvbGxpbmcgdGltZW91dCBpcyBoYXJkY29kZWQgb24gdGhlIHNlcnZlci4gVGhlIHZhbHVlIGhlcmVcclxuLy8gc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSB2YWx1ZSB1c2VkIGJ5IHRoZSBzZXJ2ZXIsIGFzIHRoZSBzZXJ2ZXIgd2lsbFxyXG4vLyBzaWxlbnRseSBpZ25vcmUgYSB2YWx1ZSBiZWxvdyB0aGUgbWluaW11bSBhbmQgZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0LlxyXG4vLyBHb29nbGVycyBzZWUgYi8yNjY4Njg4NzEgZm9yIHJlbGV2YW50IGRpc2N1c3Npb24uXHJcbmNvbnN0IE1JTl9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTID0gNTtcclxuLy8gTm8gbWF4aW11bSBsb25nLXBvbGxpbmcgdGltZW91dCBpcyBjb25maWd1cmVkIGluIHRoZSBzZXJ2ZXIsIGFuZCBkZWZhdWx0cyB0b1xyXG4vLyAzMCBzZWNvbmRzLCB3aGljaCBpcyB3aGF0IFdhdGNoIGFwcGVhcnMgdG8gdXNlLlxyXG4vLyBHb29nbGVycyBzZWUgYi8yNjY4Njg4NzEgZm9yIHJlbGV2YW50IGRpc2N1c3Npb24uXHJcbmNvbnN0IE1BWF9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTID0gMzA7XHJcbi8vIFdoZXRoZXIgbG9uZy1wb2xsaW5nIGF1dG8tZGV0ZWN0ZWQgaXMgZW5hYmxlZCBieSBkZWZhdWx0LlxyXG5jb25zdCBERUZBVUxUX0FVVE9fREVURUNUX0xPTkdfUE9MTElORyA9IHRydWU7XHJcbi8qKlxyXG4gKiBBIGNvbmNyZXRlIHR5cGUgZGVzY3JpYmluZyBhbGwgdGhlIHZhbHVlcyB0aGF0IGNhbiBiZSBhcHBsaWVkIHZpYSBhXHJcbiAqIHVzZXItc3VwcGxpZWQgYEZpcmVzdG9yZVNldHRpbmdzYCBvYmplY3QuIFRoaXMgaXMgYSBzZXBhcmF0ZSB0eXBlIHNvIHRoYXRcclxuICogZGVmYXVsdHMgY2FuIGJlIHN1cHBsaWVkIGFuZCB0aGUgdmFsdWUgY2FuIGJlIGNoZWNrZWQgZm9yIGVxdWFsaXR5LlxyXG4gKi9cclxuY2xhc3MgRmlyZXN0b3JlU2V0dGluZ3NJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBpZiAoc2V0dGluZ3MuaG9zdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zc2wgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgXCJDYW4ndCBwcm92aWRlIHNzbCBvcHRpb24gaWYgaG9zdCBvcHRpb24gaXMgbm90IHNldFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmhvc3QgPSBERUZBVUxUX0hPU1Q7XHJcbiAgICAgICAgICAgIHRoaXMuc3NsID0gREVGQVVMVF9TU0w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmhvc3QgPSBzZXR0aW5ncy5ob3N0O1xyXG4gICAgICAgICAgICB0aGlzLnNzbCA9IChfYSA9IHNldHRpbmdzLnNzbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogREVGQVVMVF9TU0w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBzZXR0aW5ncy5jcmVkZW50aWFscztcclxuICAgICAgICB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgPSAhIXNldHRpbmdzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXM7XHJcbiAgICAgICAgdGhpcy5sb2NhbENhY2hlID0gc2V0dGluZ3MubG9jYWxDYWNoZTtcclxuICAgICAgICBpZiAoc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlU2l6ZUJ5dGVzID0gTFJVX0RFRkFVTFRfQ0FDSEVfU0laRV9CWVRFUztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyAhPT0gTFJVX0NPTExFQ1RJT05fRElTQUJMRUQgJiZcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzIDwgTFJVX01JTklNVU1fQ0FDSEVfU0laRV9CWVRFUykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYGNhY2hlU2l6ZUJ5dGVzIG11c3QgYmUgYXQgbGVhc3QgJHtMUlVfTUlOSU1VTV9DQUNIRV9TSVpFX0JZVEVTfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZVNpemVCeXRlcyA9IHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbGlkYXRlSXNOb3RVc2VkVG9nZXRoZXIoJ2V4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmcnLCBzZXR0aW5ncy5leHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nLCAnZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nJywgc2V0dGluZ3MuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nKTtcclxuICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmcgPSAhIXNldHRpbmdzLmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmc7XHJcbiAgICAgICAgaWYgKHRoaXMuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzZXR0aW5ncy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyA9IERFRkFVTFRfQVVUT19ERVRFQ1RfTE9OR19QT0xMSU5HO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBjb2VyY2UgdGhlIHZhbHVlIHRvIGJvb2xlYW4gZXZlbiB0aG91Z2hcclxuICAgICAgICAgICAgLy8gdGhlIFR5cGVTY3JpcHQgY29tcGlsZXIgaGFzIG5hcnJvd2VkIHRoZSB0eXBlIHRvIGJvb2xlYW4gYWxyZWFkeS5cclxuICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFBvaW50bGVzc0Jvb2xlYW5FeHByZXNzaW9uSlNcclxuICAgICAgICAgICAgdGhpcy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPVxyXG4gICAgICAgICAgICAgICAgISFzZXR0aW5ncy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZXhwZXJpbWVudGFsTG9uZ1BvbGxpbmdPcHRpb25zID0gY2xvbmVMb25nUG9sbGluZ09wdGlvbnMoKF9iID0gc2V0dGluZ3MuZXhwZXJpbWVudGFsTG9uZ1BvbGxpbmdPcHRpb25zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSk7XHJcbiAgICAgICAgdmFsaWRhdGVMb25nUG9sbGluZ09wdGlvbnModGhpcy5leHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMudXNlRmV0Y2hTdHJlYW1zID0gISFzZXR0aW5ncy51c2VGZXRjaFN0cmVhbXM7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmhvc3QgPT09IG90aGVyLmhvc3QgJiZcclxuICAgICAgICAgICAgdGhpcy5zc2wgPT09IG90aGVyLnNzbCAmJlxyXG4gICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID09PSBvdGhlci5jcmVkZW50aWFscyAmJlxyXG4gICAgICAgICAgICB0aGlzLmNhY2hlU2l6ZUJ5dGVzID09PSBvdGhlci5jYWNoZVNpemVCeXRlcyAmJlxyXG4gICAgICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmcgPT09XHJcbiAgICAgICAgICAgICAgICBvdGhlci5leHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nICYmXHJcbiAgICAgICAgICAgIHRoaXMuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nID09PVxyXG4gICAgICAgICAgICAgICAgb3RoZXIuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nICYmXHJcbiAgICAgICAgICAgIGxvbmdQb2xsaW5nT3B0aW9uc0VxdWFsKHRoaXMuZXhwZXJpbWVudGFsTG9uZ1BvbGxpbmdPcHRpb25zLCBvdGhlci5leHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMpICYmXHJcbiAgICAgICAgICAgIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyA9PT0gb3RoZXIuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyAmJlxyXG4gICAgICAgICAgICB0aGlzLnVzZUZldGNoU3RyZWFtcyA9PT0gb3RoZXIudXNlRmV0Y2hTdHJlYW1zKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZUxvbmdQb2xsaW5nT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucy50aW1lb3V0U2Vjb25kcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKGlzTmFOKG9wdGlvbnMudGltZW91dFNlY29uZHMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBpbnZhbGlkIGxvbmcgcG9sbGluZyB0aW1lb3V0OiBgICtcclxuICAgICAgICAgICAgICAgIGAke29wdGlvbnMudGltZW91dFNlY29uZHN9IChtdXN0IG5vdCBiZSBOYU4pYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXRTZWNvbmRzIDwgTUlOX0xPTkdfUE9MTElOR19USU1FT1VUX1NFQ09ORFMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYGludmFsaWQgbG9uZyBwb2xsaW5nIHRpbWVvdXQ6ICR7b3B0aW9ucy50aW1lb3V0U2Vjb25kc30gYCArXHJcbiAgICAgICAgICAgICAgICBgKG1pbmltdW0gYWxsb3dlZCB2YWx1ZSBpcyAke01JTl9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTfSlgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dFNlY29uZHMgPiBNQVhfTE9OR19QT0xMSU5HX1RJTUVPVVRfU0VDT05EUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgaW52YWxpZCBsb25nIHBvbGxpbmcgdGltZW91dDogJHtvcHRpb25zLnRpbWVvdXRTZWNvbmRzfSBgICtcclxuICAgICAgICAgICAgICAgIGAobWF4aW11bSBhbGxvd2VkIHZhbHVlIGlzICR7TUFYX0xPTkdfUE9MTElOR19USU1FT1VUX1NFQ09ORFN9KWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIENsb3VkIEZpcmVzdG9yZSBzZXJ2aWNlIGludGVyZmFjZS5cclxuICpcclxuICogRG8gbm90IGNhbGwgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gSW5zdGVhZCwgdXNlIHtAbGluayAoZ2V0RmlyZXN0b3JlOjEpfS5cclxuICovXHJcbmNsYXNzIEZpcmVzdG9yZSB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoX2F1dGhDcmVkZW50aWFscywgX2FwcENoZWNrQ3JlZGVudGlhbHMsIF9kYXRhYmFzZUlkLCBfYXBwKSB7XHJcbiAgICAgICAgdGhpcy5fYXV0aENyZWRlbnRpYWxzID0gX2F1dGhDcmVkZW50aWFscztcclxuICAgICAgICB0aGlzLl9hcHBDaGVja0NyZWRlbnRpYWxzID0gX2FwcENoZWNrQ3JlZGVudGlhbHM7XHJcbiAgICAgICAgdGhpcy5fZGF0YWJhc2VJZCA9IF9kYXRhYmFzZUlkO1xyXG4gICAgICAgIHRoaXMuX2FwcCA9IF9hcHA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBpdCdzIGEgRmlyZXN0b3JlIG9yIEZpcmVzdG9yZSBMaXRlIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdmaXJlc3RvcmUtbGl0ZSc7XHJcbiAgICAgICAgdGhpcy5fcGVyc2lzdGVuY2VLZXkgPSAnKGxpdGUpJztcclxuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IG5ldyBGaXJlc3RvcmVTZXR0aW5nc0ltcGwoe30pO1xyXG4gICAgICAgIHRoaXMuX3NldHRpbmdzRnJvemVuID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgYEZpcmVzdG9yZWAgc2VydmljZVxyXG4gICAgICogaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGdldCBhcHAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9hcHApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgXCJGaXJlc3RvcmUgd2FzIG5vdCBpbml0aWFsaXplZCB1c2luZyB0aGUgRmlyZWJhc2UgU0RLLiAnYXBwJyBpcyBcIiArXHJcbiAgICAgICAgICAgICAgICAnbm90IGF2YWlsYWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fYXBwO1xyXG4gICAgfVxyXG4gICAgZ2V0IF9pbml0aWFsaXplZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3NGcm96ZW47XHJcbiAgICB9XHJcbiAgICBnZXQgX3Rlcm1pbmF0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlcm1pbmF0ZVRhc2sgIT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIF9zZXRTZXR0aW5ncyhzZXR0aW5ncykge1xyXG4gICAgICAgIGlmICh0aGlzLl9zZXR0aW5nc0Zyb3plbikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnRmlyZXN0b3JlIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCBhbmQgaXRzIHNldHRpbmdzIGNhbiBubyBsb25nZXIgJyArXHJcbiAgICAgICAgICAgICAgICAnYmUgY2hhbmdlZC4gWW91IGNhbiBvbmx5IG1vZGlmeSBzZXR0aW5ncyBiZWZvcmUgY2FsbGluZyBhbnkgb3RoZXIgJyArXHJcbiAgICAgICAgICAgICAgICAnbWV0aG9kcyBvbiBhIEZpcmVzdG9yZSBvYmplY3QuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NldHRpbmdzID0gbmV3IEZpcmVzdG9yZVNldHRpbmdzSW1wbChzZXR0aW5ncyk7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmNyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXV0aENyZWRlbnRpYWxzID0gbWFrZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKHNldHRpbmdzLmNyZWRlbnRpYWxzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZ2V0U2V0dGluZ3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzO1xyXG4gICAgfVxyXG4gICAgX2ZyZWV6ZVNldHRpbmdzKCkge1xyXG4gICAgICAgIHRoaXMuX3NldHRpbmdzRnJvemVuID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3M7XHJcbiAgICB9XHJcbiAgICBfZGVsZXRlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fdGVybWluYXRlVGFzaykge1xyXG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hdGVUYXNrID0gdGhpcy5fdGVybWluYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXJtaW5hdGVUYXNrO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGBGaXJlc3RvcmVgIGluc3RhbmNlLiAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGFwcDogdGhpcy5fYXBwLFxyXG4gICAgICAgICAgICBkYXRhYmFzZUlkOiB0aGlzLl9kYXRhYmFzZUlkLFxyXG4gICAgICAgICAgICBzZXR0aW5nczogdGhpcy5fc2V0dGluZ3NcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXJtaW5hdGVzIGFsbCBjb21wb25lbnRzIHVzZWQgYnkgdGhpcyBjbGllbnQuIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlXHJcbiAgICAgKiB0aGlzIG1ldGhvZCB0byBjbGVhbiB1cCB0aGVpciBvd24gZGVwZW5kZW5jaWVzLCBidXQgbXVzdCBhbHNvIGNhbGwgdGhpc1xyXG4gICAgICogbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqIE9ubHkgZXZlciBjYWxsZWQgb25jZS5cclxuICAgICAqL1xyXG4gICAgX3Rlcm1pbmF0ZSgpIHtcclxuICAgICAgICByZW1vdmVDb21wb25lbnRzKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbml0aWFsaXplRmlyZXN0b3JlKGFwcCwgc2V0dGluZ3MsIGRhdGFiYXNlSWQpIHtcclxuICAgIGlmICghZGF0YWJhc2VJZCkge1xyXG4gICAgICAgIGRhdGFiYXNlSWQgPSBERUZBVUxUX0RBVEFCQVNFX05BTUU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsICdmaXJlc3RvcmUvbGl0ZScpO1xyXG4gICAgaWYgKHByb3ZpZGVyLmlzSW5pdGlhbGl6ZWQoZGF0YWJhc2VJZCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnRmlyZXN0b3JlIGNhbiBvbmx5IGJlIGluaXRpYWxpemVkIG9uY2UgcGVyIGFwcC4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm92aWRlci5pbml0aWFsaXplKHtcclxuICAgICAgICBvcHRpb25zOiBzZXR0aW5ncyxcclxuICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IGRhdGFiYXNlSWRcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldEZpcmVzdG9yZShhcHBPckRhdGFiYXNlSWQsIG9wdGlvbmFsRGF0YWJhc2VJZCkge1xyXG4gICAgY29uc3QgYXBwID0gdHlwZW9mIGFwcE9yRGF0YWJhc2VJZCA9PT0gJ29iamVjdCcgPyBhcHBPckRhdGFiYXNlSWQgOiBnZXRBcHAoKTtcclxuICAgIGNvbnN0IGRhdGFiYXNlSWQgPSB0eXBlb2YgYXBwT3JEYXRhYmFzZUlkID09PSAnc3RyaW5nJ1xyXG4gICAgICAgID8gYXBwT3JEYXRhYmFzZUlkXHJcbiAgICAgICAgOiBvcHRpb25hbERhdGFiYXNlSWQgfHwgJyhkZWZhdWx0KSc7XHJcbiAgICBjb25zdCBkYiA9IF9nZXRQcm92aWRlcihhcHAsICdmaXJlc3RvcmUvbGl0ZScpLmdldEltbWVkaWF0ZSh7XHJcbiAgICAgICAgaWRlbnRpZmllcjogZGF0YWJhc2VJZFxyXG4gICAgfSk7XHJcbiAgICBpZiAoIWRiLl9pbml0aWFsaXplZCkge1xyXG4gICAgICAgIGNvbnN0IGVtdWxhdG9yID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0KCdmaXJlc3RvcmUnKTtcclxuICAgICAgICBpZiAoZW11bGF0b3IpIHtcclxuICAgICAgICAgICAgY29ubmVjdEZpcmVzdG9yZUVtdWxhdG9yKGRiLCAuLi5lbXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRiO1xyXG59XHJcbi8qKlxyXG4gKiBNb2RpZnkgdGhpcyBpbnN0YW5jZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBDbG91ZCBGaXJlc3RvcmUgZW11bGF0b3IuXHJcbiAqXHJcbiAqIE5vdGU6IFRoaXMgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHRoaXMgaW5zdGFuY2UgaGFzIGJlZW4gdXNlZCB0byBkbyBhbnlcclxuICogb3BlcmF0aW9ucy5cclxuICpcclxuICogQHBhcmFtIGZpcmVzdG9yZSAtIFRoZSBgRmlyZXN0b3JlYCBpbnN0YW5jZSB0byBjb25maWd1cmUgdG8gY29ubmVjdCB0byB0aGVcclxuICogZW11bGF0b3IuXHJcbiAqIEBwYXJhbSBob3N0IC0gdGhlIGVtdWxhdG9yIGhvc3QgKGV4OiBsb2NhbGhvc3QpLlxyXG4gKiBAcGFyYW0gcG9ydCAtIHRoZSBlbXVsYXRvciBwb3J0IChleDogOTAwMCkuXHJcbiAqIEBwYXJhbSBvcHRpb25zLm1vY2tVc2VyVG9rZW4gLSB0aGUgbW9jayBhdXRoIHRva2VuIHRvIHVzZSBmb3IgdW5pdCB0ZXN0aW5nXHJcbiAqIFNlY3VyaXR5IFJ1bGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gY29ubmVjdEZpcmVzdG9yZUVtdWxhdG9yKGZpcmVzdG9yZSwgaG9zdCwgcG9ydCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IHNldHRpbmdzID0gZmlyZXN0b3JlLl9nZXRTZXR0aW5ncygpO1xyXG4gICAgY29uc3QgbmV3SG9zdFNldHRpbmcgPSBgJHtob3N0fToke3BvcnR9YDtcclxuICAgIGlmIChzZXR0aW5ncy5ob3N0ICE9PSBERUZBVUxUX0hPU1QgJiYgc2V0dGluZ3MuaG9zdCAhPT0gbmV3SG9zdFNldHRpbmcpIHtcclxuICAgICAgICBsb2dXYXJuKCdIb3N0IGhhcyBiZWVuIHNldCBpbiBib3RoIHNldHRpbmdzKCkgYW5kIGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvcigpLCBlbXVsYXRvciBob3N0ICcgK1xyXG4gICAgICAgICAgICAnd2lsbCBiZSB1c2VkLicpO1xyXG4gICAgfVxyXG4gICAgZmlyZXN0b3JlLl9zZXRTZXR0aW5ncyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzKSwgeyBob3N0OiBuZXdIb3N0U2V0dGluZywgc3NsOiBmYWxzZSB9KSk7XHJcbiAgICBpZiAob3B0aW9ucy5tb2NrVXNlclRva2VuKSB7XHJcbiAgICAgICAgbGV0IHRva2VuO1xyXG4gICAgICAgIGxldCB1c2VyO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tb2NrVXNlclRva2VuID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0b2tlbiA9IG9wdGlvbnMubW9ja1VzZXJUb2tlbjtcclxuICAgICAgICAgICAgdXNlciA9IFVzZXIuTU9DS19VU0VSO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTGV0IGNyZWF0ZU1vY2tVc2VyVG9rZW4gdmFsaWRhdGUgZmlyc3QgKGNhdGNoZXMgY29tbW9uIG1pc3Rha2VzIGxpa2VcclxuICAgICAgICAgICAgLy8gaW52YWxpZCBmaWVsZCBcInVpZFwiIGFuZCBtaXNzaW5nIGZpZWxkIFwic3ViXCIgLyBcInVzZXJfaWRcIi4pXHJcbiAgICAgICAgICAgIHRva2VuID0gY3JlYXRlTW9ja1VzZXJUb2tlbihvcHRpb25zLm1vY2tVc2VyVG9rZW4sIChfYSA9IGZpcmVzdG9yZS5fYXBwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW9ucy5wcm9qZWN0SWQpO1xyXG4gICAgICAgICAgICBjb25zdCB1aWQgPSBvcHRpb25zLm1vY2tVc2VyVG9rZW4uc3ViIHx8IG9wdGlvbnMubW9ja1VzZXJUb2tlbi51c2VyX2lkO1xyXG4gICAgICAgICAgICBpZiAoIXVpZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgXCJtb2NrVXNlclRva2VuIG11c3QgY29udGFpbiAnc3ViJyBvciAndXNlcl9pZCcgZmllbGQhXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVzZXIgPSBuZXcgVXNlcih1aWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaXJlc3RvcmUuX2F1dGhDcmVkZW50aWFscyA9IG5ldyBFbXVsYXRvckF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKG5ldyBPQXV0aFRva2VuKHRva2VuLCB1c2VyKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRlcm1pbmF0ZXMgdGhlIHByb3ZpZGVkIGBGaXJlc3RvcmVgIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBBZnRlciBjYWxsaW5nIGB0ZXJtaW5hdGUoKWAgb25seSB0aGUgYGNsZWFySW5kZXhlZERiUGVyc2lzdGVuY2UoKWAgZnVuY3Rpb25zXHJcbiAqIG1heSBiZSB1c2VkLiBBbnkgb3RoZXIgZnVuY3Rpb24gd2lsbCB0aHJvdyBhIGBGaXJlc3RvcmVFcnJvcmAuIFRlcm1pbmF0aW9uXHJcbiAqIGRvZXMgbm90IGNhbmNlbCBhbnkgcGVuZGluZyB3cml0ZXMsIGFuZCBhbnkgcHJvbWlzZXMgdGhhdCBhcmUgYXdhaXRpbmcgYVxyXG4gKiByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIgd2lsbCBub3QgYmUgcmVzb2x2ZWQuXHJcbiAqXHJcbiAqIFRvIHJlc3RhcnQgYWZ0ZXIgdGVybWluYXRpb24sIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBgRmlyZXN0b3JlYCB3aXRoXHJcbiAqIHtAbGluayAoZ2V0RmlyZXN0b3JlOjEpfS5cclxuICpcclxuICogTm90ZTogVW5kZXIgbm9ybWFsIGNpcmN1bXN0YW5jZXMsIGNhbGxpbmcgYHRlcm1pbmF0ZSgpYCBpcyBub3QgcmVxdWlyZWQuIFRoaXNcclxuICogZnVuY3Rpb24gaXMgdXNlZnVsIG9ubHkgd2hlbiB5b3Ugd2FudCB0byBmb3JjZSB0aGlzIGluc3RhbmNlIHRvIHJlbGVhc2UgYWxsIG9mXHJcbiAqIGl0cyByZXNvdXJjZXMgb3IgaW4gY29tYmluYXRpb24gd2l0aCB7QGxpbmsgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZX0gdG9cclxuICogZW5zdXJlIHRoYXQgYWxsIGxvY2FsIHN0YXRlIGlzIGRlc3Ryb3llZCBiZXR3ZWVuIHRlc3QgcnVucy5cclxuICpcclxuICogQHBhcmFtIGZpcmVzdG9yZSAtIFRoZSBgRmlyZXN0b3JlYCBpbnN0YW5jZSB0byB0ZXJtaW5hdGUuXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgaW5zdGFuY2UgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5XHJcbiAqIHRlcm1pbmF0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0ZXJtaW5hdGUoZmlyZXN0b3JlKSB7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UoZmlyZXN0b3JlLmFwcCwgJ2ZpcmVzdG9yZS9saXRlJyk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlLl9kZWxldGUoKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlckZpcmVzdG9yZSgpIHtcclxuICAgIHNldFNES1ZlcnNpb24oYCR7U0RLX1ZFUlNJT04kMX1fbGl0ZWApO1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2ZpcmVzdG9yZS9saXRlJywgKGNvbnRhaW5lciwgeyBpbnN0YW5jZUlkZW50aWZpZXI6IGRhdGFiYXNlSWQsIG9wdGlvbnM6IHNldHRpbmdzIH0pID0+IHtcclxuICAgICAgICBjb25zdCBhcHAgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcCcpLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IGZpcmVzdG9yZUluc3RhbmNlID0gbmV3IEZpcmVzdG9yZShuZXcgTGl0ZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKGNvbnRhaW5lci5nZXRQcm92aWRlcignYXV0aC1pbnRlcm5hbCcpKSwgbmV3IExpdGVBcHBDaGVja1Rva2VuUHJvdmlkZXIoY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAtY2hlY2staW50ZXJuYWwnKSksIGRhdGFiYXNlSWRGcm9tQXBwKGFwcCwgZGF0YWJhc2VJZCksIGFwcCk7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIGZpcmVzdG9yZUluc3RhbmNlLl9zZXRTZXR0aW5ncyhzZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaXJlc3RvcmVJbnN0YW5jZTtcclxuICAgIH0sICdQVUJMSUMnKS5zZXRNdWx0aXBsZUluc3RhbmNlcyh0cnVlKSk7XHJcbiAgICAvLyBSVU5USU1FX0VOViBhbmQgQlVJTERfVEFSR0VUIGFyZSByZXBsYWNlZCBieSByZWFsIHZhbHVlcyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXHJcbiAgICByZWdpc3RlclZlcnNpb24oJ2ZpcmVzdG9yZS1saXRlJywgdmVyc2lvbiQxLCAnbm9kZScpO1xyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKCdmaXJlc3RvcmUtbGl0ZScsIHZlcnNpb24kMSwgJ2VzbTIwMTcnKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIEFnZ3JlZ2F0ZSB0eXBlLlxyXG4gKi9cclxuY2xhc3MgQWdncmVnYXRlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhbGlhcywgYWdncmVnYXRlVHlwZSwgZmllbGRQYXRoKSB7XHJcbiAgICAgICAgdGhpcy5hbGlhcyA9IGFsaWFzO1xyXG4gICAgICAgIHRoaXMuYWdncmVnYXRlVHlwZSA9IGFnZ3JlZ2F0ZVR5cGU7XHJcbiAgICAgICAgdGhpcy5maWVsZFBhdGggPSBmaWVsZFBhdGg7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gYWdncmVnYXRpb24gdGhhdCBjYW4gYmUgcGVyZm9ybWVkIGJ5IEZpcmVzdG9yZS5cclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcclxuY2xhc3MgQWdncmVnYXRlRmllbGQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgQWdncmVnYXRlRmllbGQ8VD5cclxuICAgICAqIEBwYXJhbSBhZ2dyZWdhdGVUeXBlIFNwZWNpZmllcyB0aGUgdHlwZSBvZiBhZ2dyZWdhdGlvbiBvcGVyYXRpb24gdG8gcGVyZm9ybS5cclxuICAgICAqIEBwYXJhbSBfaW50ZXJuYWxGaWVsZFBhdGggT3B0aW9uYWxseSBzcGVjaWZpZXMgdGhlIGZpZWxkIHRoYXQgaXMgYWdncmVnYXRlZC5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihhZ2dyZWdhdGVUeXBlID0gJ2NvdW50JywgX2ludGVybmFsRmllbGRQYXRoKSB7XHJcbiAgICAgICAgdGhpcy5faW50ZXJuYWxGaWVsZFBhdGggPSBfaW50ZXJuYWxGaWVsZFBhdGg7XHJcbiAgICAgICAgLyoqIEEgdHlwZSBzdHJpbmcgdG8gdW5pcXVlbHkgaWRlbnRpZnkgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MuICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gJ0FnZ3JlZ2F0ZUZpZWxkJztcclxuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZVR5cGUgPSBhZ2dyZWdhdGVUeXBlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgcmVzdWx0cyBvZiBleGVjdXRpbmcgYW4gYWdncmVnYXRpb24gcXVlcnkuXHJcbiAqL1xyXG5jbGFzcyBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90IHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihxdWVyeSwgX3VzZXJEYXRhV3JpdGVyLCBfZGF0YSkge1xyXG4gICAgICAgIHRoaXMuX3VzZXJEYXRhV3JpdGVyID0gX3VzZXJEYXRhV3JpdGVyO1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcclxuICAgICAgICAvKiogQSB0eXBlIHN0cmluZyB0byB1bmlxdWVseSBpZGVudGlmeSBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcy4gKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSAnQWdncmVnYXRlUXVlcnlTbmFwc2hvdCc7XHJcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIHRoZSBhZ2dyZWdhdGlvbnMgcGVyZm9ybWVkIG92ZXIgdGhlIHVuZGVybHlpbmdcclxuICAgICAqIHF1ZXJ5LlxyXG4gICAgICpcclxuICAgICAqIFRoZSBrZXlzIG9mIHRoZSByZXR1cm5lZCBvYmplY3Qgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aG9zZSBvZiB0aGVcclxuICAgICAqIGBBZ2dyZWdhdGVTcGVjYCBvYmplY3Qgc3BlY2lmaWVkIHRvIHRoZSBhZ2dyZWdhdGlvbiBtZXRob2QsIGFuZCB0aGUgdmFsdWVzXHJcbiAgICAgKiB3aWxsIGJlIHRoZSBjb3JyZXNwb25kaW5nIGFnZ3JlZ2F0aW9uIHJlc3VsdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0cyBvZiB0aGUgYWdncmVnYXRpb25zIHBlcmZvcm1lZCBvdmVyIHRoZSB1bmRlcmx5aW5nXHJcbiAgICAgKiBxdWVyeS5cclxuICAgICAqL1xyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdXNlckRhdGFXcml0ZXIuY29udmVydE9iamVjdE1hcCh0aGlzLl9kYXRhKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBgUXVlcnlgIHJlZmVycyB0byBhIHF1ZXJ5IHdoaWNoIHlvdSBjYW4gcmVhZCBvciBsaXN0ZW4gdG8uIFlvdSBjYW4gYWxzb1xyXG4gKiBjb25zdHJ1Y3QgcmVmaW5lZCBgUXVlcnlgIG9iamVjdHMgYnkgYWRkaW5nIGZpbHRlcnMgYW5kIG9yZGVyaW5nLlxyXG4gKi9cclxuY2xhc3MgUXVlcnkge1xyXG4gICAgLy8gVGhpcyBpcyB0aGUgbGl0ZSB2ZXJzaW9uIG9mIHRoZSBRdWVyeSBjbGFzcyBpbiB0aGUgbWFpbiBTREsuXHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciBwcm90ZWN0ZWQgKi9cclxuICAgIGNvbnN0cnVjdG9yKGZpcmVzdG9yZSwgXHJcbiAgICAvKipcclxuICAgICAqIElmIHByb3ZpZGVkLCB0aGUgYEZpcmVzdG9yZURhdGFDb252ZXJ0ZXJgIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0ZXIsIF9xdWVyeSkge1xyXG4gICAgICAgIHRoaXMuY29udmVydGVyID0gY29udmVydGVyO1xyXG4gICAgICAgIHRoaXMuX3F1ZXJ5ID0gX3F1ZXJ5O1xyXG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIEZpcmVzdG9yZSByZWZlcmVuY2UuICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gJ3F1ZXJ5JztcclxuICAgICAgICB0aGlzLmZpcmVzdG9yZSA9IGZpcmVzdG9yZTtcclxuICAgIH1cclxuICAgIHdpdGhDb252ZXJ0ZXIoY29udmVydGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLmZpcmVzdG9yZSwgY29udmVydGVyLCB0aGlzLl9xdWVyeSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgYERvY3VtZW50UmVmZXJlbmNlYCByZWZlcnMgdG8gYSBkb2N1bWVudCBsb2NhdGlvbiBpbiBhIEZpcmVzdG9yZSBkYXRhYmFzZVxyXG4gKiBhbmQgY2FuIGJlIHVzZWQgdG8gd3JpdGUsIHJlYWQsIG9yIGxpc3RlbiB0byB0aGUgbG9jYXRpb24uIFRoZSBkb2N1bWVudCBhdFxyXG4gKiB0aGUgcmVmZXJlbmNlZCBsb2NhdGlvbiBtYXkgb3IgbWF5IG5vdCBleGlzdC5cclxuICovXHJcbmNsYXNzIERvY3VtZW50UmVmZXJlbmNlIHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihmaXJlc3RvcmUsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBwcm92aWRlZCwgdGhlIGBGaXJlc3RvcmVEYXRhQ29udmVydGVyYCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgY29udmVydGVyLCBfa2V5KSB7XHJcbiAgICAgICAgdGhpcy5jb252ZXJ0ZXIgPSBjb252ZXJ0ZXI7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBGaXJlc3RvcmUgcmVmZXJlbmNlLiAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdkb2N1bWVudCc7XHJcbiAgICAgICAgdGhpcy5maXJlc3RvcmUgPSBmaXJlc3RvcmU7XHJcbiAgICB9XHJcbiAgICBnZXQgX3BhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleS5wYXRoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZG9jdW1lbnQncyBpZGVudGlmaWVyIHdpdGhpbiBpdHMgY29sbGVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0IGlkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9rZXkucGF0aC5sYXN0U2VnbWVudCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHBhdGggb2YgdGhlIHJlZmVyZW5jZWQgZG9jdW1lbnQgKHJlbGF0aXZlXHJcbiAgICAgKiB0byB0aGUgcm9vdCBvZiB0aGUgZGF0YWJhc2UpLlxyXG4gICAgICovXHJcbiAgICBnZXQgcGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fa2V5LnBhdGguY2Fub25pY2FsU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb2xsZWN0aW9uIHRoaXMgYERvY3VtZW50UmVmZXJlbmNlYCBiZWxvbmdzIHRvLlxyXG4gICAgICovXHJcbiAgICBnZXQgcGFyZW50KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvblJlZmVyZW5jZSh0aGlzLmZpcmVzdG9yZSwgdGhpcy5jb252ZXJ0ZXIsIHRoaXMuX2tleS5wYXRoLnBvcExhc3QoKSk7XHJcbiAgICB9XHJcbiAgICB3aXRoQ29udmVydGVyKGNvbnZlcnRlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UodGhpcy5maXJlc3RvcmUsIGNvbnZlcnRlciwgdGhpcy5fa2V5KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBgQ29sbGVjdGlvblJlZmVyZW5jZWAgb2JqZWN0IGNhbiBiZSB1c2VkIGZvciBhZGRpbmcgZG9jdW1lbnRzLCBnZXR0aW5nXHJcbiAqIGRvY3VtZW50IHJlZmVyZW5jZXMsIGFuZCBxdWVyeWluZyBmb3IgZG9jdW1lbnRzICh1c2luZyB7QGxpbmsgKHF1ZXJ5OjEpfSkuXHJcbiAqL1xyXG5jbGFzcyBDb2xsZWN0aW9uUmVmZXJlbmNlIGV4dGVuZHMgUXVlcnkge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKGZpcmVzdG9yZSwgY29udmVydGVyLCBfcGF0aCkge1xyXG4gICAgICAgIHN1cGVyKGZpcmVzdG9yZSwgY29udmVydGVyLCBuZXdRdWVyeUZvclBhdGgoX3BhdGgpKTtcclxuICAgICAgICB0aGlzLl9wYXRoID0gX3BhdGg7XHJcbiAgICAgICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgRmlyZXN0b3JlIHJlZmVyZW5jZS4gKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSAnY29sbGVjdGlvbic7XHJcbiAgICB9XHJcbiAgICAvKiogVGhlIGNvbGxlY3Rpb24ncyBpZGVudGlmaWVyLiAqL1xyXG4gICAgZ2V0IGlkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9xdWVyeS5wYXRoLmxhc3RTZWdtZW50KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcGF0aCBvZiB0aGUgcmVmZXJlbmNlZCBjb2xsZWN0aW9uIChyZWxhdGl2ZVxyXG4gICAgICogdG8gdGhlIHJvb3Qgb2YgdGhlIGRhdGFiYXNlKS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5LnBhdGguY2Fub25pY2FsU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBjb250YWluaW5nIGBEb2N1bWVudFJlZmVyZW5jZWAgaWYgdGhpcyBpcyBhXHJcbiAgICAgKiBzdWJjb2xsZWN0aW9uLiBJZiB0aGlzIGlzbid0IGEgc3ViY29sbGVjdGlvbiwgdGhlIHJlZmVyZW5jZSBpcyBudWxsLlxyXG4gICAgICovXHJcbiAgICBnZXQgcGFyZW50KCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSB0aGlzLl9wYXRoLnBvcExhc3QoKTtcclxuICAgICAgICBpZiAocGFyZW50UGF0aC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHRoaXMuZmlyZXN0b3JlLCBcclxuICAgICAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsLCBuZXcgRG9jdW1lbnRLZXkocGFyZW50UGF0aCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHdpdGhDb252ZXJ0ZXIoY29udmVydGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uUmVmZXJlbmNlKHRoaXMuZmlyZXN0b3JlLCBjb252ZXJ0ZXIsIHRoaXMuX3BhdGgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbGxlY3Rpb24ocGFyZW50LCBwYXRoLCAuLi5wYXRoU2VnbWVudHMpIHtcclxuICAgIHBhcmVudCA9IGdldE1vZHVsYXJJbnN0YW5jZShwYXJlbnQpO1xyXG4gICAgdmFsaWRhdGVOb25FbXB0eUFyZ3VtZW50KCdjb2xsZWN0aW9uJywgJ3BhdGgnLCBwYXRoKTtcclxuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBGaXJlc3RvcmUpIHtcclxuICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhwYXRoLCAuLi5wYXRoU2VnbWVudHMpO1xyXG4gICAgICAgIHZhbGlkYXRlQ29sbGVjdGlvblBhdGgoYWJzb2x1dGVQYXRoKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWZlcmVuY2UocGFyZW50LCAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIGFic29sdXRlUGF0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkgJiZcclxuICAgICAgICAgICAgIShwYXJlbnQgaW5zdGFuY2VvZiBDb2xsZWN0aW9uUmVmZXJlbmNlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gY29sbGVjdGlvbigpIHRvIGJlIGEgQ29sbGVjdGlvblJlZmVyZW5jZSwgJyArXHJcbiAgICAgICAgICAgICAgICAnYSBEb2N1bWVudFJlZmVyZW5jZSBvciBGaXJlYmFzZUZpcmVzdG9yZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBwYXJlbnQuX3BhdGguY2hpbGQoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCwgLi4ucGF0aFNlZ21lbnRzKSk7XHJcbiAgICAgICAgdmFsaWRhdGVDb2xsZWN0aW9uUGF0aChhYnNvbHV0ZVBhdGgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvblJlZmVyZW5jZShwYXJlbnQuZmlyZXN0b3JlLCBcclxuICAgICAgICAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIGFic29sdXRlUGF0aCk7XHJcbiAgICB9XHJcbn1cclxuLy8gVE9ETyhmaXJlc3RvcmVsaXRlKTogQ29uc2lkZXIgdXNpbmcgRXJyb3JGYWN0b3J5IC1cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9ibG9iLzAxMzFlMWYvcGFja2FnZXMvdXRpbC9zcmMvZXJyb3JzLnRzI0wxMDZcclxuLyoqXHJcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgYFF1ZXJ5YCBpbnN0YW5jZSB0aGF0IGluY2x1ZGVzIGFsbCBkb2N1bWVudHMgaW4gdGhlXHJcbiAqIGRhdGFiYXNlIHRoYXQgYXJlIGNvbnRhaW5lZCBpbiBhIGNvbGxlY3Rpb24gb3Igc3ViY29sbGVjdGlvbiB3aXRoIHRoZVxyXG4gKiBnaXZlbiBgY29sbGVjdGlvbklkYC5cclxuICpcclxuICogQHBhcmFtIGZpcmVzdG9yZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSByb290IGBGaXJlc3RvcmVgIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gY29sbGVjdGlvbklkIC0gSWRlbnRpZmllcyB0aGUgY29sbGVjdGlvbnMgdG8gcXVlcnkgb3Zlci4gRXZlcnlcclxuICogY29sbGVjdGlvbiBvciBzdWJjb2xsZWN0aW9uIHdpdGggdGhpcyBJRCBhcyB0aGUgbGFzdCBzZWdtZW50IG9mIGl0cyBwYXRoXHJcbiAqIHdpbGwgYmUgaW5jbHVkZWQuIENhbm5vdCBjb250YWluIGEgc2xhc2guXHJcbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGBRdWVyeWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb2xsZWN0aW9uR3JvdXAoZmlyZXN0b3JlLCBjb2xsZWN0aW9uSWQpIHtcclxuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgdmFsaWRhdGVOb25FbXB0eUFyZ3VtZW50KCdjb2xsZWN0aW9uR3JvdXAnLCAnY29sbGVjdGlvbiBpZCcsIGNvbGxlY3Rpb25JZCk7XHJcbiAgICBpZiAoY29sbGVjdGlvbklkLmluZGV4T2YoJy8nKSA+PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgY29sbGVjdGlvbiBJRCAnJHtjb2xsZWN0aW9uSWR9JyBwYXNzZWQgdG8gZnVuY3Rpb24gYCArXHJcbiAgICAgICAgICAgIGBjb2xsZWN0aW9uR3JvdXAoKS4gQ29sbGVjdGlvbiBJRHMgbXVzdCBub3QgY29udGFpbiAnLycuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5KGZpcmVzdG9yZSwgXHJcbiAgICAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIG5ld1F1ZXJ5Rm9yQ29sbGVjdGlvbkdyb3VwKGNvbGxlY3Rpb25JZCkpO1xyXG59XHJcbmZ1bmN0aW9uIGRvYyhwYXJlbnQsIHBhdGgsIC4uLnBhdGhTZWdtZW50cykge1xyXG4gICAgcGFyZW50ID0gZ2V0TW9kdWxhckluc3RhbmNlKHBhcmVudCk7XHJcbiAgICAvLyBXZSBhbGxvdyBvbWlzc2lvbiBvZiAncGF0aFN0cmluZycgYnV0IGV4cGxpY2l0bHkgcHJvaGliaXQgcGFzc2luZyBpbiBib3RoXHJcbiAgICAvLyAndW5kZWZpbmVkJyBhbmQgJ251bGwnLlxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBwYXRoID0gQXV0b0lkLm5ld0lkKCk7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZU5vbkVtcHR5QXJndW1lbnQoJ2RvYycsICdwYXRoJywgcGF0aCk7XHJcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgRmlyZXN0b3JlKSB7XHJcbiAgICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCwgLi4ucGF0aFNlZ21lbnRzKTtcclxuICAgICAgICB2YWxpZGF0ZURvY3VtZW50UGF0aChhYnNvbHV0ZVBhdGgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UocGFyZW50LCBcclxuICAgICAgICAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIG5ldyBEb2N1bWVudEtleShhYnNvbHV0ZVBhdGgpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICghKHBhcmVudCBpbnN0YW5jZW9mIERvY3VtZW50UmVmZXJlbmNlKSAmJlxyXG4gICAgICAgICAgICAhKHBhcmVudCBpbnN0YW5jZW9mIENvbGxlY3Rpb25SZWZlcmVuY2UpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBjb2xsZWN0aW9uKCkgdG8gYmUgYSBDb2xsZWN0aW9uUmVmZXJlbmNlLCAnICtcclxuICAgICAgICAgICAgICAgICdhIERvY3VtZW50UmVmZXJlbmNlIG9yIEZpcmViYXNlRmlyZXN0b3JlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHBhcmVudC5fcGF0aC5jaGlsZChSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhwYXRoLCAuLi5wYXRoU2VnbWVudHMpKTtcclxuICAgICAgICB2YWxpZGF0ZURvY3VtZW50UGF0aChhYnNvbHV0ZVBhdGgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UocGFyZW50LmZpcmVzdG9yZSwgcGFyZW50IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSA/IHBhcmVudC5jb252ZXJ0ZXIgOiBudWxsLCBuZXcgRG9jdW1lbnRLZXkoYWJzb2x1dGVQYXRoKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgcmVmZXJlbmNlcyBhcmUgZXF1YWwuXHJcbiAqXHJcbiAqIEBwYXJhbSBsZWZ0IC0gQSByZWZlcmVuY2UgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHJpZ2h0IC0gQSByZWZlcmVuY2UgdG8gY29tcGFyZS5cclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcmVmZXJlbmNlcyBwb2ludCB0byB0aGUgc2FtZSBsb2NhdGlvbiBpbiB0aGUgc2FtZVxyXG4gKiBGaXJlc3RvcmUgZGF0YWJhc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWZFcXVhbChsZWZ0LCByaWdodCkge1xyXG4gICAgbGVmdCA9IGdldE1vZHVsYXJJbnN0YW5jZShsZWZ0KTtcclxuICAgIHJpZ2h0ID0gZ2V0TW9kdWxhckluc3RhbmNlKHJpZ2h0KTtcclxuICAgIGlmICgobGVmdCBpbnN0YW5jZW9mIERvY3VtZW50UmVmZXJlbmNlIHx8XHJcbiAgICAgICAgbGVmdCBpbnN0YW5jZW9mIENvbGxlY3Rpb25SZWZlcmVuY2UpICYmXHJcbiAgICAgICAgKHJpZ2h0IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UgfHwgcmlnaHQgaW5zdGFuY2VvZiBDb2xsZWN0aW9uUmVmZXJlbmNlKSkge1xyXG4gICAgICAgIHJldHVybiAobGVmdC5maXJlc3RvcmUgPT09IHJpZ2h0LmZpcmVzdG9yZSAmJlxyXG4gICAgICAgICAgICBsZWZ0LnBhdGggPT09IHJpZ2h0LnBhdGggJiZcclxuICAgICAgICAgICAgbGVmdC5jb252ZXJ0ZXIgPT09IHJpZ2h0LmNvbnZlcnRlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgcXVlcmllcyBwb2ludCB0byB0aGUgc2FtZSBjb2xsZWN0aW9uIGFuZCBhcHBseVxyXG4gKiB0aGUgc2FtZSBjb25zdHJhaW50cy5cclxuICpcclxuICogQHBhcmFtIGxlZnQgLSBBIGBRdWVyeWAgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHJpZ2h0IC0gQSBgUXVlcnlgIHRvIGNvbXBhcmUuXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHJlZmVyZW5jZXMgcG9pbnQgdG8gdGhlIHNhbWUgbG9jYXRpb24gaW4gdGhlIHNhbWVcclxuICogRmlyZXN0b3JlIGRhdGFiYXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlFcXVhbChsZWZ0LCByaWdodCkge1xyXG4gICAgbGVmdCA9IGdldE1vZHVsYXJJbnN0YW5jZShsZWZ0KTtcclxuICAgIHJpZ2h0ID0gZ2V0TW9kdWxhckluc3RhbmNlKHJpZ2h0KTtcclxuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgUXVlcnkgJiYgcmlnaHQgaW5zdGFuY2VvZiBRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiAobGVmdC5maXJlc3RvcmUgPT09IHJpZ2h0LmZpcmVzdG9yZSAmJlxyXG4gICAgICAgICAgICBxdWVyeUVxdWFscyhsZWZ0Ll9xdWVyeSwgcmlnaHQuX3F1ZXJ5KSAmJlxyXG4gICAgICAgICAgICBsZWZ0LmNvbnZlcnRlciA9PT0gcmlnaHQuY29udmVydGVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW1tdXRhYmxlIG9iamVjdCByZXByZXNlbnRpbmcgYW4gYXJyYXkgb2YgYnl0ZXMuXHJcbiAqL1xyXG5jbGFzcyBCeXRlcyB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoYnl0ZVN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX2J5dGVTdHJpbmcgPSBieXRlU3RyaW5nO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBCeXRlc2Agb2JqZWN0IGZyb20gdGhlIGdpdmVuIEJhc2U2NCBzdHJpbmcsIGNvbnZlcnRpbmcgaXQgdG9cclxuICAgICAqIGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBiYXNlNjQgLSBUaGUgQmFzZTY0IHN0cmluZyB1c2VkIHRvIGNyZWF0ZSB0aGUgYEJ5dGVzYCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tQmFzZTY0U3RyaW5nKGJhc2U2NCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZXMoQnl0ZVN0cmluZy5mcm9tQmFzZTY0U3RyaW5nKGJhc2U2NCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnRmFpbGVkIHRvIGNvbnN0cnVjdCBkYXRhIGZyb20gQmFzZTY0IHN0cmluZzogJyArIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgQnl0ZXNgIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBVaW50OEFycmF5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhcnJheSAtIFRoZSBVaW50OEFycmF5IHVzZWQgdG8gY3JlYXRlIHRoZSBgQnl0ZXNgIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21VaW50OEFycmF5KGFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlcyhCeXRlU3RyaW5nLmZyb21VaW50OEFycmF5KGFycmF5KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgYnl0ZXMgYXMgYSBCYXNlNjQtZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIEJhc2U2NC1lbmNvZGVkIHN0cmluZyBjcmVhdGVkIGZyb20gdGhlIGBCeXRlc2Agb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB0b0Jhc2U2NCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZVN0cmluZy50b0Jhc2U2NCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIGJ5dGVzIGluIGEgbmV3IGBVaW50OEFycmF5YC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgVWludDhBcnJheSBjcmVhdGVkIGZyb20gdGhlIGBCeXRlc2Agb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB0b1VpbnQ4QXJyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVTdHJpbmcudG9VaW50OEFycmF5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGBCeXRlc2Agb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgQnl0ZXNgIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICdCeXRlcyhiYXNlNjQ6ICcgKyB0aGlzLnRvQmFzZTY0KCkgKyAnKSc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGBCeXRlc2Agb2JqZWN0IGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG90aGVyIC0gVGhlIGBCeXRlc2Agb2JqZWN0IHRvIGNvbXBhcmUgYWdhaW5zdC5cclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBgQnl0ZXNgIG9iamVjdCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxyXG4gICAgICovXHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVTdHJpbmcuaXNFcXVhbChvdGhlci5fYnl0ZVN0cmluZyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgYEZpZWxkUGF0aGAgcmVmZXJzIHRvIGEgZmllbGQgaW4gYSBkb2N1bWVudC4gVGhlIHBhdGggbWF5IGNvbnNpc3Qgb2YgYVxyXG4gKiBzaW5nbGUgZmllbGQgbmFtZSAocmVmZXJyaW5nIHRvIGEgdG9wLWxldmVsIGZpZWxkIGluIHRoZSBkb2N1bWVudCksIG9yIGFcclxuICogbGlzdCBvZiBmaWVsZCBuYW1lcyAocmVmZXJyaW5nIHRvIGEgbmVzdGVkIGZpZWxkIGluIHRoZSBkb2N1bWVudCkuXHJcbiAqXHJcbiAqIENyZWF0ZSBhIGBGaWVsZFBhdGhgIGJ5IHByb3ZpZGluZyBmaWVsZCBuYW1lcy4gSWYgbW9yZSB0aGFuIG9uZSBmaWVsZFxyXG4gKiBuYW1lIGlzIHByb3ZpZGVkLCB0aGUgcGF0aCB3aWxsIHBvaW50IHRvIGEgbmVzdGVkIGZpZWxkIGluIGEgZG9jdW1lbnQuXHJcbiAqL1xyXG5jbGFzcyBGaWVsZFBhdGgge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgYEZpZWxkUGF0aGAgZnJvbSB0aGUgcHJvdmlkZWQgZmllbGQgbmFtZXMuIElmIG1vcmUgdGhhbiBvbmUgZmllbGRcclxuICAgICAqIG5hbWUgaXMgcHJvdmlkZWQsIHRoZSBwYXRoIHdpbGwgcG9pbnQgdG8gYSBuZXN0ZWQgZmllbGQgaW4gYSBkb2N1bWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmllbGROYW1lcyAtIEEgbGlzdCBvZiBmaWVsZCBuYW1lcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoLi4uZmllbGROYW1lcykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lc1tpXS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIGZpZWxkIG5hbWUgYXQgYXJndW1lbnQgJChpICsgMSkuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICdGaWVsZCBuYW1lcyBtdXN0IG5vdCBiZSBlbXB0eS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pbnRlcm5hbFBhdGggPSBuZXcgRmllbGRQYXRoJDEoZmllbGROYW1lcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGBGaWVsZFBhdGhgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG90aGVyIC0gVGhlIGBGaWVsZFBhdGhgIHRvIGNvbXBhcmUgYWdhaW5zdC5cclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBgRmllbGRQYXRoYCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxyXG4gICAgICovXHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsUGF0aC5pc0VxdWFsKG90aGVyLl9pbnRlcm5hbFBhdGgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3BlY2lhbCBzZW50aW5lbCBgRmllbGRQYXRoYCB0byByZWZlciB0byB0aGUgSUQgb2YgYSBkb2N1bWVudC5cclxuICogSXQgY2FuIGJlIHVzZWQgaW4gcXVlcmllcyB0byBzb3J0IG9yIGZpbHRlciBieSB0aGUgZG9jdW1lbnQgSUQuXHJcbiAqL1xyXG5mdW5jdGlvbiBkb2N1bWVudElkKCkge1xyXG4gICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgoRE9DVU1FTlRfS0VZX05BTUUpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBTZW50aW5lbCB2YWx1ZXMgdGhhdCBjYW4gYmUgdXNlZCB3aGVuIHdyaXRpbmcgZG9jdW1lbnQgZmllbGRzIHdpdGggYHNldCgpYFxyXG4gKiBvciBgdXBkYXRlKClgLlxyXG4gKi9cclxuY2xhc3MgRmllbGRWYWx1ZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBfbWV0aG9kTmFtZSAtIFRoZSBwdWJsaWMgQVBJIGVuZHBvaW50IHRoYXQgcmV0dXJucyB0aGlzIGNsYXNzLlxyXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfbWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHRoaXMuX21ldGhvZE5hbWUgPSBfbWV0aG9kTmFtZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW1tdXRhYmxlIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljIGxvY2F0aW9uIGluIEZpcmVzdG9yZS4gVGhlXHJcbiAqIGxvY2F0aW9uIGlzIHJlcHJlc2VudGVkIGFzIGxhdGl0dWRlL2xvbmdpdHVkZSBwYWlyLlxyXG4gKlxyXG4gKiBMYXRpdHVkZSB2YWx1ZXMgYXJlIGluIHRoZSByYW5nZSBvZiBbLTkwLCA5MF0uXHJcbiAqIExvbmdpdHVkZSB2YWx1ZXMgYXJlIGluIHRoZSByYW5nZSBvZiBbLTE4MCwgMTgwXS5cclxuICovXHJcbmNsYXNzIEdlb1BvaW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbW11dGFibGUgYEdlb1BvaW50YCBvYmplY3Qgd2l0aCB0aGUgcHJvdmlkZWQgbGF0aXR1ZGUgYW5kXHJcbiAgICAgKiBsb25naXR1ZGUgdmFsdWVzLlxyXG4gICAgICogQHBhcmFtIGxhdGl0dWRlIC0gVGhlIGxhdGl0dWRlIGFzIG51bWJlciBiZXR3ZWVuIC05MCBhbmQgOTAuXHJcbiAgICAgKiBAcGFyYW0gbG9uZ2l0dWRlIC0gVGhlIGxvbmdpdHVkZSBhcyBudW1iZXIgYmV0d2VlbiAtMTgwIGFuZCAxODAuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxhdGl0dWRlLCBsb25naXR1ZGUpIHtcclxuICAgICAgICBpZiAoIWlzRmluaXRlKGxhdGl0dWRlKSB8fCBsYXRpdHVkZSA8IC05MCB8fCBsYXRpdHVkZSA+IDkwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdMYXRpdHVkZSBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gLTkwIGFuZCA5MCwgYnV0IHdhczogJyArIGxhdGl0dWRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShsb25naXR1ZGUpIHx8IGxvbmdpdHVkZSA8IC0xODAgfHwgbG9uZ2l0dWRlID4gMTgwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdMb25naXR1ZGUgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIC0xODAgYW5kIDE4MCwgYnV0IHdhczogJyArIGxvbmdpdHVkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xhdCA9IGxhdGl0dWRlO1xyXG4gICAgICAgIHRoaXMuX2xvbmcgPSBsb25naXR1ZGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsYXRpdHVkZSBvZiB0aGlzIGBHZW9Qb2ludGAgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGdldCBsYXRpdHVkZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGF0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbG9uZ2l0dWRlIG9mIHRoaXMgYEdlb1BvaW50YCBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGxvbmdpdHVkZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYEdlb1BvaW50YCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBgR2VvUG9pbnRgIHRvIGNvbXBhcmUgYWdhaW5zdC5cclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBgR2VvUG9pbnRgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXHJcbiAgICAgKi9cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGF0ID09PSBvdGhlci5fbGF0ICYmIHRoaXMuX2xvbmcgPT09IG90aGVyLl9sb25nO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEdlb1BvaW50LiAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7IGxhdGl0dWRlOiB0aGlzLl9sYXQsIGxvbmdpdHVkZTogdGhpcy5fbG9uZyB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3R1YWxseSBwcml2YXRlIHRvIEpTIGNvbnN1bWVycyBvZiBvdXIgQVBJLCBzbyB0aGlzIGZ1bmN0aW9uIGlzIHByZWZpeGVkXHJcbiAgICAgKiB3aXRoIGFuIHVuZGVyc2NvcmUuXHJcbiAgICAgKi9cclxuICAgIF9jb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKHByaW1pdGl2ZUNvbXBhcmF0b3IodGhpcy5fbGF0LCBvdGhlci5fbGF0KSB8fFxyXG4gICAgICAgICAgICBwcmltaXRpdmVDb21wYXJhdG9yKHRoaXMuX2xvbmcsIG90aGVyLl9sb25nKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgUkVTRVJWRURfRklFTERfUkVHRVggPSAvXl9fLipfXyQvO1xyXG4vKiogVGhlIHJlc3VsdCBvZiBwYXJzaW5nIGRvY3VtZW50IGRhdGEgKGUuZy4gZm9yIGEgc2V0RGF0YSBjYWxsKS4gKi9cclxuY2xhc3MgUGFyc2VkU2V0RGF0YSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBmaWVsZE1hc2ssIGZpZWxkVHJhbnNmb3Jtcykge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5maWVsZE1hc2sgPSBmaWVsZE1hc2s7XHJcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXM7XHJcbiAgICB9XHJcbiAgICB0b011dGF0aW9uKGtleSwgcHJlY29uZGl0aW9uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmllbGRNYXNrICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGF0Y2hNdXRhdGlvbihrZXksIHRoaXMuZGF0YSwgdGhpcy5maWVsZE1hc2ssIHByZWNvbmRpdGlvbiwgdGhpcy5maWVsZFRyYW5zZm9ybXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXRNdXRhdGlvbihrZXksIHRoaXMuZGF0YSwgcHJlY29uZGl0aW9uLCB0aGlzLmZpZWxkVHJhbnNmb3Jtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKiBUaGUgcmVzdWx0IG9mIHBhcnNpbmcgXCJ1cGRhdGVcIiBkYXRhIChpLmUuIGZvciBhbiB1cGRhdGVEYXRhIGNhbGwpLiAqL1xyXG5jbGFzcyBQYXJzZWRVcGRhdGVEYXRhIHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEsIFxyXG4gICAgLy8gVGhlIGZpZWxkTWFzayBkb2VzIG5vdCBpbmNsdWRlIGRvY3VtZW50IHRyYW5zZm9ybXMuXHJcbiAgICBmaWVsZE1hc2ssIGZpZWxkVHJhbnNmb3Jtcykge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5maWVsZE1hc2sgPSBmaWVsZE1hc2s7XHJcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXM7XHJcbiAgICB9XHJcbiAgICB0b011dGF0aW9uKGtleSwgcHJlY29uZGl0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXRjaE11dGF0aW9uKGtleSwgdGhpcy5kYXRhLCB0aGlzLmZpZWxkTWFzaywgcHJlY29uZGl0aW9uLCB0aGlzLmZpZWxkVHJhbnNmb3Jtcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNXcml0ZShkYXRhU291cmNlKSB7XHJcbiAgICBzd2l0Y2ggKGRhdGFTb3VyY2UpIHtcclxuICAgICAgICBjYXNlIDAgLyogVXNlckRhdGFTb3VyY2UuU2V0ICovOiAvLyBmYWxsIHRocm91Z2hcclxuICAgICAgICBjYXNlIDIgLyogVXNlckRhdGFTb3VyY2UuTWVyZ2VTZXQgKi86IC8vIGZhbGwgdGhyb3VnaFxyXG4gICAgICAgIGNhc2UgMSAvKiBVc2VyRGF0YVNvdXJjZS5VcGRhdGUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGNhc2UgMyAvKiBVc2VyRGF0YVNvdXJjZS5Bcmd1bWVudCAqLzpcclxuICAgICAgICBjYXNlIDQgLyogVXNlckRhdGFTb3VyY2UuQXJyYXlBcmd1bWVudCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgIH1cclxufVxyXG4vKiogQSBcImNvbnRleHRcIiBvYmplY3QgcGFzc2VkIGFyb3VuZCB3aGlsZSBwYXJzaW5nIHVzZXIgZGF0YS4gKi9cclxuY2xhc3MgUGFyc2VDb250ZXh0SW1wbCB7XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIGEgUGFyc2VDb250ZXh0IHdpdGggdGhlIGdpdmVuIHNvdXJjZSBhbmQgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2V0dGluZ3MgLSBUaGUgc2V0dGluZ3MgZm9yIHRoZSBwYXJzZXIuXHJcbiAgICAgKiBAcGFyYW0gZGF0YWJhc2VJZCAtIFRoZSBkYXRhYmFzZSBJRCBvZiB0aGUgRmlyZXN0b3JlIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIHNlcmlhbGl6ZXIgLSBUaGUgc2VyaWFsaXplciB0byB1c2UgdG8gZ2VuZXJhdGUgdGhlIFZhbHVlIHByb3RvLlxyXG4gICAgICogQHBhcmFtIGlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgLSBXaGV0aGVyIHRvIGlnbm9yZSB1bmRlZmluZWQgcHJvcGVydGllc1xyXG4gICAgICogcmF0aGVyIHRoYW4gdGhyb3cuXHJcbiAgICAgKiBAcGFyYW0gZmllbGRUcmFuc2Zvcm1zIC0gQSBtdXRhYmxlIGxpc3Qgb2YgZmllbGQgdHJhbnNmb3JtcyBlbmNvdW50ZXJlZFxyXG4gICAgICogd2hpbGUgcGFyc2luZyB0aGUgZGF0YS5cclxuICAgICAqIEBwYXJhbSBmaWVsZE1hc2sgLSBBIG11dGFibGUgbGlzdCBvZiBmaWVsZCBwYXRocyBlbmNvdW50ZXJlZCB3aGlsZSBwYXJzaW5nXHJcbiAgICAgKiB0aGUgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBUT0RPKGIvMzQ4NzExMzEpOiBXZSBkb24ndCBzdXBwb3J0IGFycmF5IHBhdGhzIHJpZ2h0IG5vdywgc28gcGF0aCBjYW4gYmVcclxuICAgICAqIG51bGwgdG8gaW5kaWNhdGUgdGhlIGNvbnRleHQgcmVwcmVzZW50cyBhbnkgbG9jYXRpb24gd2l0aGluIGFuIGFycmF5IChpblxyXG4gICAgICogd2hpY2ggY2FzZSBjZXJ0YWluIGZlYXR1cmVzIHdpbGwgbm90IHdvcmsgYW5kIGVycm9ycyB3aWxsIGJlIHNvbWV3aGF0XHJcbiAgICAgKiBjb21wcm9taXNlZCkuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzLCBkYXRhYmFzZUlkLCBzZXJpYWxpemVyLCBpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzLCBmaWVsZFRyYW5zZm9ybXMsIGZpZWxkTWFzaykge1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBkYXRhYmFzZUlkO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XHJcbiAgICAgICAgdGhpcy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzID0gaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcztcclxuICAgICAgICAvLyBNaW5vciBoYWNrOiBJZiBmaWVsZFRyYW5zZm9ybXMgaXMgdW5kZWZpbmVkLCB3ZSBhc3N1bWUgdGhpcyBpcyBhblxyXG4gICAgICAgIC8vIGV4dGVybmFsIGNhbGwgYW5kIHdlIG5lZWQgdG8gdmFsaWRhdGUgdGhlIGVudGlyZSBwYXRoLlxyXG4gICAgICAgIGlmIChmaWVsZFRyYW5zZm9ybXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IGZpZWxkVHJhbnNmb3JtcyB8fCBbXTtcclxuICAgICAgICB0aGlzLmZpZWxkTWFzayA9IGZpZWxkTWFzayB8fCBbXTtcclxuICAgIH1cclxuICAgIGdldCBwYXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnBhdGg7XHJcbiAgICB9XHJcbiAgICBnZXQgZGF0YVNvdXJjZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5kYXRhU291cmNlO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYSBuZXcgY29udGV4dCB3aXRoIHRoZSBzcGVjaWZpZWQgc2V0dGluZ3Mgb3ZlcndyaXR0ZW4uICovXHJcbiAgICBjb250ZXh0V2l0aChjb25maWd1cmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHRJbXBsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zZXR0aW5ncyksIGNvbmZpZ3VyYXRpb24pLCB0aGlzLmRhdGFiYXNlSWQsIHRoaXMuc2VyaWFsaXplciwgdGhpcy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzLCB0aGlzLmZpZWxkVHJhbnNmb3JtcywgdGhpcy5maWVsZE1hc2spO1xyXG4gICAgfVxyXG4gICAgY2hpbGRDb250ZXh0Rm9yRmllbGQoZmllbGQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gKF9hID0gdGhpcy5wYXRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hpbGQoZmllbGQpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRXaXRoKHsgcGF0aDogY2hpbGRQYXRoLCBhcnJheUVsZW1lbnQ6IGZhbHNlIH0pO1xyXG4gICAgICAgIGNvbnRleHQudmFsaWRhdGVQYXRoU2VnbWVudChmaWVsZCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgICB9XHJcbiAgICBjaGlsZENvbnRleHRGb3JGaWVsZFBhdGgoZmllbGQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gKF9hID0gdGhpcy5wYXRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hpbGQoZmllbGQpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRXaXRoKHsgcGF0aDogY2hpbGRQYXRoLCBhcnJheUVsZW1lbnQ6IGZhbHNlIH0pO1xyXG4gICAgICAgIGNvbnRleHQudmFsaWRhdGVQYXRoKCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgICB9XHJcbiAgICBjaGlsZENvbnRleHRGb3JBcnJheShpbmRleCkge1xyXG4gICAgICAgIC8vIFRPRE8oYi8zNDg3MTEzMSk6IFdlIGRvbid0IHN1cHBvcnQgYXJyYXkgcGF0aHMgcmlnaHQgbm93OyBzbyBtYWtlIHBhdGhcclxuICAgICAgICAvLyB1bmRlZmluZWQuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dFdpdGgoeyBwYXRoOiB1bmRlZmluZWQsIGFycmF5RWxlbWVudDogdHJ1ZSB9KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUVycm9yKHJlYXNvbikge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFcnJvcihyZWFzb24sIHRoaXMuc2V0dGluZ3MubWV0aG9kTmFtZSwgdGhpcy5zZXR0aW5ncy5oYXNDb252ZXJ0ZXIgfHwgZmFsc2UsIHRoaXMucGF0aCwgdGhpcy5zZXR0aW5ncy50YXJnZXREb2MpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgJ3RydWUnIGlmICdmaWVsZFBhdGgnIHdhcyB0cmF2ZXJzZWQgd2hlbiBjcmVhdGluZyB0aGlzIGNvbnRleHQuICovXHJcbiAgICBjb250YWlucyhmaWVsZFBhdGgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmllbGRNYXNrLmZpbmQoZmllbGQgPT4gZmllbGRQYXRoLmlzUHJlZml4T2YoZmllbGQpKSAhPT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zLmZpbmQodHJhbnNmb3JtID0+IGZpZWxkUGF0aC5pc1ByZWZpeE9mKHRyYW5zZm9ybS5maWVsZCkpICE9PSB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVQYXRoKCkge1xyXG4gICAgICAgIC8vIFRPRE8oYi8zNDg3MTEzMSk6IFJlbW92ZSBudWxsIGNoZWNrIG9uY2Ugd2UgaGF2ZSBwcm9wZXIgcGF0aHMgZm9yIGZpZWxkc1xyXG4gICAgICAgIC8vIHdpdGhpbiBhcnJheXMuXHJcbiAgICAgICAgaWYgKCF0aGlzLnBhdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGF0aFNlZ21lbnQodGhpcy5wYXRoLmdldChpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVQYXRoU2VnbWVudChzZWdtZW50KSB7XHJcbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IoJ0RvY3VtZW50IGZpZWxkcyBtdXN0IG5vdCBiZSBlbXB0eScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNXcml0ZSh0aGlzLmRhdGFTb3VyY2UpICYmIFJFU0VSVkVEX0ZJRUxEX1JFR0VYLnRlc3Qoc2VnbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcignRG9jdW1lbnQgZmllbGRzIGNhbm5vdCBiZWdpbiBhbmQgZW5kIHdpdGggXCJfX1wiJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgZm9yIHBhcnNpbmcgcmF3IHVzZXIgaW5wdXQgKHByb3ZpZGVkIHZpYSB0aGUgQVBJKSBpbnRvIGludGVybmFsIG1vZGVsXHJcbiAqIGNsYXNzZXMuXHJcbiAqL1xyXG5jbGFzcyBVc2VyRGF0YVJlYWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhYmFzZUlkLCBpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzLCBzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhYmFzZUlkID0gZGF0YWJhc2VJZDtcclxuICAgICAgICB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgPSBpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXIgfHwgbmV3U2VyaWFsaXplcihkYXRhYmFzZUlkKTtcclxuICAgIH1cclxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHRvcC1sZXZlbCBwYXJzZSBjb250ZXh0LiAqL1xyXG4gICAgY3JlYXRlQ29udGV4dChkYXRhU291cmNlLCBtZXRob2ROYW1lLCB0YXJnZXREb2MsIGhhc0NvbnZlcnRlciA9IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHRJbXBsKHtcclxuICAgICAgICAgICAgZGF0YVNvdXJjZSxcclxuICAgICAgICAgICAgbWV0aG9kTmFtZSxcclxuICAgICAgICAgICAgdGFyZ2V0RG9jLFxyXG4gICAgICAgICAgICBwYXRoOiBGaWVsZFBhdGgkMS5lbXB0eVBhdGgoKSxcclxuICAgICAgICAgICAgYXJyYXlFbGVtZW50OiBmYWxzZSxcclxuICAgICAgICAgICAgaGFzQ29udmVydGVyXHJcbiAgICAgICAgfSwgdGhpcy5kYXRhYmFzZUlkLCB0aGlzLnNlcmlhbGl6ZXIsIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3VXNlckRhdGFSZWFkZXIoZmlyZXN0b3JlKSB7XHJcbiAgICBjb25zdCBzZXR0aW5ncyA9IGZpcmVzdG9yZS5fZnJlZXplU2V0dGluZ3MoKTtcclxuICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXdTZXJpYWxpemVyKGZpcmVzdG9yZS5fZGF0YWJhc2VJZCk7XHJcbiAgICByZXR1cm4gbmV3IFVzZXJEYXRhUmVhZGVyKGZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgISFzZXR0aW5ncy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzLCBzZXJpYWxpemVyKTtcclxufVxyXG4vKiogUGFyc2UgZG9jdW1lbnQgZGF0YSBmcm9tIGEgc2V0KCkgY2FsbC4gKi9cclxuZnVuY3Rpb24gcGFyc2VTZXREYXRhKHVzZXJEYXRhUmVhZGVyLCBtZXRob2ROYW1lLCB0YXJnZXREb2MsIGlucHV0LCBoYXNDb252ZXJ0ZXIsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IHVzZXJEYXRhUmVhZGVyLmNyZWF0ZUNvbnRleHQob3B0aW9ucy5tZXJnZSB8fCBvcHRpb25zLm1lcmdlRmllbGRzXHJcbiAgICAgICAgPyAyIC8qIFVzZXJEYXRhU291cmNlLk1lcmdlU2V0ICovXHJcbiAgICAgICAgOiAwIC8qIFVzZXJEYXRhU291cmNlLlNldCAqLywgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jLCBoYXNDb252ZXJ0ZXIpO1xyXG4gICAgdmFsaWRhdGVQbGFpbk9iamVjdCgnRGF0YSBtdXN0IGJlIGFuIG9iamVjdCwgYnV0IGl0IHdhczonLCBjb250ZXh0LCBpbnB1dCk7XHJcbiAgICBjb25zdCB1cGRhdGVEYXRhID0gcGFyc2VPYmplY3QoaW5wdXQsIGNvbnRleHQpO1xyXG4gICAgbGV0IGZpZWxkTWFzaztcclxuICAgIGxldCBmaWVsZFRyYW5zZm9ybXM7XHJcbiAgICBpZiAob3B0aW9ucy5tZXJnZSkge1xyXG4gICAgICAgIGZpZWxkTWFzayA9IG5ldyBGaWVsZE1hc2soY29udGV4dC5maWVsZE1hc2spO1xyXG4gICAgICAgIGZpZWxkVHJhbnNmb3JtcyA9IGNvbnRleHQuZmllbGRUcmFuc2Zvcm1zO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3B0aW9ucy5tZXJnZUZpZWxkcykge1xyXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZEZpZWxkUGF0aHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHN0cmluZ09yRmllbGRQYXRoIG9mIG9wdGlvbnMubWVyZ2VGaWVsZHMpIHtcclxuICAgICAgICAgICAgY29uc3QgZmllbGRQYXRoID0gZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEobWV0aG9kTmFtZSwgc3RyaW5nT3JGaWVsZFBhdGgsIHRhcmdldERvYyk7XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5jb250YWlucyhmaWVsZFBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRmllbGQgJyR7ZmllbGRQYXRofScgaXMgc3BlY2lmaWVkIGluIHlvdXIgZmllbGQgbWFzayBidXQgbWlzc2luZyBmcm9tIHlvdXIgaW5wdXQgZGF0YS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWZpZWxkTWFza0NvbnRhaW5zKHZhbGlkYXRlZEZpZWxkUGF0aHMsIGZpZWxkUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlZEZpZWxkUGF0aHMucHVzaChmaWVsZFBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpZWxkTWFzayA9IG5ldyBGaWVsZE1hc2sodmFsaWRhdGVkRmllbGRQYXRocyk7XHJcbiAgICAgICAgZmllbGRUcmFuc2Zvcm1zID0gY29udGV4dC5maWVsZFRyYW5zZm9ybXMuZmlsdGVyKHRyYW5zZm9ybSA9PiBmaWVsZE1hc2suY292ZXJzKHRyYW5zZm9ybS5maWVsZCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmllbGRNYXNrID0gbnVsbDtcclxuICAgICAgICBmaWVsZFRyYW5zZm9ybXMgPSBjb250ZXh0LmZpZWxkVHJhbnNmb3JtcztcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUGFyc2VkU2V0RGF0YShuZXcgT2JqZWN0VmFsdWUodXBkYXRlRGF0YSksIGZpZWxkTWFzaywgZmllbGRUcmFuc2Zvcm1zKTtcclxufVxyXG5jbGFzcyBEZWxldGVGaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xyXG4gICAgX3RvRmllbGRUcmFuc2Zvcm0oY29udGV4dCkge1xyXG4gICAgICAgIGlmIChjb250ZXh0LmRhdGFTb3VyY2UgPT09IDIgLyogVXNlckRhdGFTb3VyY2UuTWVyZ2VTZXQgKi8pIHtcclxuICAgICAgICAgICAgLy8gTm8gdHJhbnNmb3JtIHRvIGFkZCBmb3IgYSBkZWxldGUsIGJ1dCB3ZSBuZWVkIHRvIGFkZCBpdCB0byBvdXJcclxuICAgICAgICAgICAgLy8gZmllbGRNYXNrIHNvIGl0IGdldHMgZGVsZXRlZC5cclxuICAgICAgICAgICAgY29udGV4dC5maWVsZE1hc2sucHVzaChjb250ZXh0LnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb250ZXh0LmRhdGFTb3VyY2UgPT09IDEgLyogVXNlckRhdGFTb3VyY2UuVXBkYXRlICovKSB7XHJcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoYCR7dGhpcy5fbWV0aG9kTmFtZX0oKSBjYW4gb25seSBhcHBlYXIgYXQgdGhlIHRvcCBsZXZlbCBgICtcclxuICAgICAgICAgICAgICAgICdvZiB5b3VyIHVwZGF0ZSBkYXRhJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBXZSBzaG91bGRuJ3QgZW5jb3VudGVyIGRlbGV0ZSBzZW50aW5lbHMgZm9yIHF1ZXJpZXMgb3Igbm9uLW1lcmdlIHNldCgpIGNhbGxzLlxyXG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGAke3RoaXMuX21ldGhvZE5hbWV9KCkgY2Fubm90IGJlIHVzZWQgd2l0aCBzZXQoKSB1bmxlc3MgeW91IHBhc3MgYCArXHJcbiAgICAgICAgICAgICAgICAne21lcmdlOnRydWV9Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIERlbGV0ZUZpZWxkVmFsdWVJbXBsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgY2hpbGQgY29udGV4dCBmb3IgcGFyc2luZyBTZXJpYWxpemFibGVGaWVsZFZhbHVlcy5cclxuICpcclxuICogVGhpcyBpcyBkaWZmZXJlbnQgdGhhbiBjYWxsaW5nIGBQYXJzZUNvbnRleHQuY29udGV4dFdpdGhgIGJlY2F1c2UgaXQga2VlcHNcclxuICogdGhlIGZpZWxkVHJhbnNmb3JtcyBhbmQgZmllbGRNYXNrIHNlcGFyYXRlLlxyXG4gKlxyXG4gKiBUaGUgY3JlYXRlZCBjb250ZXh0IGhhcyBpdHMgYGRhdGFTb3VyY2VgIHNldCB0byBgVXNlckRhdGFTb3VyY2UuQXJndW1lbnRgLlxyXG4gKiBBbHRob3VnaCB0aGVzZSB2YWx1ZXMgYXJlIHVzZWQgd2l0aCB3cml0ZXMsIGFueSBlbGVtZW50cyBpbiB0aGVzZSBGaWVsZFZhbHVlc1xyXG4gKiBhcmUgbm90IGNvbnNpZGVyZWQgd3JpdGVzIHNpbmNlIHRoZXkgY2Fubm90IGNvbnRhaW4gYW55IEZpZWxkVmFsdWUgc2VudGluZWxzLFxyXG4gKiBldGMuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaWVsZFZhbHVlIC0gVGhlIHNlbnRpbmVsIEZpZWxkVmFsdWUgZm9yIHdoaWNoIHRvIGNyZWF0ZSBhIGNoaWxkXHJcbiAqICAgICBjb250ZXh0LlxyXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBwYXJlbnQgY29udGV4dC5cclxuICogQHBhcmFtIGFycmF5RWxlbWVudCAtIFdoZXRoZXIgb3Igbm90IHRoZSBGaWVsZFZhbHVlIGhhcyBhbiBhcnJheS5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVNlbnRpbmVsQ2hpbGRDb250ZXh0KGZpZWxkVmFsdWUsIGNvbnRleHQsIGFycmF5RWxlbWVudCkge1xyXG4gICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHRJbXBsKHtcclxuICAgICAgICBkYXRhU291cmNlOiAzIC8qIFVzZXJEYXRhU291cmNlLkFyZ3VtZW50ICovLFxyXG4gICAgICAgIHRhcmdldERvYzogY29udGV4dC5zZXR0aW5ncy50YXJnZXREb2MsXHJcbiAgICAgICAgbWV0aG9kTmFtZTogZmllbGRWYWx1ZS5fbWV0aG9kTmFtZSxcclxuICAgICAgICBhcnJheUVsZW1lbnRcclxuICAgIH0sIGNvbnRleHQuZGF0YWJhc2VJZCwgY29udGV4dC5zZXJpYWxpemVyLCBjb250ZXh0Lmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMpO1xyXG59XHJcbmNsYXNzIFNlcnZlclRpbWVzdGFtcEZpZWxkVmFsdWVJbXBsIGV4dGVuZHMgRmllbGRWYWx1ZSB7XHJcbiAgICBfdG9GaWVsZFRyYW5zZm9ybShjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFRyYW5zZm9ybShjb250ZXh0LnBhdGgsIG5ldyBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0oKSk7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgU2VydmVyVGltZXN0YW1wRmllbGRWYWx1ZUltcGw7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQXJyYXlVbmlvbkZpZWxkVmFsdWVJbXBsIGV4dGVuZHMgRmllbGRWYWx1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lLCBfZWxlbWVudHMpIHtcclxuICAgICAgICBzdXBlcihtZXRob2ROYW1lKTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50cyA9IF9lbGVtZW50cztcclxuICAgIH1cclxuICAgIF90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpIHtcclxuICAgICAgICBjb25zdCBwYXJzZUNvbnRleHQgPSBjcmVhdGVTZW50aW5lbENoaWxkQ29udGV4dCh0aGlzLCBjb250ZXh0LCBcclxuICAgICAgICAvKmFycmF5PSovIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZEVsZW1lbnRzID0gdGhpcy5fZWxlbWVudHMubWFwKGVsZW1lbnQgPT4gcGFyc2VEYXRhKGVsZW1lbnQsIHBhcnNlQ29udGV4dCkpO1xyXG4gICAgICAgIGNvbnN0IGFycmF5VW5pb24gPSBuZXcgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbihwYXJzZWRFbGVtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFRyYW5zZm9ybShjb250ZXh0LnBhdGgsIGFycmF5VW5pb24pO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBBcnJheVVuaW9uRmllbGRWYWx1ZUltcGwgJiZcclxuICAgICAgICAgICAgZGVlcEVxdWFsKHRoaXMuX2VsZW1lbnRzLCBvdGhlci5fZWxlbWVudHMpKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBBcnJheVJlbW92ZUZpZWxkVmFsdWVJbXBsIGV4dGVuZHMgRmllbGRWYWx1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lLCBfZWxlbWVudHMpIHtcclxuICAgICAgICBzdXBlcihtZXRob2ROYW1lKTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50cyA9IF9lbGVtZW50cztcclxuICAgIH1cclxuICAgIF90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpIHtcclxuICAgICAgICBjb25zdCBwYXJzZUNvbnRleHQgPSBjcmVhdGVTZW50aW5lbENoaWxkQ29udGV4dCh0aGlzLCBjb250ZXh0LCBcclxuICAgICAgICAvKmFycmF5PSovIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZEVsZW1lbnRzID0gdGhpcy5fZWxlbWVudHMubWFwKGVsZW1lbnQgPT4gcGFyc2VEYXRhKGVsZW1lbnQsIHBhcnNlQ29udGV4dCkpO1xyXG4gICAgICAgIGNvbnN0IGFycmF5VW5pb24gPSBuZXcgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24ocGFyc2VkRWxlbWVudHMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRUcmFuc2Zvcm0oY29udGV4dC5wYXRoLCBhcnJheVVuaW9uKTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKG90aGVyIGluc3RhbmNlb2YgQXJyYXlSZW1vdmVGaWVsZFZhbHVlSW1wbCAmJlxyXG4gICAgICAgICAgICBkZWVwRXF1YWwodGhpcy5fZWxlbWVudHMsIG90aGVyLl9lbGVtZW50cykpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIE51bWVyaWNJbmNyZW1lbnRGaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kTmFtZSwgX29wZXJhbmQpIHtcclxuICAgICAgICBzdXBlcihtZXRob2ROYW1lKTtcclxuICAgICAgICB0aGlzLl9vcGVyYW5kID0gX29wZXJhbmQ7XHJcbiAgICB9XHJcbiAgICBfdG9GaWVsZFRyYW5zZm9ybShjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgbnVtZXJpY0luY3JlbWVudCA9IG5ldyBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uKGNvbnRleHQuc2VyaWFsaXplciwgdG9OdW1iZXIoY29udGV4dC5zZXJpYWxpemVyLCB0aGlzLl9vcGVyYW5kKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFRyYW5zZm9ybShjb250ZXh0LnBhdGgsIG51bWVyaWNJbmNyZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBOdW1lcmljSW5jcmVtZW50RmllbGRWYWx1ZUltcGwgJiZcclxuICAgICAgICAgICAgdGhpcy5fb3BlcmFuZCA9PT0gb3RoZXIuX29wZXJhbmQpO1xyXG4gICAgfVxyXG59XHJcbi8qKiBQYXJzZSB1cGRhdGUgZGF0YSBmcm9tIGFuIHVwZGF0ZSgpIGNhbGwuICovXHJcbmZ1bmN0aW9uIHBhcnNlVXBkYXRlRGF0YSh1c2VyRGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jLCBpbnB1dCkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IHVzZXJEYXRhUmVhZGVyLmNyZWF0ZUNvbnRleHQoMSAvKiBVc2VyRGF0YVNvdXJjZS5VcGRhdGUgKi8sIG1ldGhvZE5hbWUsIHRhcmdldERvYyk7XHJcbiAgICB2YWxpZGF0ZVBsYWluT2JqZWN0KCdEYXRhIG11c3QgYmUgYW4gb2JqZWN0LCBidXQgaXQgd2FzOicsIGNvbnRleHQsIGlucHV0KTtcclxuICAgIGNvbnN0IGZpZWxkTWFza1BhdGhzID0gW107XHJcbiAgICBjb25zdCB1cGRhdGVEYXRhID0gT2JqZWN0VmFsdWUuZW1wdHkoKTtcclxuICAgIGZvckVhY2goaW5wdXQsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcobWV0aG9kTmFtZSwga2V5LCB0YXJnZXREb2MpO1xyXG4gICAgICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXHJcbiAgICAgICAgLy8gcGVyZm9ybWluZyB2YWxpZGF0aW9uLlxyXG4gICAgICAgIHZhbHVlID0gZ2V0TW9kdWxhckluc3RhbmNlKHZhbHVlKTtcclxuICAgICAgICBjb25zdCBjaGlsZENvbnRleHQgPSBjb250ZXh0LmNoaWxkQ29udGV4dEZvckZpZWxkUGF0aChwYXRoKTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEZWxldGVGaWVsZFZhbHVlSW1wbCkge1xyXG4gICAgICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGZpZWxkIG1hc2ssIGJ1dCBkb24ndCBhZGQgYW55dGhpbmcgdG8gdXBkYXRlRGF0YS5cclxuICAgICAgICAgICAgZmllbGRNYXNrUGF0aHMucHVzaChwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VEYXRhKHZhbHVlLCBjaGlsZENvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAocGFyc2VkVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZmllbGRNYXNrUGF0aHMucHVzaChwYXRoKTtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZURhdGEuc2V0KHBhdGgsIHBhcnNlZFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgY29uc3QgbWFzayA9IG5ldyBGaWVsZE1hc2soZmllbGRNYXNrUGF0aHMpO1xyXG4gICAgcmV0dXJuIG5ldyBQYXJzZWRVcGRhdGVEYXRhKHVwZGF0ZURhdGEsIG1hc2ssIGNvbnRleHQuZmllbGRUcmFuc2Zvcm1zKTtcclxufVxyXG4vKiogUGFyc2UgdXBkYXRlIGRhdGEgZnJvbSBhIGxpc3Qgb2YgZmllbGQvdmFsdWUgYXJndW1lbnRzLiAqL1xyXG5mdW5jdGlvbiBwYXJzZVVwZGF0ZVZhcmFyZ3ModXNlckRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIHRhcmdldERvYywgZmllbGQsIHZhbHVlLCBtb3JlRmllbGRzQW5kVmFsdWVzKSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlckRhdGFSZWFkZXIuY3JlYXRlQ29udGV4dCgxIC8qIFVzZXJEYXRhU291cmNlLlVwZGF0ZSAqLywgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jKTtcclxuICAgIGNvbnN0IGtleXMgPSBbZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEobWV0aG9kTmFtZSwgZmllbGQsIHRhcmdldERvYyldO1xyXG4gICAgY29uc3QgdmFsdWVzID0gW3ZhbHVlXTtcclxuICAgIGlmIChtb3JlRmllbGRzQW5kVmFsdWVzLmxlbmd0aCAlIDIgIT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRnVuY3Rpb24gJHttZXRob2ROYW1lfSgpIG5lZWRzIHRvIGJlIGNhbGxlZCB3aXRoIGFuIGV2ZW4gbnVtYmVyIGAgK1xyXG4gICAgICAgICAgICAnb2YgYXJndW1lbnRzIHRoYXQgYWx0ZXJuYXRlIGJldHdlZW4gZmllbGQgbmFtZXMgYW5kIHZhbHVlcy4nKTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9yZUZpZWxkc0FuZFZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgIGtleXMucHVzaChmaWVsZFBhdGhGcm9tQXJndW1lbnQkMShtZXRob2ROYW1lLCBtb3JlRmllbGRzQW5kVmFsdWVzW2ldKSk7XHJcbiAgICAgICAgdmFsdWVzLnB1c2gobW9yZUZpZWxkc0FuZFZhbHVlc1tpICsgMV0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZmllbGRNYXNrUGF0aHMgPSBbXTtcclxuICAgIGNvbnN0IHVwZGF0ZURhdGEgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xyXG4gICAgLy8gV2UgaXRlcmF0ZSBpbiByZXZlcnNlIG9yZGVyIHRvIHBpY2sgdGhlIGxhc3QgdmFsdWUgZm9yIGEgZmllbGQgaWYgdGhlXHJcbiAgICAvLyB1c2VyIHNwZWNpZmllZCB0aGUgZmllbGQgbXVsdGlwbGUgdGltZXMuXHJcbiAgICBmb3IgKGxldCBpID0ga2V5cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgIGlmICghZmllbGRNYXNrQ29udGFpbnMoZmllbGRNYXNrUGF0aHMsIGtleXNbaV0pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNbaV07XHJcbiAgICAgICAgICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXHJcbiAgICAgICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cclxuICAgICAgICAgICAgdmFsdWUgPSBnZXRNb2R1bGFySW5zdGFuY2UodmFsdWUpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZENvbnRleHQgPSBjb250ZXh0LmNoaWxkQ29udGV4dEZvckZpZWxkUGF0aChwYXRoKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGVsZXRlRmllbGRWYWx1ZUltcGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCBpdCB0byB0aGUgZmllbGQgbWFzaywgYnV0IGRvbid0IGFkZCBhbnl0aGluZyB0byB1cGRhdGVEYXRhLlxyXG4gICAgICAgICAgICAgICAgZmllbGRNYXNrUGF0aHMucHVzaChwYXRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VEYXRhKHZhbHVlLCBjaGlsZENvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZFZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZE1hc2tQYXRocy5wdXNoKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZURhdGEuc2V0KHBhdGgsIHBhcnNlZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IG1hc2sgPSBuZXcgRmllbGRNYXNrKGZpZWxkTWFza1BhdGhzKTtcclxuICAgIHJldHVybiBuZXcgUGFyc2VkVXBkYXRlRGF0YSh1cGRhdGVEYXRhLCBtYXNrLCBjb250ZXh0LmZpZWxkVHJhbnNmb3Jtcyk7XHJcbn1cclxuLyoqXHJcbiAqIFBhcnNlIGEgXCJxdWVyeSB2YWx1ZVwiIChlLmcuIHZhbHVlIGluIGEgd2hlcmUgZmlsdGVyIG9yIGEgdmFsdWUgaW4gYSBjdXJzb3JcclxuICogYm91bmQpLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWxsb3dBcnJheXMgLSBXaGV0aGVyIHRoZSBxdWVyeSB2YWx1ZSBpcyBhbiBhcnJheSB0aGF0IG1heSBkaXJlY3RseVxyXG4gKiBjb250YWluIGFkZGl0aW9uYWwgYXJyYXlzIChlLmcuIHRoZSBvcGVyYW5kIG9mIGFuIGBpbmAgcXVlcnkpLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VRdWVyeVZhbHVlKHVzZXJEYXRhUmVhZGVyLCBtZXRob2ROYW1lLCBpbnB1dCwgYWxsb3dBcnJheXMgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IHVzZXJEYXRhUmVhZGVyLmNyZWF0ZUNvbnRleHQoYWxsb3dBcnJheXMgPyA0IC8qIFVzZXJEYXRhU291cmNlLkFycmF5QXJndW1lbnQgKi8gOiAzIC8qIFVzZXJEYXRhU291cmNlLkFyZ3VtZW50ICovLCBtZXRob2ROYW1lKTtcclxuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlRGF0YShpbnB1dCwgY29udGV4dCk7XHJcbiAgICByZXR1cm4gcGFyc2VkO1xyXG59XHJcbi8qKlxyXG4gKiBQYXJzZXMgdXNlciBkYXRhIHRvIFByb3RvYnVmIFZhbHVlcy5cclxuICpcclxuICogQHBhcmFtIGlucHV0IC0gRGF0YSB0byBiZSBwYXJzZWQuXHJcbiAqIEBwYXJhbSBjb250ZXh0IC0gQSBjb250ZXh0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcGF0aCBiZWluZyBwYXJzZWQsXHJcbiAqIHRoZSBzb3VyY2Ugb2YgdGhlIGRhdGEgYmVpbmcgcGFyc2VkLCBldGMuXHJcbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgdmFsdWUsIG9yIG51bGwgaWYgdGhlIHZhbHVlIHdhcyBhIEZpZWxkVmFsdWUgc2VudGluZWxcclxuICogdGhhdCBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgcGFyc2VkIGRhdGEuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZURhdGEoaW5wdXQsIGNvbnRleHQpIHtcclxuICAgIC8vIFVud3JhcCB0aGUgQVBJIHR5cGUgZnJvbSB0aGUgQ29tcGF0IFNESy4gVGhpcyB3aWxsIHJldHVybiB0aGUgQVBJIHR5cGVcclxuICAgIC8vIGZyb20gZmlyZXN0b3JlLWV4cC5cclxuICAgIGlucHV0ID0gZ2V0TW9kdWxhckluc3RhbmNlKGlucHV0KTtcclxuICAgIGlmIChsb29rc0xpa2VKc29uT2JqZWN0KGlucHV0KSkge1xyXG4gICAgICAgIHZhbGlkYXRlUGxhaW5PYmplY3QoJ1Vuc3VwcG9ydGVkIGZpZWxkIHZhbHVlOicsIGNvbnRleHQsIGlucHV0KTtcclxuICAgICAgICByZXR1cm4gcGFyc2VPYmplY3QoaW5wdXQsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBGaWVsZFZhbHVlKSB7XHJcbiAgICAgICAgLy8gRmllbGRWYWx1ZXMgdXN1YWxseSBwYXJzZSBpbnRvIHRyYW5zZm9ybXMgKGV4Y2VwdCBkZWxldGVGaWVsZCgpKVxyXG4gICAgICAgIC8vIGluIHdoaWNoIGNhc2Ugd2UgZG8gbm90IHdhbnQgdG8gaW5jbHVkZSB0aGlzIGZpZWxkIGluIG91ciBwYXJzZWQgZGF0YVxyXG4gICAgICAgIC8vIChhcyBkb2luZyBzbyB3aWxsIG92ZXJ3cml0ZSB0aGUgZmllbGQgZGlyZWN0bHkgcHJpb3IgdG8gdGhlIHRyYW5zZm9ybVxyXG4gICAgICAgIC8vIHRyeWluZyB0byB0cmFuc2Zvcm0gaXQpLiBTbyB3ZSBkb24ndCBhZGQgdGhpcyBsb2NhdGlvbiB0b1xyXG4gICAgICAgIC8vIGNvbnRleHQuZmllbGRNYXNrIGFuZCB3ZSByZXR1cm4gbnVsbCBhcyBvdXIgcGFyc2luZyByZXN1bHQuXHJcbiAgICAgICAgcGFyc2VTZW50aW5lbEZpZWxkVmFsdWUoaW5wdXQsIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Lmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMpIHtcclxuICAgICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgdW5kZWZpbmVkIGl0IGNhbiBuZXZlciBwYXJ0aWNpcGF0ZSBpbiB0aGUgZmllbGRNYXNrLCBzb1xyXG4gICAgICAgIC8vIGRvbid0IGhhbmRsZSB0aGlzIGJlbG93LiBJZiBgaWdub3JlVW5kZWZpbmVkUHJvcGVydGllc2AgaXMgZmFsc2UsXHJcbiAgICAgICAgLy8gYHBhcnNlU2NhbGFyVmFsdWVgIHdpbGwgcmVqZWN0IGFuIHVuZGVmaW5lZCB2YWx1ZS5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIElmIGNvbnRleHQucGF0aCBpcyBudWxsIHdlIGFyZSBpbnNpZGUgYW4gYXJyYXkgYW5kIHdlIGRvbid0IHN1cHBvcnRcclxuICAgICAgICAvLyBmaWVsZCBtYXNrIHBhdGhzIG1vcmUgZ3JhbnVsYXIgdGhhbiB0aGUgdG9wLWxldmVsIGFycmF5LlxyXG4gICAgICAgIGlmIChjb250ZXh0LnBhdGgpIHtcclxuICAgICAgICAgICAgY29udGV4dC5maWVsZE1hc2sucHVzaChjb250ZXh0LnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPKGIvMzQ4NzExMzEpOiBJbmNsdWRlIHRoZSBwYXRoIGNvbnRhaW5pbmcgdGhlIGFycmF5IGluIHRoZSBlcnJvclxyXG4gICAgICAgICAgICAvLyBtZXNzYWdlLlxyXG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBJTiBxdWVyaWVzLCB0aGUgcGFyc2VkIGRhdGEgaXMgYW4gYXJyYXkgKHJlcHJlc2VudGluZ1xyXG4gICAgICAgICAgICAvLyB0aGUgc2V0IG9mIHZhbHVlcyB0byBiZSBpbmNsdWRlZCBmb3IgdGhlIElOIHF1ZXJ5KSB0aGF0IG1heSBkaXJlY3RseVxyXG4gICAgICAgICAgICAvLyBjb250YWluIGFkZGl0aW9uYWwgYXJyYXlzIChlYWNoIHJlcHJlc2VudGluZyBhbiBpbmRpdmlkdWFsIGZpZWxkXHJcbiAgICAgICAgICAgIC8vIHZhbHVlKSwgc28gd2UgZGlzYWJsZSB0aGlzIHZhbGlkYXRpb24uXHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnNldHRpbmdzLmFycmF5RWxlbWVudCAmJlxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5kYXRhU291cmNlICE9PSA0IC8qIFVzZXJEYXRhU291cmNlLkFycmF5QXJndW1lbnQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoJ05lc3RlZCBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VBcnJheShpbnB1dCwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTY2FsYXJWYWx1ZShpbnB1dCwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iaiwgY29udGV4dCkge1xyXG4gICAgY29uc3QgZmllbGRzID0ge307XHJcbiAgICBpZiAoaXNFbXB0eShvYmopKSB7XHJcbiAgICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVtcHR5IG9iamVjdCwgd2UgZXhwbGljaXRseSBhZGQgaXQgdG8gdGhlIHVwZGF0ZVxyXG4gICAgICAgIC8vIG1hc2sgdG8gZW5zdXJlIHRoYXQgdGhlIHNlcnZlciBjcmVhdGVzIGEgbWFwIGVudHJ5LlxyXG4gICAgICAgIGlmIChjb250ZXh0LnBhdGggJiYgY29udGV4dC5wYXRoLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29udGV4dC5maWVsZE1hc2sucHVzaChjb250ZXh0LnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZvckVhY2gob2JqLCAoa2V5LCB2YWwpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZURhdGEodmFsLCBjb250ZXh0LmNoaWxkQ29udGV4dEZvckZpZWxkKGtleSkpO1xyXG4gICAgICAgICAgICBpZiAocGFyc2VkVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZmllbGRzW2tleV0gPSBwYXJzZWRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgbWFwVmFsdWU6IHsgZmllbGRzIH0gfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUFycmF5KGFycmF5LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcclxuICAgIGxldCBlbnRyeUluZGV4ID0gMDtcclxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgYXJyYXkpIHtcclxuICAgICAgICBsZXQgcGFyc2VkRW50cnkgPSBwYXJzZURhdGEoZW50cnksIGNvbnRleHQuY2hpbGRDb250ZXh0Rm9yQXJyYXkoZW50cnlJbmRleCkpO1xyXG4gICAgICAgIGlmIChwYXJzZWRFbnRyeSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIEp1c3QgaW5jbHVkZSBudWxscyBpbiB0aGUgYXJyYXkgZm9yIGZpZWxkcyBiZWluZyByZXBsYWNlZCB3aXRoIGFcclxuICAgICAgICAgICAgLy8gc2VudGluZWwuXHJcbiAgICAgICAgICAgIHBhcnNlZEVudHJ5ID0geyBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWx1ZXMucHVzaChwYXJzZWRFbnRyeSk7XHJcbiAgICAgICAgZW50cnlJbmRleCsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgYXJyYXlWYWx1ZTogeyB2YWx1ZXMgfSB9O1xyXG59XHJcbi8qKlxyXG4gKiBcIlBhcnNlc1wiIHRoZSBwcm92aWRlZCBGaWVsZFZhbHVlSW1wbCwgYWRkaW5nIGFueSBuZWNlc3NhcnkgdHJhbnNmb3JtcyB0b1xyXG4gKiBjb250ZXh0LmZpZWxkVHJhbnNmb3Jtcy5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlU2VudGluZWxGaWVsZFZhbHVlKHZhbHVlLCBjb250ZXh0KSB7XHJcbiAgICAvLyBTZW50aW5lbHMgYXJlIG9ubHkgc3VwcG9ydGVkIHdpdGggd3JpdGVzLCBhbmQgbm90IHdpdGhpbiBhcnJheXMuXHJcbiAgICBpZiAoIWlzV3JpdGUoY29udGV4dC5kYXRhU291cmNlKSkge1xyXG4gICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoYCR7dmFsdWUuX21ldGhvZE5hbWV9KCkgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHVwZGF0ZSgpIGFuZCBzZXQoKWApO1xyXG4gICAgfVxyXG4gICAgaWYgKCFjb250ZXh0LnBhdGgpIHtcclxuICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGAke3ZhbHVlLl9tZXRob2ROYW1lfSgpIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGluc2lkZSBhcnJheXNgKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGZpZWxkVHJhbnNmb3JtID0gdmFsdWUuX3RvRmllbGRUcmFuc2Zvcm0oY29udGV4dCk7XHJcbiAgICBpZiAoZmllbGRUcmFuc2Zvcm0pIHtcclxuICAgICAgICBjb250ZXh0LmZpZWxkVHJhbnNmb3Jtcy5wdXNoKGZpZWxkVHJhbnNmb3JtKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIHBhcnNlIGEgc2NhbGFyIHZhbHVlIChpLmUuIG5vdCBhbiBPYmplY3QsIEFycmF5LCBvciBGaWVsZFZhbHVlKVxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVNjYWxhclZhbHVlKHZhbHVlLCBjb250ZXh0KSB7XHJcbiAgICB2YWx1ZSA9IGdldE1vZHVsYXJJbnN0YW5jZSh2YWx1ZSk7XHJcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4geyBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJyB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiB0b051bWJlcihjb250ZXh0LnNlcmlhbGl6ZXIsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgYm9vbGVhblZhbHVlOiB2YWx1ZSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiB7IHN0cmluZ1ZhbHVlOiB2YWx1ZSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gVGltZXN0YW1wLmZyb21EYXRlKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0aW1lc3RhbXBWYWx1ZTogdG9UaW1lc3RhbXAoY29udGV4dC5zZXJpYWxpemVyLCB0aW1lc3RhbXApXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgVGltZXN0YW1wKSB7XHJcbiAgICAgICAgLy8gRmlyZXN0b3JlIGJhY2tlbmQgdHJ1bmNhdGVzIHByZWNpc2lvbiBkb3duIHRvIG1pY3Jvc2Vjb25kcy4gVG8gZW5zdXJlXHJcbiAgICAgICAgLy8gb2ZmbGluZSBtb2RlIHdvcmtzIHRoZSBzYW1lIHdpdGggcmVnYXJkcyB0byB0cnVuY2F0aW9uLCBwZXJmb3JtIHRoZVxyXG4gICAgICAgIC8vIHRydW5jYXRpb24gaW1tZWRpYXRlbHkgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgYmFja2VuZCB0byBkbyB0aGF0LlxyXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBUaW1lc3RhbXAodmFsdWUuc2Vjb25kcywgTWF0aC5mbG9vcih2YWx1ZS5uYW5vc2Vjb25kcyAvIDEwMDApICogMTAwMCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGltZXN0YW1wVmFsdWU6IHRvVGltZXN0YW1wKGNvbnRleHQuc2VyaWFsaXplciwgdGltZXN0YW1wKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEdlb1BvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZ2VvUG9pbnRWYWx1ZToge1xyXG4gICAgICAgICAgICAgICAgbGF0aXR1ZGU6IHZhbHVlLmxhdGl0dWRlLFxyXG4gICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiB2YWx1ZS5sb25naXR1ZGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJ5dGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgYnl0ZXNWYWx1ZTogdG9CeXRlcyhjb250ZXh0LnNlcmlhbGl6ZXIsIHZhbHVlLl9ieXRlU3RyaW5nKSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkge1xyXG4gICAgICAgIGNvbnN0IHRoaXNEYiA9IGNvbnRleHQuZGF0YWJhc2VJZDtcclxuICAgICAgICBjb25zdCBvdGhlckRiID0gdmFsdWUuZmlyZXN0b3JlLl9kYXRhYmFzZUlkO1xyXG4gICAgICAgIGlmICghb3RoZXJEYi5pc0VxdWFsKHRoaXNEYikpIHtcclxuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcignRG9jdW1lbnQgcmVmZXJlbmNlIGlzIGZvciBkYXRhYmFzZSAnICtcclxuICAgICAgICAgICAgICAgIGAke290aGVyRGIucHJvamVjdElkfS8ke290aGVyRGIuZGF0YWJhc2V9IGJ1dCBzaG91bGQgYmUgYCArXHJcbiAgICAgICAgICAgICAgICBgZm9yIGRhdGFiYXNlICR7dGhpc0RiLnByb2plY3RJZH0vJHt0aGlzRGIuZGF0YWJhc2V9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJlZmVyZW5jZVZhbHVlOiB0b1Jlc291cmNlTmFtZSh2YWx1ZS5maXJlc3RvcmUuX2RhdGFiYXNlSWQgfHwgY29udGV4dC5kYXRhYmFzZUlkLCB2YWx1ZS5fa2V5LnBhdGgpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoYFVuc3VwcG9ydGVkIGZpZWxkIHZhbHVlOiAke3ZhbHVlRGVzY3JpcHRpb24odmFsdWUpfWApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBhbiBvYmplY3QgbG9va3MgbGlrZSBhIEpTT04gb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGNvbnZlcnRlZFxyXG4gKiBpbnRvIGEgc3RydWN0LiBOb3JtYWwgY2xhc3MvcHJvdG90eXBlIGluc3RhbmNlcyBhcmUgY29uc2lkZXJlZCB0byBsb29rIGxpa2VcclxuICogSlNPTiBvYmplY3RzIHNpbmNlIHRoZXkgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIHN0cnVjdCB2YWx1ZS4gQXJyYXlzLCBEYXRlcyxcclxuICogR2VvUG9pbnRzLCBldGMuIGFyZSBub3QgY29uc2lkZXJlZCB0byBsb29rIGxpa2UgSlNPTiBvYmplY3RzIHNpbmNlIHRoZXkgbWFwXHJcbiAqIHRvIHNwZWNpZmljIEZpZWxkVmFsdWUgdHlwZXMgb3RoZXIgdGhhbiBPYmplY3RWYWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGxvb2tzTGlrZUpzb25PYmplY3QoaW5wdXQpIHtcclxuICAgIHJldHVybiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgIGlucHV0ICE9PSBudWxsICYmXHJcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIEFycmF5KSAmJlxyXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSAmJlxyXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBUaW1lc3RhbXApICYmXHJcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIEdlb1BvaW50KSAmJlxyXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBCeXRlcykgJiZcclxuICAgICAgICAhKGlucHV0IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpICYmXHJcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIEZpZWxkVmFsdWUpKTtcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVBsYWluT2JqZWN0KG1lc3NhZ2UsIGNvbnRleHQsIGlucHV0KSB7XHJcbiAgICBpZiAoIWxvb2tzTGlrZUpzb25PYmplY3QoaW5wdXQpIHx8ICFpc1BsYWluT2JqZWN0KGlucHV0KSkge1xyXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsdWVEZXNjcmlwdGlvbihpbnB1dCk7XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uID09PSAnYW4gb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAvLyBNYXNzYWdlIHRoZSBlcnJvciBpZiBpdCB3YXMgYW4gb2JqZWN0LlxyXG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKG1lc3NhZ2UgKyAnIGEgY3VzdG9tIG9iamVjdCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihtZXNzYWdlICsgJyAnICsgZGVzY3JpcHRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogSGVscGVyIHRoYXQgY2FsbHMgZnJvbURvdFNlcGFyYXRlZFN0cmluZygpIGJ1dCB3cmFwcyBhbnkgZXJyb3IgdGhyb3duLlxyXG4gKi9cclxuZnVuY3Rpb24gZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEobWV0aG9kTmFtZSwgcGF0aCwgdGFyZ2V0RG9jKSB7XHJcbiAgICAvLyBJZiByZXF1aXJlZCwgcmVwbGFjZSB0aGUgRmllbGRQYXRoIENvbXBhdCBjbGFzcyB3aXRoIHdpdGggdGhlIGZpcmVzdG9yZS1leHBcclxuICAgIC8vIEZpZWxkUGF0aC5cclxuICAgIHBhdGggPSBnZXRNb2R1bGFySW5zdGFuY2UocGF0aCk7XHJcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIEZpZWxkUGF0aCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoLl9pbnRlcm5hbFBhdGg7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gZmllbGRQYXRoRnJvbURvdFNlcGFyYXRlZFN0cmluZyhtZXRob2ROYW1lLCBwYXRoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnRmllbGQgcGF0aCBhcmd1bWVudHMgbXVzdCBiZSBvZiB0eXBlIHN0cmluZyBvciAnO1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKG1lc3NhZ2UsIG1ldGhvZE5hbWUsIFxyXG4gICAgICAgIC8qIGhhc0NvbnZlcnRlcj0gKi8gZmFsc2UsIFxyXG4gICAgICAgIC8qIHBhdGg9ICovIHVuZGVmaW5lZCwgdGFyZ2V0RG9jKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWF0Y2hlcyBhbnkgY2hhcmFjdGVycyBpbiBhIGZpZWxkIHBhdGggc3RyaW5nIHRoYXQgYXJlIHJlc2VydmVkLlxyXG4gKi9cclxuY29uc3QgRklFTERfUEFUSF9SRVNFUlZFRCA9IG5ldyBSZWdFeHAoJ1t+XFxcXCovXFxcXFtcXFxcXV0nKTtcclxuLyoqXHJcbiAqIFdyYXBzIGZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcgd2l0aCBhbiBlcnJvciBtZXNzYWdlIGFib3V0IHRoZSBtZXRob2QgdGhhdFxyXG4gKiB3YXMgdGhyb3duLlxyXG4gKiBAcGFyYW0gbWV0aG9kTmFtZSAtIFRoZSBwdWJsaWNseSB2aXNpYmxlIG1ldGhvZCBuYW1lXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGRvdC1zZXBhcmF0ZWQgc3RyaW5nIGZvcm0gb2YgYSBmaWVsZCBwYXRoIHdoaWNoIHdpbGwgYmVcclxuICogc3BsaXQgb24gZG90cy5cclxuICogQHBhcmFtIHRhcmdldERvYyAtIFRoZSBkb2N1bWVudCBhZ2FpbnN0IHdoaWNoIHRoZSBmaWVsZCBwYXRoIHdpbGwgYmVcclxuICogZXZhbHVhdGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gZmllbGRQYXRoRnJvbURvdFNlcGFyYXRlZFN0cmluZyhtZXRob2ROYW1lLCBwYXRoLCB0YXJnZXREb2MpIHtcclxuICAgIGNvbnN0IGZvdW5kID0gcGF0aC5zZWFyY2goRklFTERfUEFUSF9SRVNFUlZFRCk7XHJcbiAgICBpZiAoZm91bmQgPj0gMCkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGBJbnZhbGlkIGZpZWxkIHBhdGggKCR7cGF0aH0pLiBQYXRocyBtdXN0IG5vdCBjb250YWluIGAgK1xyXG4gICAgICAgICAgICBgJ34nLCAnKicsICcvJywgJ1snLCBvciAnXSdgLCBtZXRob2ROYW1lLCBcclxuICAgICAgICAvKiBoYXNDb252ZXJ0ZXI9ICovIGZhbHNlLCBcclxuICAgICAgICAvKiBwYXRoPSAqLyB1bmRlZmluZWQsIHRhcmdldERvYyk7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRQYXRoKC4uLnBhdGguc3BsaXQoJy4nKSkuX2ludGVybmFsUGF0aDtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoYEludmFsaWQgZmllbGQgcGF0aCAoJHtwYXRofSkuIFBhdGhzIG11c3Qgbm90IGJlIGVtcHR5LCBgICtcclxuICAgICAgICAgICAgYGJlZ2luIHdpdGggJy4nLCBlbmQgd2l0aCAnLicsIG9yIGNvbnRhaW4gJy4uJ2AsIG1ldGhvZE5hbWUsIFxyXG4gICAgICAgIC8qIGhhc0NvbnZlcnRlcj0gKi8gZmFsc2UsIFxyXG4gICAgICAgIC8qIHBhdGg9ICovIHVuZGVmaW5lZCwgdGFyZ2V0RG9jKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVFcnJvcihyZWFzb24sIG1ldGhvZE5hbWUsIGhhc0NvbnZlcnRlciwgcGF0aCwgdGFyZ2V0RG9jKSB7XHJcbiAgICBjb25zdCBoYXNQYXRoID0gcGF0aCAmJiAhcGF0aC5pc0VtcHR5KCk7XHJcbiAgICBjb25zdCBoYXNEb2N1bWVudCA9IHRhcmdldERvYyAhPT0gdW5kZWZpbmVkO1xyXG4gICAgbGV0IG1lc3NhZ2UgPSBgRnVuY3Rpb24gJHttZXRob2ROYW1lfSgpIGNhbGxlZCB3aXRoIGludmFsaWQgZGF0YWA7XHJcbiAgICBpZiAoaGFzQ29udmVydGVyKSB7XHJcbiAgICAgICAgbWVzc2FnZSArPSAnICh2aWEgYHRvRmlyZXN0b3JlKClgKSc7XHJcbiAgICB9XHJcbiAgICBtZXNzYWdlICs9ICcuICc7XHJcbiAgICBsZXQgZGVzY3JpcHRpb24gPSAnJztcclxuICAgIGlmIChoYXNQYXRoIHx8IGhhc0RvY3VtZW50KSB7XHJcbiAgICAgICAgZGVzY3JpcHRpb24gKz0gJyAoZm91bmQnO1xyXG4gICAgICAgIGlmIChoYXNQYXRoKSB7XHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uICs9IGAgaW4gZmllbGQgJHtwYXRofWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNEb2N1bWVudCkge1xyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbiArPSBgIGluIGRvY3VtZW50ICR7dGFyZ2V0RG9jfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlc2NyaXB0aW9uICs9ICcpJztcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBtZXNzYWdlICsgcmVhc29uICsgZGVzY3JpcHRpb24pO1xyXG59XHJcbi8qKiBDaGVja3MgYGhheXN0YWNrYCBpZiBGaWVsZFBhdGggYG5lZWRsZWAgaXMgcHJlc2VudC4gUnVucyBpbiBPKG4pLiAqL1xyXG5mdW5jdGlvbiBmaWVsZE1hc2tDb250YWlucyhoYXlzdGFjaywgbmVlZGxlKSB7XHJcbiAgICByZXR1cm4gaGF5c3RhY2suc29tZSh2ID0+IHYuaXNFcXVhbChuZWVkbGUpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBgRG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbnMgZGF0YSByZWFkIGZyb20gYSBkb2N1bWVudCBpbiB5b3VyIEZpcmVzdG9yZVxyXG4gKiBkYXRhYmFzZS4gVGhlIGRhdGEgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGAuZGF0YSgpYCBvciBgLmdldCg8ZmllbGQ+KWAgdG9cclxuICogZ2V0IGEgc3BlY2lmaWMgZmllbGQuXHJcbiAqXHJcbiAqIEZvciBhIGBEb2N1bWVudFNuYXBzaG90YCB0aGF0IHBvaW50cyB0byBhIG5vbi1leGlzdGluZyBkb2N1bWVudCwgYW55IGRhdGFcclxuICogYWNjZXNzIHdpbGwgcmV0dXJuICd1bmRlZmluZWQnLiBZb3UgY2FuIHVzZSB0aGUgYGV4aXN0cygpYCBtZXRob2QgdG9cclxuICogZXhwbGljaXRseSB2ZXJpZnkgYSBkb2N1bWVudCdzIGV4aXN0ZW5jZS5cclxuICovXHJcbmNsYXNzIERvY3VtZW50U25hcHNob3Qge1xyXG4gICAgLy8gTm90ZTogVGhpcyBjbGFzcyBpcyBzdHJpcHBlZCBkb3duIHZlcnNpb24gb2YgdGhlIERvY3VtZW50U25hcHNob3QgaW5cclxuICAgIC8vIHRoZSBsZWdhY3kgU0RLLiBUaGUgY2hhbmdlcyBhcmU6XHJcbiAgICAvLyAtIE5vIHN1cHBvcnQgZm9yIFNuYXBzaG90TWV0YWRhdGEuXHJcbiAgICAvLyAtIE5vIHN1cHBvcnQgZm9yIFNuYXBzaG90T3B0aW9ucy5cclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yIHByb3RlY3RlZCAqL1xyXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSwgX3VzZXJEYXRhV3JpdGVyLCBfa2V5LCBfZG9jdW1lbnQsIF9jb252ZXJ0ZXIpIHtcclxuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xyXG4gICAgICAgIHRoaXMuX3VzZXJEYXRhV3JpdGVyID0gX3VzZXJEYXRhV3JpdGVyO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XHJcbiAgICAgICAgdGhpcy5fY29udmVydGVyID0gX2NvbnZlcnRlcjtcclxuICAgIH1cclxuICAgIC8qKiBQcm9wZXJ0eSBvZiB0aGUgYERvY3VtZW50U25hcHNob3RgIHRoYXQgcHJvdmlkZXMgdGhlIGRvY3VtZW50J3MgSUQuICovXHJcbiAgICBnZXQgaWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleS5wYXRoLmxhc3RTZWdtZW50KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBgRG9jdW1lbnRSZWZlcmVuY2VgIGZvciB0aGUgZG9jdW1lbnQgaW5jbHVkZWQgaW4gdGhlIGBEb2N1bWVudFNuYXBzaG90YC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHJlZigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHRoaXMuX2ZpcmVzdG9yZSwgdGhpcy5fY29udmVydGVyLCB0aGlzLl9rZXkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaWduYWxzIHdoZXRoZXIgb3Igbm90IHRoZSBkb2N1bWVudCBhdCB0aGUgc25hcHNob3QncyBsb2NhdGlvbiBleGlzdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZG9jdW1lbnQgZXhpc3RzLlxyXG4gICAgICovXHJcbiAgICBleGlzdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50ICE9PSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgYXMgYW4gYE9iamVjdGAuIFJldHVybnMgYHVuZGVmaW5lZGAgaWZcclxuICAgICAqIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgb3IgYHVuZGVmaW5lZGBcclxuICAgICAqIGlmIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICovXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fY29udmVydGVyKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB1c2UgdGhlIGNvbnZlcnRlciBhbmQgY3JlYXRlIGEgbmV3IERvY3VtZW50U25hcHNob3RcclxuICAgICAgICAgICAgLy8gaWYgYSBjb252ZXJ0ZXIgaGFzIGJlZW4gcHJvdmlkZWQuXHJcbiAgICAgICAgICAgIGNvbnN0IHNuYXBzaG90ID0gbmV3IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCh0aGlzLl9maXJlc3RvcmUsIHRoaXMuX3VzZXJEYXRhV3JpdGVyLCB0aGlzLl9rZXksIHRoaXMuX2RvY3VtZW50LCBcclxuICAgICAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRlci5mcm9tRmlyZXN0b3JlKHNuYXBzaG90KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91c2VyRGF0YVdyaXRlci5jb252ZXJ0VmFsdWUodGhpcy5fZG9jdW1lbnQuZGF0YS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGZpZWxkIHNwZWNpZmllZCBieSBgZmllbGRQYXRoYC4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGVcclxuICAgICAqIGRvY3VtZW50IG9yIGZpZWxkIGRvZXNuJ3QgZXhpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZpZWxkUGF0aCAtIFRoZSBwYXRoIChmb3IgZXhhbXBsZSAnZm9vJyBvciAnZm9vLmJhcicpIHRvIGEgc3BlY2lmaWNcclxuICAgICAqIGZpZWxkLlxyXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgYXQgdGhlIHNwZWNpZmllZCBmaWVsZCBsb2NhdGlvbiBvciB1bmRlZmluZWQgaWYgbm8gc3VjaFxyXG4gICAgICogZmllbGQgZXhpc3RzIGluIHRoZSBkb2N1bWVudC5cclxuICAgICAqL1xyXG4gICAgLy8gV2UgYXJlIHVzaW5nIGBhbnlgIGhlcmUgdG8gYXZvaWQgYW4gZXhwbGljaXQgY2FzdCBieSBvdXIgdXNlcnMuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgZ2V0KGZpZWxkUGF0aCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kb2N1bWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2RvY3VtZW50LmRhdGEuZmllbGQoZmllbGRQYXRoRnJvbUFyZ3VtZW50KCdEb2N1bWVudFNuYXBzaG90LmdldCcsIGZpZWxkUGF0aCkpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl91c2VyRGF0YVdyaXRlci5jb252ZXJ0VmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgYFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbnMgZGF0YSByZWFkIGZyb20gYSBkb2N1bWVudCBpbiB5b3VyXHJcbiAqIEZpcmVzdG9yZSBkYXRhYmFzZSBhcyBwYXJ0IG9mIGEgcXVlcnkuIFRoZSBkb2N1bWVudCBpcyBndWFyYW50ZWVkIHRvIGV4aXN0XHJcbiAqIGFuZCBpdHMgZGF0YSBjYW4gYmUgZXh0cmFjdGVkIHdpdGggYC5kYXRhKClgIG9yIGAuZ2V0KDxmaWVsZD4pYCB0byBnZXQgYVxyXG4gKiBzcGVjaWZpYyBmaWVsZC5cclxuICpcclxuICogQSBgUXVlcnlEb2N1bWVudFNuYXBzaG90YCBvZmZlcnMgdGhlIHNhbWUgQVBJIHN1cmZhY2UgYXMgYVxyXG4gKiBgRG9jdW1lbnRTbmFwc2hvdGAuIFNpbmNlIHF1ZXJ5IHJlc3VsdHMgY29udGFpbiBvbmx5IGV4aXN0aW5nIGRvY3VtZW50cywgdGhlXHJcbiAqIGBleGlzdHNgIHByb3BlcnR5IHdpbGwgYWx3YXlzIGJlIHRydWUgYW5kIGBkYXRhKClgIHdpbGwgbmV2ZXIgcmV0dXJuXHJcbiAqICd1bmRlZmluZWQnLlxyXG4gKi9cclxuY2xhc3MgUXVlcnlEb2N1bWVudFNuYXBzaG90IGV4dGVuZHMgRG9jdW1lbnRTbmFwc2hvdCB7XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudCBhcyBhbiBgT2JqZWN0YC5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRhdGEoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBgUXVlcnlTbmFwc2hvdGAgY29udGFpbnMgemVybyBvciBtb3JlIGBEb2N1bWVudFNuYXBzaG90YCBvYmplY3RzXHJcbiAqIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0cyBvZiBhIHF1ZXJ5LiBUaGUgZG9jdW1lbnRzIGNhbiBiZSBhY2Nlc3NlZCBhcyBhblxyXG4gKiBhcnJheSB2aWEgdGhlIGBkb2NzYCBwcm9wZXJ0eSBvciBlbnVtZXJhdGVkIHVzaW5nIHRoZSBgZm9yRWFjaGAgbWV0aG9kLiBUaGVcclxuICogbnVtYmVyIG9mIGRvY3VtZW50cyBjYW4gYmUgZGV0ZXJtaW5lZCB2aWEgdGhlIGBlbXB0eWAgYW5kIGBzaXplYFxyXG4gKiBwcm9wZXJ0aWVzLlxyXG4gKi9cclxuY2xhc3MgUXVlcnlTbmFwc2hvdCB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoX3F1ZXJ5LCBfZG9jcykge1xyXG4gICAgICAgIHRoaXMuX2RvY3MgPSBfZG9jcztcclxuICAgICAgICB0aGlzLnF1ZXJ5ID0gX3F1ZXJ5O1xyXG4gICAgfVxyXG4gICAgLyoqIEFuIGFycmF5IG9mIGFsbCB0aGUgZG9jdW1lbnRzIGluIHRoZSBgUXVlcnlTbmFwc2hvdGAuICovXHJcbiAgICBnZXQgZG9jcygpIHtcclxuICAgICAgICByZXR1cm4gWy4uLnRoaXMuX2RvY3NdO1xyXG4gICAgfVxyXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIGluIHRoZSBgUXVlcnlTbmFwc2hvdGAuICovXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2NzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKiBUcnVlIGlmIHRoZXJlIGFyZSBubyBkb2N1bWVudHMgaW4gdGhlIGBRdWVyeVNuYXBzaG90YC4gKi9cclxuICAgIGdldCBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2NzLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW51bWVyYXRlcyBhbGwgb2YgdGhlIGRvY3VtZW50cyBpbiB0aGUgYFF1ZXJ5U25hcHNob3RgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdpdGggYSBgUXVlcnlEb2N1bWVudFNuYXBzaG90YCBmb3JcclxuICAgICAqIGVhY2ggZG9jdW1lbnQgaW4gdGhlIHNuYXBzaG90LlxyXG4gICAgICogQHBhcmFtIHRoaXNBcmcgLSBUaGUgYHRoaXNgIGJpbmRpbmcgZm9yIHRoZSBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xyXG4gICAgICAgIHRoaXMuX2RvY3MuZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgc25hcHNob3RzIGFyZSBlcXVhbC5cclxuICpcclxuICogQHBhcmFtIGxlZnQgLSBBIHNuYXBzaG90IHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSByaWdodCAtIEEgc25hcHNob3QgdG8gY29tcGFyZS5cclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc25hcHNob3RzIGFyZSBlcXVhbC5cclxuICovXHJcbmZ1bmN0aW9uIHNuYXBzaG90RXF1YWwobGVmdCwgcmlnaHQpIHtcclxuICAgIGxlZnQgPSBnZXRNb2R1bGFySW5zdGFuY2UobGVmdCk7XHJcbiAgICByaWdodCA9IGdldE1vZHVsYXJJbnN0YW5jZShyaWdodCk7XHJcbiAgICBpZiAobGVmdCBpbnN0YW5jZW9mIERvY3VtZW50U25hcHNob3QgJiYgcmlnaHQgaW5zdGFuY2VvZiBEb2N1bWVudFNuYXBzaG90KSB7XHJcbiAgICAgICAgcmV0dXJuIChsZWZ0Ll9maXJlc3RvcmUgPT09IHJpZ2h0Ll9maXJlc3RvcmUgJiZcclxuICAgICAgICAgICAgbGVmdC5fa2V5LmlzRXF1YWwocmlnaHQuX2tleSkgJiZcclxuICAgICAgICAgICAgKGxlZnQuX2RvY3VtZW50ID09PSBudWxsXHJcbiAgICAgICAgICAgICAgICA/IHJpZ2h0Ll9kb2N1bWVudCA9PT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgOiBsZWZ0Ll9kb2N1bWVudC5pc0VxdWFsKHJpZ2h0Ll9kb2N1bWVudCkpICYmXHJcbiAgICAgICAgICAgIGxlZnQuX2NvbnZlcnRlciA9PT0gcmlnaHQuX2NvbnZlcnRlcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChsZWZ0IGluc3RhbmNlb2YgUXVlcnlTbmFwc2hvdCAmJiByaWdodCBpbnN0YW5jZW9mIFF1ZXJ5U25hcHNob3QpIHtcclxuICAgICAgICByZXR1cm4gKHF1ZXJ5RXF1YWwobGVmdC5xdWVyeSwgcmlnaHQucXVlcnkpICYmXHJcbiAgICAgICAgICAgIGFycmF5RXF1YWxzKGxlZnQuZG9jcywgcmlnaHQuZG9jcywgc25hcHNob3RFcXVhbCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdGhhdCBjYWxscyBgZnJvbURvdFNlcGFyYXRlZFN0cmluZygpYCBidXQgd3JhcHMgYW55IGVycm9yIHRocm93bi5cclxuICovXHJcbmZ1bmN0aW9uIGZpZWxkUGF0aEZyb21Bcmd1bWVudChtZXRob2ROYW1lLCBhcmcpIHtcclxuICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBmaWVsZFBhdGhGcm9tRG90U2VwYXJhdGVkU3RyaW5nKG1ldGhvZE5hbWUsIGFyZyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBGaWVsZFBhdGgpIHtcclxuICAgICAgICByZXR1cm4gYXJnLl9pbnRlcm5hbFBhdGg7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYXJnLl9kZWxlZ2F0ZS5faW50ZXJuYWxQYXRoO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlSGFzRXhwbGljaXRPcmRlckJ5Rm9yTGltaXRUb0xhc3QocXVlcnkpIHtcclxuICAgIGlmIChxdWVyeS5saW1pdFR5cGUgPT09IFwiTFwiIC8qIExpbWl0VHlwZS5MYXN0ICovICYmXHJcbiAgICAgICAgcXVlcnkuZXhwbGljaXRPcmRlckJ5Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOSU1QTEVNRU5URUQsICdsaW1pdFRvTGFzdCgpIHF1ZXJpZXMgcmVxdWlyZSBzcGVjaWZ5aW5nIGF0IGxlYXN0IG9uZSBvcmRlckJ5KCkgY2xhdXNlJyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFuIGBBcHBsaWFibGVDb25zdHJhaW50YCBpcyBhbiBhYnN0cmFjdGlvbiBvZiBhIGNvbnN0cmFpbnQgdGhhdCBjYW4gYmUgYXBwbGllZFxyXG4gKiB0byBhIEZpcmVzdG9yZSBxdWVyeS5cclxuICovXHJcbmNsYXNzIEFwcGxpYWJsZUNvbnN0cmFpbnQge1xyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeUNvbnN0cmFpbnRgIGlzIHVzZWQgdG8gbmFycm93IHRoZSBzZXQgb2YgZG9jdW1lbnRzIHJldHVybmVkIGJ5IGFcclxuICogRmlyZXN0b3JlIHF1ZXJ5LiBgUXVlcnlDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIHdoZXJlfSxcclxuICoge0BsaW5rIG9yZGVyQnl9LCB7QGxpbmsgKHN0YXJ0QXQ6MSl9LCB7QGxpbmsgKHN0YXJ0QWZ0ZXI6MSl9LCB7QGxpbmtcclxuICogKGVuZEJlZm9yZToxKX0sIHtAbGluayAoZW5kQXQ6MSl9LCB7QGxpbmsgbGltaXR9LCB7QGxpbmsgbGltaXRUb0xhc3R9IGFuZFxyXG4gKiBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGEgbmV3IHF1ZXJ5IGluc3RhbmNlIHRoYXRcclxuICogYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeUNvbnN0cmFpbnRgLlxyXG4gKi9cclxuY2xhc3MgUXVlcnlDb25zdHJhaW50IGV4dGVuZHMgQXBwbGlhYmxlQ29uc3RyYWludCB7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnkocXVlcnksIHF1ZXJ5Q29uc3RyYWludCwgLi4uYWRkaXRpb25hbFF1ZXJ5Q29uc3RyYWludHMpIHtcclxuICAgIGxldCBxdWVyeUNvbnN0cmFpbnRzID0gW107XHJcbiAgICBpZiAocXVlcnlDb25zdHJhaW50IGluc3RhbmNlb2YgQXBwbGlhYmxlQ29uc3RyYWludCkge1xyXG4gICAgICAgIHF1ZXJ5Q29uc3RyYWludHMucHVzaChxdWVyeUNvbnN0cmFpbnQpO1xyXG4gICAgfVxyXG4gICAgcXVlcnlDb25zdHJhaW50cyA9IHF1ZXJ5Q29uc3RyYWludHMuY29uY2F0KGFkZGl0aW9uYWxRdWVyeUNvbnN0cmFpbnRzKTtcclxuICAgIHZhbGlkYXRlUXVlcnlDb25zdHJhaW50QXJyYXkocXVlcnlDb25zdHJhaW50cyk7XHJcbiAgICBmb3IgKGNvbnN0IGNvbnN0cmFpbnQgb2YgcXVlcnlDb25zdHJhaW50cykge1xyXG4gICAgICAgIHF1ZXJ5ID0gY29uc3RyYWludC5fYXBwbHkocXVlcnkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHF1ZXJ5O1xyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludGAgaXMgdXNlZCB0byBuYXJyb3cgdGhlIHNldCBvZiBkb2N1bWVudHMgcmV0dXJuZWQgYnlcclxuICogYSBGaXJlc3RvcmUgcXVlcnkgYnkgZmlsdGVyaW5nIG9uIG9uZSBvciBtb3JlIGRvY3VtZW50IGZpZWxkcy5cclxuICogYFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIHdoZXJlfSBhbmQgY2FuIHRoZW5cclxuICogYmUgcGFzc2VkIHRvIHtAbGluayAocXVlcnk6MSl9IHRvIGNyZWF0ZSBhIG5ldyBxdWVyeSBpbnN0YW5jZSB0aGF0IGFsc28gY29udGFpbnNcclxuICogdGhpcyBgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnRgLlxyXG4gKi9cclxuY2xhc3MgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoX2ZpZWxkLCBfb3AsIF92YWx1ZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fZmllbGQgPSBfZmllbGQ7XHJcbiAgICAgICAgdGhpcy5fb3AgPSBfb3A7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICd3aGVyZSc7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2NyZWF0ZShfZmllbGQsIF9vcCwgX3ZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludChfZmllbGQsIF9vcCwgX3ZhbHVlKTtcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuX3BhcnNlKHF1ZXJ5KTtcclxuICAgICAgICB2YWxpZGF0ZU5ld0ZpZWxkRmlsdGVyKHF1ZXJ5Ll9xdWVyeSwgZmlsdGVyKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhBZGRlZEZpbHRlcihxdWVyeS5fcXVlcnksIGZpbHRlcikpO1xyXG4gICAgfVxyXG4gICAgX3BhcnNlKHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIocXVlcnkuZmlyZXN0b3JlKTtcclxuICAgICAgICBjb25zdCBmaWx0ZXIgPSBuZXdRdWVyeUZpbHRlcihxdWVyeS5fcXVlcnksICd3aGVyZScsIHJlYWRlciwgcXVlcnkuZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCB0aGlzLl9maWVsZCwgdGhpcy5fb3AsIHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEge0BsaW5rIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50fSB0aGF0IGVuZm9yY2VzIHRoYXQgZG9jdW1lbnRzXHJcbiAqIG11c3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIGZpZWxkIGFuZCB0aGF0IHRoZSB2YWx1ZSBzaG91bGQgc2F0aXNmeSB0aGVcclxuICogcmVsYXRpb24gY29uc3RyYWludCBwcm92aWRlZC5cclxuICpcclxuICogQHBhcmFtIGZpZWxkUGF0aCAtIFRoZSBwYXRoIHRvIGNvbXBhcmVcclxuICogQHBhcmFtIG9wU3RyIC0gVGhlIG9wZXJhdGlvbiBzdHJpbmcgKGUuZyBcIiZsdDtcIiwgXCImbHQ7PVwiLCBcIj09XCIsIFwiJmx0O1wiLFxyXG4gKiAgIFwiJmx0Oz1cIiwgXCIhPVwiKS5cclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGZvciBjb21wYXJpc29uXHJcbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHtAbGluayBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludH0uXHJcbiAqL1xyXG5mdW5jdGlvbiB3aGVyZShmaWVsZFBhdGgsIG9wU3RyLCB2YWx1ZSkge1xyXG4gICAgY29uc3Qgb3AgPSBvcFN0cjtcclxuICAgIGNvbnN0IGZpZWxkID0gZmllbGRQYXRoRnJvbUFyZ3VtZW50KCd3aGVyZScsIGZpZWxkUGF0aCk7XHJcbiAgICByZXR1cm4gUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnQuX2NyZWF0ZShmaWVsZCwgb3AsIHZhbHVlKTtcclxufVxyXG4vKipcclxuICogQSBgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50YCBpcyB1c2VkIHRvIG5hcnJvdyB0aGUgc2V0IG9mIGRvY3VtZW50c1xyXG4gKiByZXR1cm5lZCBieSBhIEZpcmVzdG9yZSBxdWVyeSBieSBwZXJmb3JtaW5nIHRoZSBsb2dpY2FsIE9SIG9yIEFORCBvZiBtdWx0aXBsZVxyXG4gKiB7QGxpbmsgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnR9cyBvciB7QGxpbmsgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50fXMuXHJcbiAqIGBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgb3J9IG9yXHJcbiAqIHtAbGluayBhbmR9IGFuZCBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGEgbmV3IHF1ZXJ5XHJcbiAqIGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWlucyB0aGUgYFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludGAuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnQgZXh0ZW5kcyBBcHBsaWFibGVDb25zdHJhaW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xyXG4gICAgdHlwZSwgX3F1ZXJ5Q29uc3RyYWludHMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5fcXVlcnlDb25zdHJhaW50cyA9IF9xdWVyeUNvbnN0cmFpbnRzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9jcmVhdGUodHlwZSwgX3F1ZXJ5Q29uc3RyYWludHMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCh0eXBlLCBfcXVlcnlDb25zdHJhaW50cyk7XHJcbiAgICB9XHJcbiAgICBfcGFyc2UocXVlcnkpIHtcclxuICAgICAgICBjb25zdCBwYXJzZWRGaWx0ZXJzID0gdGhpcy5fcXVlcnlDb25zdHJhaW50c1xyXG4gICAgICAgICAgICAubWFwKHF1ZXJ5Q29uc3RyYWludCA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBxdWVyeUNvbnN0cmFpbnQuX3BhcnNlKHF1ZXJ5KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZmlsdGVyKHBhcnNlZEZpbHRlciA9PiBwYXJzZWRGaWx0ZXIuZ2V0RmlsdGVycygpLmxlbmd0aCA+IDApO1xyXG4gICAgICAgIGlmIChwYXJzZWRGaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkRmlsdGVyc1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUocGFyc2VkRmlsdGVycywgdGhpcy5fZ2V0T3BlcmF0b3IoKSk7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICBjb25zdCBwYXJzZWRGaWx0ZXIgPSB0aGlzLl9wYXJzZShxdWVyeSk7XHJcbiAgICAgICAgaWYgKHBhcnNlZEZpbHRlci5nZXRGaWx0ZXJzKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgZXhpc3RpbmcgcXVlcnkgaWYgbm90IGFkZGluZyBhbnkgbW9yZSBmaWx0ZXJzIChlLmcuIGFuIGVtcHR5XHJcbiAgICAgICAgICAgIC8vIGNvbXBvc2l0ZSBmaWx0ZXIpLlxyXG4gICAgICAgICAgICByZXR1cm4gcXVlcnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbGlkYXRlTmV3RmlsdGVyKHF1ZXJ5Ll9xdWVyeSwgcGFyc2VkRmlsdGVyKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhBZGRlZEZpbHRlcihxdWVyeS5fcXVlcnksIHBhcnNlZEZpbHRlcikpO1xyXG4gICAgfVxyXG4gICAgX2dldFF1ZXJ5Q29uc3RyYWludHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5Q29uc3RyYWludHM7XHJcbiAgICB9XHJcbiAgICBfZ2V0T3BlcmF0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2FuZCcgPyBcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLyA6IFwib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqLztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50fSB0aGF0IGlzIGEgZGlzanVuY3Rpb24gb2ZcclxuICogdGhlIGdpdmVuIGZpbHRlciBjb25zdHJhaW50cy4gQSBkaXNqdW5jdGlvbiBmaWx0ZXIgaW5jbHVkZXMgYSBkb2N1bWVudCBpZiBpdFxyXG4gKiBzYXRpc2ZpZXMgYW55IG9mIHRoZSBnaXZlbiBmaWx0ZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnlDb25zdHJhaW50cyAtIE9wdGlvbmFsLiBUaGUgbGlzdCBvZlxyXG4gKiB7QGxpbmsgUXVlcnlGaWx0ZXJDb25zdHJhaW50fXMgdG8gcGVyZm9ybSBhIGRpc2p1bmN0aW9uIGZvci4gVGhlc2UgbXVzdCBiZVxyXG4gKiBjcmVhdGVkIHdpdGggY2FsbHMgdG8ge0BsaW5rIHdoZXJlfSwge0BsaW5rIG9yfSwgb3Ige0BsaW5rIGFuZH0uXHJcbiAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIHtAbGluayBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnR9LlxyXG4gKi9cclxuZnVuY3Rpb24gb3IoLi4ucXVlcnlDb25zdHJhaW50cykge1xyXG4gICAgLy8gT25seSBzdXBwb3J0IFF1ZXJ5RmlsdGVyQ29uc3RyYWludHNcclxuICAgIHF1ZXJ5Q29uc3RyYWludHMuZm9yRWFjaChxdWVyeUNvbnN0cmFpbnQgPT4gdmFsaWRhdGVRdWVyeUZpbHRlckNvbnN0cmFpbnQoJ29yJywgcXVlcnlDb25zdHJhaW50KSk7XHJcbiAgICByZXR1cm4gUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50Ll9jcmVhdGUoXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovLCBxdWVyeUNvbnN0cmFpbnRzKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50fSB0aGF0IGlzIGEgY29uanVuY3Rpb24gb2ZcclxuICogdGhlIGdpdmVuIGZpbHRlciBjb25zdHJhaW50cy4gQSBjb25qdW5jdGlvbiBmaWx0ZXIgaW5jbHVkZXMgYSBkb2N1bWVudCBpZiBpdFxyXG4gKiBzYXRpc2ZpZXMgYWxsIG9mIHRoZSBnaXZlbiBmaWx0ZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnlDb25zdHJhaW50cyAtIE9wdGlvbmFsLiBUaGUgbGlzdCBvZlxyXG4gKiB7QGxpbmsgUXVlcnlGaWx0ZXJDb25zdHJhaW50fXMgdG8gcGVyZm9ybSBhIGNvbmp1bmN0aW9uIGZvci4gVGhlc2UgbXVzdCBiZVxyXG4gKiBjcmVhdGVkIHdpdGggY2FsbHMgdG8ge0BsaW5rIHdoZXJlfSwge0BsaW5rIG9yfSwgb3Ige0BsaW5rIGFuZH0uXHJcbiAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIHtAbGluayBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnR9LlxyXG4gKi9cclxuZnVuY3Rpb24gYW5kKC4uLnF1ZXJ5Q29uc3RyYWludHMpIHtcclxuICAgIC8vIE9ubHkgc3VwcG9ydCBRdWVyeUZpbHRlckNvbnN0cmFpbnRzXHJcbiAgICBxdWVyeUNvbnN0cmFpbnRzLmZvckVhY2gocXVlcnlDb25zdHJhaW50ID0+IHZhbGlkYXRlUXVlcnlGaWx0ZXJDb25zdHJhaW50KCdhbmQnLCBxdWVyeUNvbnN0cmFpbnQpKTtcclxuICAgIHJldHVybiBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnQuX2NyZWF0ZShcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLywgcXVlcnlDb25zdHJhaW50cyk7XHJcbn1cclxuLyoqXHJcbiAqIEEgYFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnRgIGlzIHVzZWQgdG8gc29ydCB0aGUgc2V0IG9mIGRvY3VtZW50cyByZXR1cm5lZCBieSBhXHJcbiAqIEZpcmVzdG9yZSBxdWVyeS4gYFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZ1xyXG4gKiB7QGxpbmsgb3JkZXJCeX0gYW5kIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYSBuZXcgcXVlcnlcclxuICogaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnRgLlxyXG4gKlxyXG4gKiBOb3RlOiBEb2N1bWVudHMgdGhhdCBkbyBub3QgY29udGFpbiB0aGUgb3JkZXJCeSBmaWVsZCB3aWxsIG5vdCBiZSBwcmVzZW50IGluXHJcbiAqIHRoZSBxdWVyeSByZXN1bHQuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeU9yZGVyQnlDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9maWVsZCwgX2RpcmVjdGlvbikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fZmllbGQgPSBfZmllbGQ7XHJcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gX2RpcmVjdGlvbjtcclxuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBxdWVyeSBjb25zdHJhaW50ICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gJ29yZGVyQnknO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9jcmVhdGUoX2ZpZWxkLCBfZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeU9yZGVyQnlDb25zdHJhaW50KF9maWVsZCwgX2RpcmVjdGlvbik7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICBjb25zdCBvcmRlckJ5ID0gbmV3UXVlcnlPcmRlckJ5KHF1ZXJ5Ll9xdWVyeSwgdGhpcy5fZmllbGQsIHRoaXMuX2RpcmVjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShxdWVyeS5maXJlc3RvcmUsIHF1ZXJ5LmNvbnZlcnRlciwgcXVlcnlXaXRoQWRkZWRPcmRlckJ5KHF1ZXJ5Ll9xdWVyeSwgb3JkZXJCeSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEge0BsaW5rIFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnR9IHRoYXQgc29ydHMgdGhlIHF1ZXJ5IHJlc3VsdCBieSB0aGVcclxuICogc3BlY2lmaWVkIGZpZWxkLCBvcHRpb25hbGx5IGluIGRlc2NlbmRpbmcgb3JkZXIgaW5zdGVhZCBvZiBhc2NlbmRpbmcuXHJcbiAqXHJcbiAqIE5vdGU6IERvY3VtZW50cyB0aGF0IGRvIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgZmllbGQgd2lsbCBub3QgYmUgcHJlc2VudFxyXG4gKiBpbiB0aGUgcXVlcnkgcmVzdWx0LlxyXG4gKlxyXG4gKiBAcGFyYW0gZmllbGRQYXRoIC0gVGhlIGZpZWxkIHRvIHNvcnQgYnkuXHJcbiAqIEBwYXJhbSBkaXJlY3Rpb25TdHIgLSBPcHRpb25hbCBkaXJlY3Rpb24gdG8gc29ydCBieSAoJ2FzYycgb3IgJ2Rlc2MnKS4gSWZcclxuICogbm90IHNwZWNpZmllZCwgb3JkZXIgd2lsbCBiZSBhc2NlbmRpbmcuXHJcbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHtAbGluayBRdWVyeU9yZGVyQnlDb25zdHJhaW50fS5cclxuICovXHJcbmZ1bmN0aW9uIG9yZGVyQnkoZmllbGRQYXRoLCBkaXJlY3Rpb25TdHIgPSAnYXNjJykge1xyXG4gICAgY29uc3QgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyO1xyXG4gICAgY29uc3QgcGF0aCA9IGZpZWxkUGF0aEZyb21Bcmd1bWVudCgnb3JkZXJCeScsIGZpZWxkUGF0aCk7XHJcbiAgICByZXR1cm4gUXVlcnlPcmRlckJ5Q29uc3RyYWludC5fY3JlYXRlKHBhdGgsIGRpcmVjdGlvbik7XHJcbn1cclxuLyoqXHJcbiAqIEEgYFF1ZXJ5TGltaXRDb25zdHJhaW50YCBpcyB1c2VkIHRvIGxpbWl0IHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHJldHVybmVkIGJ5XHJcbiAqIGEgRmlyZXN0b3JlIHF1ZXJ5LlxyXG4gKiBgUXVlcnlMaW1pdENvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgbGltaXR9IG9yXHJcbiAqIHtAbGluayBsaW1pdFRvTGFzdH0gYW5kIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYSBuZXdcclxuICogcXVlcnkgaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5TGltaXRDb25zdHJhaW50YC5cclxuICovXHJcbmNsYXNzIFF1ZXJ5TGltaXRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xyXG4gICAgdHlwZSwgX2xpbWl0LCBfbGltaXRUeXBlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuX2xpbWl0ID0gX2xpbWl0O1xyXG4gICAgICAgIHRoaXMuX2xpbWl0VHlwZSA9IF9saW1pdFR5cGU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2NyZWF0ZSh0eXBlLCBfbGltaXQsIF9saW1pdFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5TGltaXRDb25zdHJhaW50KHR5cGUsIF9saW1pdCwgX2xpbWl0VHlwZSk7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhMaW1pdChxdWVyeS5fcXVlcnksIHRoaXMuX2xpbWl0LCB0aGlzLl9saW1pdFR5cGUpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIHtAbGluayBRdWVyeUxpbWl0Q29uc3RyYWludH0gdGhhdCBvbmx5IHJldHVybnMgdGhlIGZpcnN0IG1hdGNoaW5nXHJcbiAqIGRvY3VtZW50cy5cclxuICpcclxuICogQHBhcmFtIGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIHJldHVybi5cclxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQge0BsaW5rIFF1ZXJ5TGltaXRDb25zdHJhaW50fS5cclxuICovXHJcbmZ1bmN0aW9uIGxpbWl0KGxpbWl0KSB7XHJcbiAgICB2YWxpZGF0ZVBvc2l0aXZlTnVtYmVyKCdsaW1pdCcsIGxpbWl0KTtcclxuICAgIHJldHVybiBRdWVyeUxpbWl0Q29uc3RyYWludC5fY3JlYXRlKCdsaW1pdCcsIGxpbWl0LCBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8pO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEge0BsaW5rIFF1ZXJ5TGltaXRDb25zdHJhaW50fSB0aGF0IG9ubHkgcmV0dXJucyB0aGUgbGFzdCBtYXRjaGluZ1xyXG4gKiBkb2N1bWVudHMuXHJcbiAqXHJcbiAqIFlvdSBtdXN0IHNwZWNpZnkgYXQgbGVhc3Qgb25lIGBvcmRlckJ5YCBjbGF1c2UgZm9yIGBsaW1pdFRvTGFzdGAgcXVlcmllcyxcclxuICogb3RoZXJ3aXNlIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biBkdXJpbmcgZXhlY3V0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdG8gcmV0dXJuLlxyXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCB7QGxpbmsgUXVlcnlMaW1pdENvbnN0cmFpbnR9LlxyXG4gKi9cclxuZnVuY3Rpb24gbGltaXRUb0xhc3QobGltaXQpIHtcclxuICAgIHZhbGlkYXRlUG9zaXRpdmVOdW1iZXIoJ2xpbWl0VG9MYXN0JywgbGltaXQpO1xyXG4gICAgcmV0dXJuIFF1ZXJ5TGltaXRDb25zdHJhaW50Ll9jcmVhdGUoJ2xpbWl0VG9MYXN0JywgbGltaXQsIFwiTFwiIC8qIExpbWl0VHlwZS5MYXN0ICovKTtcclxufVxyXG4vKipcclxuICogQSBgUXVlcnlTdGFydEF0Q29uc3RyYWludGAgaXMgdXNlZCB0byBleGNsdWRlIGRvY3VtZW50cyBmcm9tIHRoZSBzdGFydCBvZiBhXHJcbiAqIHJlc3VsdCBzZXQgcmV0dXJuZWQgYnkgYSBGaXJlc3RvcmUgcXVlcnkuXHJcbiAqIGBRdWVyeVN0YXJ0QXRDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIChzdGFydEF0OjEpfSBvclxyXG4gKiB7QGxpbmsgKHN0YXJ0QWZ0ZXI6MSl9IGFuZCBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGFcclxuICogbmV3IHF1ZXJ5IGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeVN0YXJ0QXRDb25zdHJhaW50YC5cclxuICovXHJcbmNsYXNzIFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBxdWVyeSBjb25zdHJhaW50ICovXHJcbiAgICB0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5fZG9jT3JGaWVsZHMgPSBfZG9jT3JGaWVsZHM7XHJcbiAgICAgICAgdGhpcy5faW5jbHVzaXZlID0gX2luY2x1c2l2ZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfY3JlYXRlKHR5cGUsIF9kb2NPckZpZWxkcywgX2luY2x1c2l2ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlTdGFydEF0Q29uc3RyYWludCh0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3QgYm91bmQgPSBuZXdRdWVyeUJvdW5kRnJvbURvY09yRmllbGRzKHF1ZXJ5LCB0aGlzLnR5cGUsIHRoaXMuX2RvY09yRmllbGRzLCB0aGlzLl9pbmNsdXNpdmUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkocXVlcnkuZmlyZXN0b3JlLCBxdWVyeS5jb252ZXJ0ZXIsIHF1ZXJ5V2l0aFN0YXJ0QXQocXVlcnkuX3F1ZXJ5LCBib3VuZCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHN0YXJ0QXQoLi4uZG9jT3JGaWVsZHMpIHtcclxuICAgIHJldHVybiBRdWVyeVN0YXJ0QXRDb25zdHJhaW50Ll9jcmVhdGUoJ3N0YXJ0QXQnLCBkb2NPckZpZWxkcywgXHJcbiAgICAvKmluY2x1c2l2ZT0qLyB0cnVlKTtcclxufVxyXG5mdW5jdGlvbiBzdGFydEFmdGVyKC4uLmRvY09yRmllbGRzKSB7XHJcbiAgICByZXR1cm4gUXVlcnlTdGFydEF0Q29uc3RyYWludC5fY3JlYXRlKCdzdGFydEFmdGVyJywgZG9jT3JGaWVsZHMsIFxyXG4gICAgLyppbmNsdXNpdmU9Ki8gZmFsc2UpO1xyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeUVuZEF0Q29uc3RyYWludGAgaXMgdXNlZCB0byBleGNsdWRlIGRvY3VtZW50cyBmcm9tIHRoZSBlbmQgb2YgYVxyXG4gKiByZXN1bHQgc2V0IHJldHVybmVkIGJ5IGEgRmlyZXN0b3JlIHF1ZXJ5LlxyXG4gKiBgUXVlcnlFbmRBdENvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgKGVuZEF0OjEpfSBvclxyXG4gKiB7QGxpbmsgKGVuZEJlZm9yZToxKX0gYW5kIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYSBuZXdcclxuICogcXVlcnkgaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5RW5kQXRDb25zdHJhaW50YC5cclxuICovXHJcbmNsYXNzIFF1ZXJ5RW5kQXRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xyXG4gICAgdHlwZSwgX2RvY09yRmllbGRzLCBfaW5jbHVzaXZlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuX2RvY09yRmllbGRzID0gX2RvY09yRmllbGRzO1xyXG4gICAgICAgIHRoaXMuX2luY2x1c2l2ZSA9IF9pbmNsdXNpdmU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2NyZWF0ZSh0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5RW5kQXRDb25zdHJhaW50KHR5cGUsIF9kb2NPckZpZWxkcywgX2luY2x1c2l2ZSk7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICBjb25zdCBib3VuZCA9IG5ld1F1ZXJ5Qm91bmRGcm9tRG9jT3JGaWVsZHMocXVlcnksIHRoaXMudHlwZSwgdGhpcy5fZG9jT3JGaWVsZHMsIHRoaXMuX2luY2x1c2l2ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShxdWVyeS5maXJlc3RvcmUsIHF1ZXJ5LmNvbnZlcnRlciwgcXVlcnlXaXRoRW5kQXQocXVlcnkuX3F1ZXJ5LCBib3VuZCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGVuZEJlZm9yZSguLi5kb2NPckZpZWxkcykge1xyXG4gICAgcmV0dXJuIFF1ZXJ5RW5kQXRDb25zdHJhaW50Ll9jcmVhdGUoJ2VuZEJlZm9yZScsIGRvY09yRmllbGRzLCBcclxuICAgIC8qaW5jbHVzaXZlPSovIGZhbHNlKTtcclxufVxyXG5mdW5jdGlvbiBlbmRBdCguLi5kb2NPckZpZWxkcykge1xyXG4gICAgcmV0dXJuIFF1ZXJ5RW5kQXRDb25zdHJhaW50Ll9jcmVhdGUoJ2VuZEF0JywgZG9jT3JGaWVsZHMsIFxyXG4gICAgLyppbmNsdXNpdmU9Ki8gdHJ1ZSk7XHJcbn1cclxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBib3VuZCBmcm9tIGEgZG9jdW1lbnQgb3IgZmllbGRzICovXHJcbmZ1bmN0aW9uIG5ld1F1ZXJ5Qm91bmRGcm9tRG9jT3JGaWVsZHMocXVlcnksIG1ldGhvZE5hbWUsIGRvY09yRmllbGRzLCBpbmNsdXNpdmUpIHtcclxuICAgIGRvY09yRmllbGRzWzBdID0gZ2V0TW9kdWxhckluc3RhbmNlKGRvY09yRmllbGRzWzBdKTtcclxuICAgIGlmIChkb2NPckZpZWxkc1swXSBpbnN0YW5jZW9mIERvY3VtZW50U25hcHNob3QpIHtcclxuICAgICAgICByZXR1cm4gbmV3UXVlcnlCb3VuZEZyb21Eb2N1bWVudChxdWVyeS5fcXVlcnksIHF1ZXJ5LmZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgbWV0aG9kTmFtZSwgZG9jT3JGaWVsZHNbMF0uX2RvY3VtZW50LCBpbmNsdXNpdmUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIocXVlcnkuZmlyZXN0b3JlKTtcclxuICAgICAgICByZXR1cm4gbmV3UXVlcnlCb3VuZEZyb21GaWVsZHMocXVlcnkuX3F1ZXJ5LCBxdWVyeS5maXJlc3RvcmUuX2RhdGFiYXNlSWQsIHJlYWRlciwgbWV0aG9kTmFtZSwgZG9jT3JGaWVsZHMsIGluY2x1c2l2ZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3UXVlcnlGaWx0ZXIocXVlcnksIG1ldGhvZE5hbWUsIGRhdGFSZWFkZXIsIGRhdGFiYXNlSWQsIGZpZWxkUGF0aCwgb3AsIHZhbHVlKSB7XHJcbiAgICBsZXQgZmllbGRWYWx1ZTtcclxuICAgIGlmIChmaWVsZFBhdGguaXNLZXlGaWVsZCgpKSB7XHJcbiAgICAgICAgaWYgKG9wID09PSBcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi8gfHwgb3AgPT09IFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIFF1ZXJ5LiBZb3UgY2FuJ3QgcGVyZm9ybSAnJHtvcH0nIHF1ZXJpZXMgb24gZG9jdW1lbnRJZCgpLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovIHx8IG9wID09PSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLykge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZURpc2p1bmN0aXZlRmlsdGVyRWxlbWVudHModmFsdWUsIG9wKTtcclxuICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFycmF5VmFsdWUgb2YgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUxpc3QucHVzaChwYXJzZURvY3VtZW50SWRWYWx1ZShkYXRhYmFzZUlkLCBxdWVyeSwgYXJyYXlWYWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSB7IGFycmF5VmFsdWU6IHsgdmFsdWVzOiByZWZlcmVuY2VMaXN0IH0gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBwYXJzZURvY3VtZW50SWRWYWx1ZShkYXRhYmFzZUlkLCBxdWVyeSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovIHx8XHJcbiAgICAgICAgICAgIG9wID09PSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLyB8fFxyXG4gICAgICAgICAgICBvcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi8pIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVEaXNqdW5jdGl2ZUZpbHRlckVsZW1lbnRzKHZhbHVlLCBvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpZWxkVmFsdWUgPSBwYXJzZVF1ZXJ5VmFsdWUoZGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgdmFsdWUsIFxyXG4gICAgICAgIC8qIGFsbG93QXJyYXlzPSAqLyBvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovIHx8IG9wID09PSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmaWx0ZXIgPSBGaWVsZEZpbHRlci5jcmVhdGUoZmllbGRQYXRoLCBvcCwgZmllbGRWYWx1ZSk7XHJcbiAgICByZXR1cm4gZmlsdGVyO1xyXG59XHJcbmZ1bmN0aW9uIG5ld1F1ZXJ5T3JkZXJCeShxdWVyeSwgZmllbGRQYXRoLCBkaXJlY3Rpb24pIHtcclxuICAgIGlmIChxdWVyeS5zdGFydEF0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ludmFsaWQgcXVlcnkuIFlvdSBtdXN0IG5vdCBjYWxsIHN0YXJ0QXQoKSBvciBzdGFydEFmdGVyKCkgYmVmb3JlICcgK1xyXG4gICAgICAgICAgICAnY2FsbGluZyBvcmRlckJ5KCkuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnkuZW5kQXQgIT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBxdWVyeS4gWW91IG11c3Qgbm90IGNhbGwgZW5kQXQoKSBvciBlbmRCZWZvcmUoKSBiZWZvcmUgJyArXHJcbiAgICAgICAgICAgICdjYWxsaW5nIG9yZGVyQnkoKS4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9yZGVyQnkgPSBuZXcgT3JkZXJCeShmaWVsZFBhdGgsIGRpcmVjdGlvbik7XHJcbiAgICByZXR1cm4gb3JkZXJCeTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGEgYEJvdW5kYCBmcm9tIGEgcXVlcnkgYW5kIGEgZG9jdW1lbnQuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGUgYEJvdW5kYCB3aWxsIGFsd2F5cyBpbmNsdWRlIHRoZSBrZXkgb2YgdGhlIGRvY3VtZW50XHJcbiAqIGFuZCBzbyBvbmx5IHRoZSBwcm92aWRlZCBkb2N1bWVudCB3aWxsIGNvbXBhcmUgZXF1YWwgdG8gdGhlIHJldHVybmVkXHJcbiAqIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBXaWxsIHRocm93IGlmIHRoZSBkb2N1bWVudCBkb2VzIG5vdCBjb250YWluIGFsbCBmaWVsZHMgb2YgdGhlIG9yZGVyIGJ5XHJcbiAqIG9mIHRoZSBxdWVyeSBvciBpZiBhbnkgb2YgdGhlIGZpZWxkcyBpbiB0aGUgb3JkZXIgYnkgYXJlIGFuIHVuY29tbWl0dGVkXHJcbiAqIHNlcnZlciB0aW1lc3RhbXAuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdRdWVyeUJvdW5kRnJvbURvY3VtZW50KHF1ZXJ5LCBkYXRhYmFzZUlkLCBtZXRob2ROYW1lLCBkb2MsIGluY2x1c2l2ZSkge1xyXG4gICAgaWYgKCFkb2MpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5OT1RfRk9VTkQsIGBDYW4ndCB1c2UgYSBEb2N1bWVudFNuYXBzaG90IHRoYXQgZG9lc24ndCBleGlzdCBmb3IgYCArXHJcbiAgICAgICAgICAgIGAke21ldGhvZE5hbWV9KCkuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb21wb25lbnRzID0gW107XHJcbiAgICAvLyBCZWNhdXNlIHBlb3BsZSBleHBlY3QgdG8gY29udGludWUvZW5kIGEgcXVlcnkgYXQgdGhlIGV4YWN0IGRvY3VtZW50XHJcbiAgICAvLyBwcm92aWRlZCwgd2UgbmVlZCB0byB1c2UgdGhlIGltcGxpY2l0IHNvcnQgb3JkZXIgcmF0aGVyIHRoYW4gdGhlIGV4cGxpY2l0XHJcbiAgICAvLyBzb3J0IG9yZGVyLCBiZWNhdXNlIGl0J3MgZ3VhcmFudGVlZCB0byBjb250YWluIHRoZSBkb2N1bWVudCBrZXkuIFRoYXQgd2F5XHJcbiAgICAvLyB0aGUgcG9zaXRpb24gYmVjb21lcyB1bmFtYmlndW91cyBhbmQgdGhlIHF1ZXJ5IGNvbnRpbnVlcy9lbmRzIGV4YWN0bHkgYXRcclxuICAgIC8vIHRoZSBwcm92aWRlZCBkb2N1bWVudC4gV2l0aG91dCB0aGUga2V5IChieSB1c2luZyB0aGUgZXhwbGljaXQgc29ydFxyXG4gICAgLy8gb3JkZXJzKSwgbXVsdGlwbGUgZG9jdW1lbnRzIGNvdWxkIG1hdGNoIHRoZSBwb3NpdGlvbiwgeWllbGRpbmcgZHVwbGljYXRlXHJcbiAgICAvLyByZXN1bHRzLlxyXG4gICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpKSB7XHJcbiAgICAgICAgaWYgKG9yZGVyQnkuZmllbGQuaXNLZXlGaWVsZCgpKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChyZWZWYWx1ZShkYXRhYmFzZUlkLCBkb2Mua2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvYy5kYXRhLmZpZWxkKG9yZGVyQnkuZmllbGQpO1xyXG4gICAgICAgICAgICBpZiAoaXNTZXJ2ZXJUaW1lc3RhbXAodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBxdWVyeS4gWW91IGFyZSB0cnlpbmcgdG8gc3RhcnQgb3IgZW5kIGEgcXVlcnkgdXNpbmcgYSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnZG9jdW1lbnQgZm9yIHdoaWNoIHRoZSBmaWVsZCBcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyQnkuZmllbGQgK1xyXG4gICAgICAgICAgICAgICAgICAgICdcIiBpcyBhbiB1bmNvbW1pdHRlZCBzZXJ2ZXIgdGltZXN0YW1wLiAoU2luY2UgdGhlIHZhbHVlIG9mICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICd0aGlzIGZpZWxkIGlzIHVua25vd24sIHlvdSBjYW5ub3Qgc3RhcnQvZW5kIGEgcXVlcnkgd2l0aCBpdC4pJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IG9yZGVyQnkuZmllbGQuY2Fub25pY2FsU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gWW91IGFyZSB0cnlpbmcgdG8gc3RhcnQgb3IgZW5kIGEgcXVlcnkgdXNpbmcgYSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgZG9jdW1lbnQgZm9yIHdoaWNoIHRoZSBmaWVsZCAnJHtmaWVsZH0nICh1c2VkIGFzIHRoZSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgb3JkZXJCeSkgZG9lcyBub3QgZXhpc3QuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEJvdW5kKGNvbXBvbmVudHMsIGluY2x1c2l2ZSk7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgbGlzdCBvZiBmaWVsZCB2YWx1ZXMgdG8gYSBgQm91bmRgIGZvciB0aGUgZ2l2ZW4gcXVlcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdRdWVyeUJvdW5kRnJvbUZpZWxkcyhxdWVyeSwgZGF0YWJhc2VJZCwgZGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgdmFsdWVzLCBpbmNsdXNpdmUpIHtcclxuICAgIC8vIFVzZSBleHBsaWNpdCBvcmRlciBieSdzIGJlY2F1c2UgaXQgaGFzIHRvIG1hdGNoIHRoZSBxdWVyeSB0aGUgdXNlciBtYWRlXHJcbiAgICBjb25zdCBvcmRlckJ5ID0gcXVlcnkuZXhwbGljaXRPcmRlckJ5O1xyXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPiBvcmRlckJ5Lmxlbmd0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBUb28gbWFueSBhcmd1bWVudHMgcHJvdmlkZWQgdG8gJHttZXRob2ROYW1lfSgpLiBgICtcclxuICAgICAgICAgICAgYFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBgICtcclxuICAgICAgICAgICAgYG51bWJlciBvZiBvcmRlckJ5KCkgY2xhdXNlc2ApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29tcG9uZW50cyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCByYXdWYWx1ZSA9IHZhbHVlc1tpXTtcclxuICAgICAgICBjb25zdCBvcmRlckJ5Q29tcG9uZW50ID0gb3JkZXJCeVtpXTtcclxuICAgICAgICBpZiAob3JkZXJCeUNvbXBvbmVudC5maWVsZC5pc0tleUZpZWxkKCkpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByYXdWYWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBFeHBlY3RlZCBhIHN0cmluZyBmb3IgZG9jdW1lbnQgSUQgaW4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYCR7bWV0aG9kTmFtZX0oKSwgYnV0IGdvdCBhICR7dHlwZW9mIHJhd1ZhbHVlfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNDb2xsZWN0aW9uR3JvdXBRdWVyeShxdWVyeSkgJiYgcmF3VmFsdWUuaW5kZXhPZignLycpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIFdoZW4gcXVlcnlpbmcgYSBjb2xsZWN0aW9uIGFuZCBvcmRlcmluZyBieSBkb2N1bWVudElkKCksIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGB0aGUgdmFsdWUgcGFzc2VkIHRvICR7bWV0aG9kTmFtZX0oKSBtdXN0IGJlIGEgcGxhaW4gZG9jdW1lbnQgSUQsIGJ1dCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgJyR7cmF3VmFsdWV9JyBjb250YWlucyBhIHNsYXNoLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBxdWVyeS5wYXRoLmNoaWxkKFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKHJhd1ZhbHVlKSk7XHJcbiAgICAgICAgICAgIGlmICghRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIFdoZW4gcXVlcnlpbmcgYSBjb2xsZWN0aW9uIGdyb3VwIGFuZCBvcmRlcmluZyBieSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgZG9jdW1lbnRJZCgpLCB0aGUgdmFsdWUgcGFzc2VkIHRvICR7bWV0aG9kTmFtZX0oKSBtdXN0IHJlc3VsdCBpbiBhIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGB2YWxpZCBkb2N1bWVudCBwYXRoLCBidXQgJyR7cGF0aH0nIGlzIG5vdCBiZWNhdXNlIGl0IGNvbnRhaW5zIGFuIG9kZCBudW1iZXIgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYG9mIHNlZ21lbnRzLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IG5ldyBEb2N1bWVudEtleShwYXRoKTtcclxuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHJlZlZhbHVlKGRhdGFiYXNlSWQsIGtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgd3JhcHBlZCA9IHBhcnNlUXVlcnlWYWx1ZShkYXRhUmVhZGVyLCBtZXRob2ROYW1lLCByYXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaCh3cmFwcGVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEJvdW5kKGNvbXBvbmVudHMsIGluY2x1c2l2ZSk7XHJcbn1cclxuLyoqXHJcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gYGRvY3VtZW50SWRWYWx1ZWAgaW50byBhIGBSZWZlcmVuY2VWYWx1ZWAsIHRocm93aW5nXHJcbiAqIGFwcHJvcHJpYXRlIGVycm9ycyBpZiB0aGUgdmFsdWUgaXMgYW55dGhpbmcgb3RoZXIgdGhhbiBhIGBEb2N1bWVudFJlZmVyZW5jZWBcclxuICogb3IgYHN0cmluZ2AsIG9yIGlmIHRoZSBzdHJpbmcgaXMgbWFsZm9ybWVkLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VEb2N1bWVudElkVmFsdWUoZGF0YWJhc2VJZCwgcXVlcnksIGRvY3VtZW50SWRWYWx1ZSkge1xyXG4gICAgZG9jdW1lbnRJZFZhbHVlID0gZ2V0TW9kdWxhckluc3RhbmNlKGRvY3VtZW50SWRWYWx1ZSk7XHJcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50SWRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnRJZFZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyB3aXRoIGRvY3VtZW50SWQoKSwgeW91ICcgK1xyXG4gICAgICAgICAgICAgICAgJ211c3QgcHJvdmlkZSBhIHZhbGlkIGRvY3VtZW50IElELCBidXQgaXQgd2FzIGFuIGVtcHR5IHN0cmluZy4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0NvbGxlY3Rpb25Hcm91cFF1ZXJ5KHF1ZXJ5KSAmJiBkb2N1bWVudElkVmFsdWUuaW5kZXhPZignLycpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyBhIGNvbGxlY3Rpb24gYnkgYCArXHJcbiAgICAgICAgICAgICAgICBgZG9jdW1lbnRJZCgpLCB5b3UgbXVzdCBwcm92aWRlIGEgcGxhaW4gZG9jdW1lbnQgSUQsIGJ1dCBgICtcclxuICAgICAgICAgICAgICAgIGAnJHtkb2N1bWVudElkVmFsdWV9JyBjb250YWlucyBhICcvJyBjaGFyYWN0ZXIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhdGggPSBxdWVyeS5wYXRoLmNoaWxkKFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKGRvY3VtZW50SWRWYWx1ZSkpO1xyXG4gICAgICAgIGlmICghRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShwYXRoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyBhIGNvbGxlY3Rpb24gZ3JvdXAgYnkgYCArXHJcbiAgICAgICAgICAgICAgICBgZG9jdW1lbnRJZCgpLCB0aGUgdmFsdWUgcHJvdmlkZWQgbXVzdCByZXN1bHQgaW4gYSB2YWxpZCBkb2N1bWVudCBwYXRoLCBgICtcclxuICAgICAgICAgICAgICAgIGBidXQgJyR7cGF0aH0nIGlzIG5vdCBiZWNhdXNlIGl0IGhhcyBhbiBvZGQgbnVtYmVyIG9mIHNlZ21lbnRzICgke3BhdGgubGVuZ3RofSkuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWZWYWx1ZShkYXRhYmFzZUlkLCBuZXcgRG9jdW1lbnRLZXkocGF0aCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZG9jdW1lbnRJZFZhbHVlIGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpIHtcclxuICAgICAgICByZXR1cm4gcmVmVmFsdWUoZGF0YWJhc2VJZCwgZG9jdW1lbnRJZFZhbHVlLl9rZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIFdoZW4gcXVlcnlpbmcgd2l0aCBkb2N1bWVudElkKCksIHlvdSBtdXN0IHByb3ZpZGUgYSB2YWxpZCBgICtcclxuICAgICAgICAgICAgYHN0cmluZyBvciBhIERvY3VtZW50UmVmZXJlbmNlLCBidXQgaXQgd2FzOiBgICtcclxuICAgICAgICAgICAgYCR7dmFsdWVEZXNjcmlwdGlvbihkb2N1bWVudElkVmFsdWUpfS5gKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIHBhc3NlZCBpbnRvIGEgZGlzanVuY3RpdmUgZmlsdGVyIHNhdGlzZmllcyBhbGxcclxuICogYXJyYXkgcmVxdWlyZW1lbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVEaXNqdW5jdGl2ZUZpbHRlckVsZW1lbnRzKHZhbHVlLCBvcGVyYXRvcikge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBRdWVyeS4gQSBub24tZW1wdHkgYXJyYXkgaXMgcmVxdWlyZWQgZm9yICcgK1xyXG4gICAgICAgICAgICBgJyR7b3BlcmF0b3IudG9TdHJpbmcoKX0nIGZpbHRlcnMuYCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGFuIG9wZXJhdG9yLCByZXR1cm5zIHRoZSBzZXQgb2Ygb3BlcmF0b3JzIHRoYXQgY2Fubm90IGJlIHVzZWQgd2l0aCBpdC5cclxuICpcclxuICogVGhpcyBpcyBub3QgYSBjb21wcmVoZW5zaXZlIGNoZWNrLCBhbmQgdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgcmVtb3ZlZCBpbiB0aGVcclxuICogbG9uZyB0ZXJtLiBWYWxpZGF0aW9ucyBzaG91bGQgb2NjdXIgaW4gdGhlIEZpcmVzdG9yZSBiYWNrZW5kLlxyXG4gKlxyXG4gKiBPcGVyYXRvcnMgaW4gYSBxdWVyeSBtdXN0IGFkaGVyZSB0byB0aGUgZm9sbG93aW5nIHNldCBvZiBydWxlczpcclxuICogMS4gT25seSBvbmUgaW5lcXVhbGl0eSBwZXIgcXVlcnkuXHJcbiAqIDIuIGBOT1RfSU5gIGNhbm5vdCBiZSB1c2VkIHdpdGggYXJyYXksIGRpc2p1bmN0aXZlLCBvciBgTk9UX0VRVUFMYCBvcGVyYXRvcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25mbGljdGluZ09wcyhvcCkge1xyXG4gICAgc3dpdGNoIChvcCkge1xyXG4gICAgICAgIGNhc2UgXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovLCBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqL107XHJcbiAgICAgICAgY2FzZSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLzpcclxuICAgICAgICBjYXNlIFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqL107XHJcbiAgICAgICAgY2FzZSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovLFxyXG4gICAgICAgICAgICAgICAgXCJpblwiIC8qIE9wZXJhdG9yLklOICovLFxyXG4gICAgICAgICAgICAgICAgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8sXHJcbiAgICAgICAgICAgICAgICBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlTmV3RmllbGRGaWx0ZXIocXVlcnksIGZpZWxkRmlsdGVyKSB7XHJcbiAgICBjb25zdCBjb25mbGljdGluZ09wID0gZmluZE9wSW5zaWRlRmlsdGVycyhxdWVyeS5maWx0ZXJzLCBjb25mbGljdGluZ09wcyhmaWVsZEZpbHRlci5vcCkpO1xyXG4gICAgaWYgKGNvbmZsaWN0aW5nT3AgIT09IG51bGwpIHtcclxuICAgICAgICAvLyBTcGVjaWFsIGNhc2Ugd2hlbiBpdCdzIGEgZHVwbGljYXRlIG9wIHRvIGdpdmUgYSBzbGlnaHRseSBjbGVhcmVyIGVycm9yIG1lc3NhZ2UuXHJcbiAgICAgICAgaWYgKGNvbmZsaWN0aW5nT3AgPT09IGZpZWxkRmlsdGVyLm9wKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIHF1ZXJ5LiBZb3UgY2Fubm90IHVzZSBtb3JlIHRoYW4gb25lICcgK1xyXG4gICAgICAgICAgICAgICAgYCcke2ZpZWxkRmlsdGVyLm9wLnRvU3RyaW5nKCl9JyBmaWx0ZXIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gWW91IGNhbm5vdCB1c2UgJyR7ZmllbGRGaWx0ZXIub3AudG9TdHJpbmcoKX0nIGZpbHRlcnMgYCArXHJcbiAgICAgICAgICAgICAgICBgd2l0aCAnJHtjb25mbGljdGluZ09wLnRvU3RyaW5nKCl9JyBmaWx0ZXJzLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZU5ld0ZpbHRlcihxdWVyeSwgZmlsdGVyKSB7XHJcbiAgICBsZXQgdGVzdFF1ZXJ5ID0gcXVlcnk7XHJcbiAgICBjb25zdCBzdWJGaWx0ZXJzID0gZmlsdGVyLmdldEZsYXR0ZW5lZEZpbHRlcnMoKTtcclxuICAgIGZvciAoY29uc3Qgc3ViRmlsdGVyIG9mIHN1YkZpbHRlcnMpIHtcclxuICAgICAgICB2YWxpZGF0ZU5ld0ZpZWxkRmlsdGVyKHRlc3RRdWVyeSwgc3ViRmlsdGVyKTtcclxuICAgICAgICB0ZXN0UXVlcnkgPSBxdWVyeVdpdGhBZGRlZEZpbHRlcih0ZXN0UXVlcnksIHN1YkZpbHRlcik7XHJcbiAgICB9XHJcbn1cclxuLy8gQ2hlY2tzIGlmIGFueSBvZiB0aGUgcHJvdmlkZWQgZmlsdGVyIG9wZXJhdG9ycyBhcmUgaW5jbHVkZWQgaW4gdGhlIGdpdmVuIGxpc3Qgb2YgZmlsdGVycyBhbmRcclxuLy8gcmV0dXJucyB0aGUgZmlyc3Qgb25lIHRoYXQgaXMsIG9yIG51bGwgaWYgbm9uZSBhcmUuXHJcbmZ1bmN0aW9uIGZpbmRPcEluc2lkZUZpbHRlcnMoZmlsdGVycywgb3BlcmF0b3JzKSB7XHJcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBmaWx0ZXJzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZEZpbHRlciBvZiBmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpKSB7XHJcbiAgICAgICAgICAgIGlmIChvcGVyYXRvcnMuaW5kZXhPZihmaWVsZEZpbHRlci5vcCkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkRmlsdGVyLm9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVRdWVyeUZpbHRlckNvbnN0cmFpbnQoZnVuY3Rpb25OYW1lLCBxdWVyeUNvbnN0cmFpbnQpIHtcclxuICAgIGlmICghKHF1ZXJ5Q29uc3RyYWludCBpbnN0YW5jZW9mIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50KSAmJlxyXG4gICAgICAgICEocXVlcnlDb25zdHJhaW50IGluc3RhbmNlb2YgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBGdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0oKSByZXF1aXJlcyBBcHBsaWFibGVDb25zdHJhaW50cyBjcmVhdGVkIHdpdGggYSBjYWxsIHRvICd3aGVyZSguLi4pJywgJ29yKC4uLiknLCBvciAnYW5kKC4uLiknLmApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlUXVlcnlDb25zdHJhaW50QXJyYXkocXVlcnlDb25zdHJhaW50KSB7XHJcbiAgICBjb25zdCBjb21wb3NpdGVGaWx0ZXJDb3VudCA9IHF1ZXJ5Q29uc3RyYWludC5maWx0ZXIoZmlsdGVyID0+IGZpbHRlciBpbnN0YW5jZW9mIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCkubGVuZ3RoO1xyXG4gICAgY29uc3QgZmllbGRGaWx0ZXJDb3VudCA9IHF1ZXJ5Q29uc3RyYWludC5maWx0ZXIoZmlsdGVyID0+IGZpbHRlciBpbnN0YW5jZW9mIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50KS5sZW5ndGg7XHJcbiAgICBpZiAoY29tcG9zaXRlRmlsdGVyQ291bnQgPiAxIHx8XHJcbiAgICAgICAgKGNvbXBvc2l0ZUZpbHRlckNvdW50ID4gMCAmJiBmaWVsZEZpbHRlckNvdW50ID4gMCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZFF1ZXJ5LiBXaGVuIHVzaW5nIGNvbXBvc2l0ZSBmaWx0ZXJzLCB5b3UgY2Fubm90IHVzZSAnICtcclxuICAgICAgICAgICAgJ21vcmUgdGhhbiBvbmUgZmlsdGVyIGF0IHRoZSB0b3AgbGV2ZWwuIENvbnNpZGVyIG5lc3RpbmcgdGhlIG11bHRpcGxlICcgK1xyXG4gICAgICAgICAgICAnZmlsdGVycyB3aXRoaW4gYW4gYGFuZCguLi4pYCBzdGF0ZW1lbnQuIEZvciBleGFtcGxlOiAnICtcclxuICAgICAgICAgICAgJ2NoYW5nZSBgcXVlcnkocXVlcnksIHdoZXJlKC4uLiksIG9yKC4uLikpYCB0byAnICtcclxuICAgICAgICAgICAgJ2BxdWVyeShxdWVyeSwgYW5kKHdoZXJlKC4uLiksIG9yKC4uLikpKWAuJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENvbnZlcnRzIEZpcmVzdG9yZSdzIGludGVybmFsIHR5cGVzIHRvIHRoZSBKYXZhU2NyaXB0IHR5cGVzIHRoYXQgd2UgZXhwb3NlXHJcbiAqIHRvIHRoZSB1c2VyLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIEFic3RyYWN0VXNlckRhdGFXcml0ZXIge1xyXG4gICAgY29udmVydFZhbHVlKHZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvciA9ICdub25lJykge1xyXG4gICAgICAgIHN3aXRjaCAodHlwZU9yZGVyKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBjYXNlIDAgLyogVHlwZU9yZGVyLk51bGxWYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogVHlwZU9yZGVyLkJvb2xlYW5WYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5ib29sZWFuVmFsdWU7XHJcbiAgICAgICAgICAgIGNhc2UgMiAvKiBUeXBlT3JkZXIuTnVtYmVyVmFsdWUgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplTnVtYmVyKHZhbHVlLmludGVnZXJWYWx1ZSB8fCB2YWx1ZS5kb3VibGVWYWx1ZSk7XHJcbiAgICAgICAgICAgIGNhc2UgMyAvKiBUeXBlT3JkZXIuVGltZXN0YW1wVmFsdWUgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VGltZXN0YW1wKHZhbHVlLnRpbWVzdGFtcFZhbHVlKTtcclxuICAgICAgICAgICAgY2FzZSA0IC8qIFR5cGVPcmRlci5TZXJ2ZXJUaW1lc3RhbXBWYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTZXJ2ZXJUaW1lc3RhbXAodmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKTtcclxuICAgICAgICAgICAgY2FzZSA1IC8qIFR5cGVPcmRlci5TdHJpbmdWYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zdHJpbmdWYWx1ZTtcclxuICAgICAgICAgICAgY2FzZSA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0Qnl0ZXMobm9ybWFsaXplQnl0ZVN0cmluZyh2YWx1ZS5ieXRlc1ZhbHVlKSk7XHJcbiAgICAgICAgICAgIGNhc2UgNyAvKiBUeXBlT3JkZXIuUmVmVmFsdWUgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0UmVmZXJlbmNlKHZhbHVlLnJlZmVyZW5jZVZhbHVlKTtcclxuICAgICAgICAgICAgY2FzZSA4IC8qIFR5cGVPcmRlci5HZW9Qb2ludFZhbHVlICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydEdlb1BvaW50KHZhbHVlLmdlb1BvaW50VmFsdWUpO1xyXG4gICAgICAgICAgICBjYXNlIDkgLyogVHlwZU9yZGVyLkFycmF5VmFsdWUgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0QXJyYXkodmFsdWUuYXJyYXlWYWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xyXG4gICAgICAgICAgICBjYXNlIDEwIC8qIFR5cGVPcmRlci5PYmplY3RWYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRPYmplY3QodmFsdWUubWFwVmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0T2JqZWN0KG1hcFZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRPYmplY3RNYXAobWFwVmFsdWUuZmllbGRzLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0T2JqZWN0TWFwKGZpZWxkcywgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IgPSAnbm9uZScpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgICAgICBmb3JFYWNoKGZpZWxkcywgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0aGlzLmNvbnZlcnRWYWx1ZSh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0R2VvUG9pbnQodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEdlb1BvaW50KG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5sYXRpdHVkZSksIG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5sb25naXR1ZGUpKTtcclxuICAgIH1cclxuICAgIGNvbnZlcnRBcnJheShhcnJheVZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcikge1xyXG4gICAgICAgIHJldHVybiAoYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pLm1hcCh2YWx1ZSA9PiB0aGlzLmNvbnZlcnRWYWx1ZSh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpKTtcclxuICAgIH1cclxuICAgIGNvbnZlcnRTZXJ2ZXJUaW1lc3RhbXAodmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKSB7XHJcbiAgICAgICAgc3dpdGNoIChzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcikge1xyXG4gICAgICAgICAgICBjYXNlICdwcmV2aW91cyc6XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gZ2V0UHJldmlvdXNWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VmFsdWUocHJldmlvdXNWYWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xyXG4gICAgICAgICAgICBjYXNlICdlc3RpbWF0ZSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VGltZXN0YW1wKGdldExvY2FsV3JpdGVUaW1lKHZhbHVlKSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0VGltZXN0YW1wKHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gbm9ybWFsaXplVGltZXN0YW1wKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChub3JtYWxpemVkVmFsdWUuc2Vjb25kcywgbm9ybWFsaXplZFZhbHVlLm5hbm9zKTtcclxuICAgIH1cclxuICAgIGNvbnZlcnREb2N1bWVudEtleShuYW1lLCBleHBlY3RlZERhdGFiYXNlSWQpIHtcclxuICAgICAgICBjb25zdCByZXNvdXJjZVBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhuYW1lKTtcclxuICAgICAgICBoYXJkQXNzZXJ0KGlzVmFsaWRSZXNvdXJjZU5hbWUocmVzb3VyY2VQYXRoKSk7XHJcbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IG5ldyBEYXRhYmFzZUlkKHJlc291cmNlUGF0aC5nZXQoMSksIHJlc291cmNlUGF0aC5nZXQoMykpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBEb2N1bWVudEtleShyZXNvdXJjZVBhdGgucG9wRmlyc3QoNSkpO1xyXG4gICAgICAgIGlmICghZGF0YWJhc2VJZC5pc0VxdWFsKGV4cGVjdGVkRGF0YWJhc2VJZCkpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyhiLzY0MTMwMjAyKTogU29tZWhvdyBzdXBwb3J0IGZvcmVpZ24gcmVmZXJlbmNlcy5cclxuICAgICAgICAgICAgbG9nRXJyb3IoYERvY3VtZW50ICR7a2V5fSBjb250YWlucyBhIGRvY3VtZW50IGAgK1xyXG4gICAgICAgICAgICAgICAgYHJlZmVyZW5jZSB3aXRoaW4gYSBkaWZmZXJlbnQgZGF0YWJhc2UgKGAgK1xyXG4gICAgICAgICAgICAgICAgYCR7ZGF0YWJhc2VJZC5wcm9qZWN0SWR9LyR7ZGF0YWJhc2VJZC5kYXRhYmFzZX0pIHdoaWNoIGlzIG5vdCBgICtcclxuICAgICAgICAgICAgICAgIGBzdXBwb3J0ZWQuIEl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHJlZmVyZW5jZSBpbiB0aGUgY3VycmVudCBgICtcclxuICAgICAgICAgICAgICAgIGBkYXRhYmFzZSAoJHtleHBlY3RlZERhdGFiYXNlSWQucHJvamVjdElkfS8ke2V4cGVjdGVkRGF0YWJhc2VJZC5kYXRhYmFzZX0pIGAgK1xyXG4gICAgICAgICAgICAgICAgYGluc3RlYWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENvbnZlcnRzIGN1c3RvbSBtb2RlbCBvYmplY3Qgb2YgdHlwZSBUIGludG8gYERvY3VtZW50RGF0YWAgYnkgYXBwbHlpbmcgdGhlXHJcbiAqIGNvbnZlcnRlciBpZiBpdCBleGlzdHMuXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIGNvbnZlcnRpbmcgdXNlciBvYmplY3RzIHRvIGBEb2N1bWVudERhdGFgXHJcbiAqIGJlY2F1c2Ugd2Ugd2FudCB0byBwcm92aWRlIHRoZSB1c2VyIHdpdGggYSBtb3JlIHNwZWNpZmljIGVycm9yIG1lc3NhZ2UgaWZcclxuICogdGhlaXIgYHNldCgpYCBvciBmYWlscyBkdWUgdG8gaW52YWxpZCBkYXRhIG9yaWdpbmF0aW5nIGZyb20gYSBgdG9GaXJlc3RvcmUoKWBcclxuICogY2FsbC5cclxuICovXHJcbmZ1bmN0aW9uIGFwcGx5RmlyZXN0b3JlRGF0YUNvbnZlcnRlcihjb252ZXJ0ZXIsIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICBsZXQgY29udmVydGVkVmFsdWU7XHJcbiAgICBpZiAoY29udmVydGVyKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMubWVyZ2UgfHwgb3B0aW9ucy5tZXJnZUZpZWxkcykpIHtcclxuICAgICAgICAgICAgLy8gQ2FzdCB0byBgYW55YCBpbiBvcmRlciB0byBzYXRpc2Z5IHRoZSB1bmlvbiB0eXBlIGNvbnN0cmFpbnQgb25cclxuICAgICAgICAgICAgLy8gdG9GaXJlc3RvcmUoKS5cclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgY29udmVydGVkVmFsdWUgPSBjb252ZXJ0ZXIudG9GaXJlc3RvcmUodmFsdWUsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29udmVydGVkVmFsdWUgPSBjb252ZXJ0ZXIudG9GaXJlc3RvcmUodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnZlcnRlZFZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udmVydGVkVmFsdWU7XHJcbn1cclxuY2xhc3MgTGl0ZVVzZXJEYXRhV3JpdGVyIGV4dGVuZHMgQWJzdHJhY3RVc2VyRGF0YVdyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaXJlc3RvcmUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZmlyZXN0b3JlID0gZmlyZXN0b3JlO1xyXG4gICAgfVxyXG4gICAgY29udmVydEJ5dGVzKGJ5dGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlcyhieXRlcyk7XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0UmVmZXJlbmNlKG5hbWUpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmNvbnZlcnREb2N1bWVudEtleShuYW1lLCB0aGlzLmZpcmVzdG9yZS5fZGF0YWJhc2VJZCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFJlZmVyZW5jZSh0aGlzLmZpcmVzdG9yZSwgLyogY29udmVydGVyPSAqLyBudWxsLCBrZXkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWFkcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhlIHNwZWNpZmllZCBkb2N1bWVudCByZWZlcmVuY2UuXHJcbiAqXHJcbiAqIEFsbCBkb2N1bWVudHMgYXJlIGRpcmVjdGx5IGZldGNoZWQgZnJvbSB0aGUgc2VydmVyLCBldmVuIGlmIHRoZSBkb2N1bWVudCB3YXNcclxuICogcHJldmlvdXNseSByZWFkIG9yIG1vZGlmaWVkLiBSZWNlbnQgbW9kaWZpY2F0aW9ucyBhcmUgb25seSByZWZsZWN0ZWQgaW4gdGhlXHJcbiAqIHJldHJpZXZlZCBgRG9jdW1lbnRTbmFwc2hvdGAgaWYgdGhleSBoYXZlIGFscmVhZHkgYmVlbiBhcHBsaWVkIGJ5IHRoZVxyXG4gKiBiYWNrZW5kLiBJZiB0aGUgY2xpZW50IGlzIG9mZmxpbmUsIHRoZSByZWFkIGZhaWxzLiBJZiB5b3UgbGlrZSB0byB1c2VcclxuICogY2FjaGluZyBvciBzZWUgbG9jYWwgbW9kaWZpY2F0aW9ucywgcGxlYXNlIHVzZSB0aGUgZnVsbCBGaXJlc3RvcmUgU0RLLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBvZiB0aGUgZG9jdW1lbnQgdG8gZmV0Y2guXHJcbiAqIEByZXR1cm5zIEEgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGEgYERvY3VtZW50U25hcHNob3RgIGNvbnRhaW5pbmcgdGhlIGN1cnJlbnRcclxuICogZG9jdW1lbnQgY29udGVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREb2MocmVmZXJlbmNlKSB7XHJcbiAgICByZWZlcmVuY2UgPSBjYXN0KHJlZmVyZW5jZSwgRG9jdW1lbnRSZWZlcmVuY2UpO1xyXG4gICAgY29uc3QgZGF0YXN0b3JlID0gZ2V0RGF0YXN0b3JlKHJlZmVyZW5jZS5maXJlc3RvcmUpO1xyXG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgTGl0ZVVzZXJEYXRhV3JpdGVyKHJlZmVyZW5jZS5maXJlc3RvcmUpO1xyXG4gICAgcmV0dXJuIGludm9rZUJhdGNoR2V0RG9jdW1lbnRzUnBjKGRhdGFzdG9yZSwgW3JlZmVyZW5jZS5fa2V5XSkudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgIGhhcmRBc3NlcnQocmVzdWx0Lmxlbmd0aCA9PT0gMSk7XHJcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSByZXN1bHRbMF07XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFNuYXBzaG90KHJlZmVyZW5jZS5maXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCByZWZlcmVuY2UuX2tleSwgZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkgPyBkb2N1bWVudCA6IG51bGwsIHJlZmVyZW5jZS5jb252ZXJ0ZXIpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cyBhcyBhIHtAbGluayBRdWVyeVNuYXBzaG90fS5cclxuICpcclxuICogQWxsIHF1ZXJpZXMgYXJlIGV4ZWN1dGVkIGRpcmVjdGx5IGJ5IHRoZSBzZXJ2ZXIsIGV2ZW4gaWYgdGhlIHRoZSBxdWVyeSB3YXNcclxuICogcHJldmlvdXNseSBleGVjdXRlZC4gUmVjZW50IG1vZGlmaWNhdGlvbnMgYXJlIG9ubHkgcmVmbGVjdGVkIGluIHRoZSByZXRyaWV2ZWRcclxuICogcmVzdWx0cyBpZiB0aGV5IGhhdmUgYWxyZWFkeSBiZWVuIGFwcGxpZWQgYnkgdGhlIGJhY2tlbmQuIElmIHRoZSBjbGllbnQgaXNcclxuICogb2ZmbGluZSwgdGhlIG9wZXJhdGlvbiBmYWlscy4gVG8gc2VlIHByZXZpb3VzbHkgY2FjaGVkIHJlc3VsdCBhbmQgbG9jYWxcclxuICogbW9kaWZpY2F0aW9ucywgdXNlIHRoZSBmdWxsIEZpcmVzdG9yZSBTREsuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBgUXVlcnlgIHRvIGV4ZWN1dGUuXHJcbiAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiB0aGUgcXVlcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREb2NzKHF1ZXJ5KSB7XHJcbiAgICBxdWVyeSA9IGNhc3QocXVlcnksIFF1ZXJ5KTtcclxuICAgIHZhbGlkYXRlSGFzRXhwbGljaXRPcmRlckJ5Rm9yTGltaXRUb0xhc3QocXVlcnkuX3F1ZXJ5KTtcclxuICAgIGNvbnN0IGRhdGFzdG9yZSA9IGdldERhdGFzdG9yZShxdWVyeS5maXJlc3RvcmUpO1xyXG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgTGl0ZVVzZXJEYXRhV3JpdGVyKHF1ZXJ5LmZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gaW52b2tlUnVuUXVlcnlScGMoZGF0YXN0b3JlLCBxdWVyeS5fcXVlcnkpLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICBjb25zdCBkb2NzID0gcmVzdWx0Lm1hcChkb2MgPT4gbmV3IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdChxdWVyeS5maXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCBkb2Mua2V5LCBkb2MsIHF1ZXJ5LmNvbnZlcnRlcikpO1xyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnkubGltaXRUeXBlID09PSBcIkxcIiAvKiBMaW1pdFR5cGUuTGFzdCAqLykge1xyXG4gICAgICAgICAgICAvLyBMaW1pdCB0byBsYXN0IHF1ZXJpZXMgcmV2ZXJzZSB0aGUgb3JkZXJCeSBjb25zdHJhaW50IHRoYXQgd2FzXHJcbiAgICAgICAgICAgIC8vIHNwZWNpZmllZCBieSB0aGUgdXNlci4gQXMgc3VjaCwgd2UgbmVlZCB0byByZXZlcnNlIHRoZSBvcmRlciBvZiB0aGVcclxuICAgICAgICAgICAgLy8gcmVzdWx0cyB0byByZXR1cm4gdGhlIGRvY3VtZW50cyBpbiB0aGUgZXhwZWN0ZWQgb3JkZXIuXHJcbiAgICAgICAgICAgIGRvY3MucmV2ZXJzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5U25hcHNob3QocXVlcnksIGRvY3MpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gc2V0RG9jKHJlZmVyZW5jZSwgZGF0YSwgb3B0aW9ucykge1xyXG4gICAgcmVmZXJlbmNlID0gY2FzdChyZWZlcmVuY2UsIERvY3VtZW50UmVmZXJlbmNlKTtcclxuICAgIGNvbnN0IGNvbnZlcnRlZFZhbHVlID0gYXBwbHlGaXJlc3RvcmVEYXRhQ29udmVydGVyKHJlZmVyZW5jZS5jb252ZXJ0ZXIsIGRhdGEsIG9wdGlvbnMpO1xyXG4gICAgY29uc3QgZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKHJlZmVyZW5jZS5maXJlc3RvcmUpO1xyXG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VTZXREYXRhKGRhdGFSZWFkZXIsICdzZXREb2MnLCByZWZlcmVuY2UuX2tleSwgY29udmVydGVkVmFsdWUsIHJlZmVyZW5jZS5jb252ZXJ0ZXIgIT09IG51bGwsIG9wdGlvbnMpO1xyXG4gICAgY29uc3QgZGF0YXN0b3JlID0gZ2V0RGF0YXN0b3JlKHJlZmVyZW5jZS5maXJlc3RvcmUpO1xyXG4gICAgcmV0dXJuIGludm9rZUNvbW1pdFJwYyhkYXRhc3RvcmUsIFtcclxuICAgICAgICBwYXJzZWQudG9NdXRhdGlvbihyZWZlcmVuY2UuX2tleSwgUHJlY29uZGl0aW9uLm5vbmUoKSlcclxuICAgIF0pO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZURvYyhyZWZlcmVuY2UsIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgLi4ubW9yZUZpZWxkc0FuZFZhbHVlcykge1xyXG4gICAgcmVmZXJlbmNlID0gY2FzdChyZWZlcmVuY2UsIERvY3VtZW50UmVmZXJlbmNlKTtcclxuICAgIGNvbnN0IGRhdGFSZWFkZXIgPSBuZXdVc2VyRGF0YVJlYWRlcihyZWZlcmVuY2UuZmlyZXN0b3JlKTtcclxuICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXHJcbiAgICAvLyBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXHJcbiAgICBmaWVsZE9yVXBkYXRlRGF0YSA9IGdldE1vZHVsYXJJbnN0YW5jZShmaWVsZE9yVXBkYXRlRGF0YSk7XHJcbiAgICBsZXQgcGFyc2VkO1xyXG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yVXBkYXRlRGF0YSA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgICBmaWVsZE9yVXBkYXRlRGF0YSBpbnN0YW5jZW9mIEZpZWxkUGF0aCkge1xyXG4gICAgICAgIHBhcnNlZCA9IHBhcnNlVXBkYXRlVmFyYXJncyhkYXRhUmVhZGVyLCAndXBkYXRlRG9jJywgcmVmZXJlbmNlLl9rZXksIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgbW9yZUZpZWxkc0FuZFZhbHVlcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZURhdGEoZGF0YVJlYWRlciwgJ3VwZGF0ZURvYycsIHJlZmVyZW5jZS5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhc3RvcmUgPSBnZXREYXRhc3RvcmUocmVmZXJlbmNlLmZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gaW52b2tlQ29tbWl0UnBjKGRhdGFzdG9yZSwgW1xyXG4gICAgICAgIHBhcnNlZC50b011dGF0aW9uKHJlZmVyZW5jZS5fa2V5LCBQcmVjb25kaXRpb24uZXhpc3RzKHRydWUpKVxyXG4gICAgXSk7XHJcbn1cclxuLyoqXHJcbiAqIERlbGV0ZXMgdGhlIGRvY3VtZW50IHJlZmVycmVkIHRvIGJ5IHRoZSBzcGVjaWZpZWQgYERvY3VtZW50UmVmZXJlbmNlYC5cclxuICpcclxuICogVGhlIGRlbGV0aW9uIHdpbGwgb25seSBiZSByZWZsZWN0ZWQgaW4gZG9jdW1lbnQgcmVhZHMgdGhhdCBvY2N1ciBhZnRlciB0aGVcclxuICogcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcy4gSWYgdGhlIGNsaWVudCBpcyBvZmZsaW5lLCB0aGVcclxuICogZGVsZXRlIGZhaWxzLiBJZiB5b3Ugd291bGQgbGlrZSB0byBzZWUgbG9jYWwgbW9kaWZpY2F0aW9ucyBvciBidWZmZXIgd3JpdGVzXHJcbiAqIHVudGlsIHRoZSBjbGllbnQgaXMgb25saW5lLCB1c2UgdGhlIGZ1bGwgRmlyZXN0b3JlIFNESy5cclxuICpcclxuICogQHBhcmFtIHJlZmVyZW5jZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0byBkZWxldGUuXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHJlc29sdmVkIG9uY2UgdGhlIGRvY3VtZW50IGhhcyBiZWVuIHN1Y2Nlc3NmdWxseVxyXG4gKiBkZWxldGVkIGZyb20gdGhlIGJhY2tlbmQuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWxldGVEb2MocmVmZXJlbmNlKSB7XHJcbiAgICByZWZlcmVuY2UgPSBjYXN0KHJlZmVyZW5jZSwgRG9jdW1lbnRSZWZlcmVuY2UpO1xyXG4gICAgY29uc3QgZGF0YXN0b3JlID0gZ2V0RGF0YXN0b3JlKHJlZmVyZW5jZS5maXJlc3RvcmUpO1xyXG4gICAgcmV0dXJuIGludm9rZUNvbW1pdFJwYyhkYXRhc3RvcmUsIFtcclxuICAgICAgICBuZXcgRGVsZXRlTXV0YXRpb24ocmVmZXJlbmNlLl9rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpXHJcbiAgICBdKTtcclxufVxyXG4vKipcclxuICogQWRkIGEgbmV3IGRvY3VtZW50IHRvIHNwZWNpZmllZCBgQ29sbGVjdGlvblJlZmVyZW5jZWAgd2l0aCB0aGUgZ2l2ZW4gZGF0YSxcclxuICogYXNzaWduaW5nIGl0IGEgZG9jdW1lbnQgSUQgYXV0b21hdGljYWxseS5cclxuICpcclxuICogVGhlIHJlc3VsdCBvZiB0aGlzIHdyaXRlIHdpbGwgb25seSBiZSByZWZsZWN0ZWQgaW4gZG9jdW1lbnQgcmVhZHMgdGhhdCBvY2N1clxyXG4gKiBhZnRlciB0aGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcy4gSWYgdGhlIGNsaWVudCBpcyBvZmZsaW5lLCB0aGVcclxuICogd3JpdGUgZmFpbHMuIElmIHlvdSB3b3VsZCBsaWtlIHRvIHNlZSBsb2NhbCBtb2RpZmljYXRpb25zIG9yIGJ1ZmZlciB3cml0ZXNcclxuICogdW50aWwgdGhlIGNsaWVudCBpcyBvbmxpbmUsIHVzZSB0aGUgZnVsbCBGaXJlc3RvcmUgU0RLLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmZXJlbmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIGNvbGxlY3Rpb24gdG8gYWRkIHRoaXMgZG9jdW1lbnQgdG8uXHJcbiAqIEBwYXJhbSBkYXRhIC0gQW4gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGEgZm9yIHRoZSBuZXcgZG9jdW1lbnQuXHJcbiAqIEB0aHJvd3MgRXJyb3IgLSBJZiB0aGUgcHJvdmlkZWQgaW5wdXQgaXMgbm90IGEgdmFsaWQgRmlyZXN0b3JlIGRvY3VtZW50LlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCByZXNvbHZlZCB3aXRoIGEgYERvY3VtZW50UmVmZXJlbmNlYCBwb2ludGluZyB0byB0aGVcclxuICogbmV3bHkgY3JlYXRlZCBkb2N1bWVudCBhZnRlciBpdCBoYXMgYmVlbiB3cml0dGVuIHRvIHRoZSBiYWNrZW5kLlxyXG4gKi9cclxuZnVuY3Rpb24gYWRkRG9jKHJlZmVyZW5jZSwgZGF0YSkge1xyXG4gICAgcmVmZXJlbmNlID0gY2FzdChyZWZlcmVuY2UsIENvbGxlY3Rpb25SZWZlcmVuY2UpO1xyXG4gICAgY29uc3QgZG9jUmVmID0gZG9jKHJlZmVyZW5jZSk7XHJcbiAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGFwcGx5RmlyZXN0b3JlRGF0YUNvbnZlcnRlcihyZWZlcmVuY2UuY29udmVydGVyLCBkYXRhKTtcclxuICAgIGNvbnN0IGRhdGFSZWFkZXIgPSBuZXdVc2VyRGF0YVJlYWRlcihyZWZlcmVuY2UuZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2V0RGF0YShkYXRhUmVhZGVyLCAnYWRkRG9jJywgZG9jUmVmLl9rZXksIGNvbnZlcnRlZFZhbHVlLCBkb2NSZWYuY29udmVydGVyICE9PSBudWxsLCB7fSk7XHJcbiAgICBjb25zdCBkYXRhc3RvcmUgPSBnZXREYXRhc3RvcmUocmVmZXJlbmNlLmZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gaW52b2tlQ29tbWl0UnBjKGRhdGFzdG9yZSwgW1xyXG4gICAgICAgIHBhcnNlZC50b011dGF0aW9uKGRvY1JlZi5fa2V5LCBQcmVjb25kaXRpb24uZXhpc3RzKGZhbHNlKSlcclxuICAgIF0pLnRoZW4oKCkgPT4gZG9jUmVmKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBpbiB0aGUgcmVzdWx0IHNldCBvZiB0aGUgZ2l2ZW4gcXVlcnlcclxuICogd2l0aG91dCBhY3R1YWxseSBkb3dubG9hZGluZyB0aGUgZG9jdW1lbnRzLlxyXG4gKlxyXG4gKiBVc2luZyB0aGlzIGZ1bmN0aW9uIHRvIGNvdW50IHRoZSBkb2N1bWVudHMgaXMgZWZmaWNpZW50IGJlY2F1c2Ugb25seSB0aGVcclxuICogZmluYWwgY291bnQsIG5vdCB0aGUgZG9jdW1lbnRzJyBkYXRhLCBpcyBkb3dubG9hZGVkLiBUaGlzIGZ1bmN0aW9uIGNhblxyXG4gKiBjb3VudCB0aGUgZG9jdW1lbnRzIGluIGNhc2VzIHdoZXJlIHRoZSByZXN1bHQgc2V0IGlzIHByb2hpYml0aXZlbHkgbGFyZ2UgdG9cclxuICogZG93bmxvYWQgZW50aXJlbHkgKHRob3VzYW5kcyBvZiBkb2N1bWVudHMpLlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnkgVGhlIHF1ZXJ5IHdob3NlIHJlc3VsdCBzZXQgc2l6ZSBpcyBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIGNvdW50OyB0aGUgY291bnQgY2FuIGJlXHJcbiAqIHJldHJpZXZlZCBmcm9tIGBzbmFwc2hvdC5kYXRhKCkuY291bnRgLCB3aGVyZSBgc25hcHNob3RgIGlzIHRoZVxyXG4gKiBgQWdncmVnYXRlUXVlcnlTbmFwc2hvdGAgdG8gd2hpY2ggdGhlIHJldHVybmVkIFByb21pc2UgcmVzb2x2ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDb3VudChxdWVyeSkge1xyXG4gICAgY29uc3QgY291bnRRdWVyeVNwZWMgPSB7XHJcbiAgICAgICAgY291bnQ6IGNvdW50KClcclxuICAgIH07XHJcbiAgICByZXR1cm4gZ2V0QWdncmVnYXRlKHF1ZXJ5LCBjb3VudFF1ZXJ5U3BlYyk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNwZWNpZmllZCBhZ2dyZWdhdGlvbnMgb3ZlciB0aGUgZG9jdW1lbnRzIGluIHRoZSByZXN1bHRcclxuICogc2V0IG9mIHRoZSBnaXZlbiBxdWVyeSB3aXRob3V0IGFjdHVhbGx5IGRvd25sb2FkaW5nIHRoZSBkb2N1bWVudHMuXHJcbiAqXHJcbiAqIFVzaW5nIHRoaXMgZnVuY3Rpb24gdG8gcGVyZm9ybSBhZ2dyZWdhdGlvbnMgaXMgZWZmaWNpZW50IGJlY2F1c2Ugb25seSB0aGVcclxuICogZmluYWwgYWdncmVnYXRpb24gdmFsdWVzLCBub3QgdGhlIGRvY3VtZW50cycgZGF0YSwgYXJlIGRvd25sb2FkZWQuIFRoaXNcclxuICogZnVuY3Rpb24gY2FuIHBlcmZvcm0gYWdncmVnYXRpb25zIG9mIHRoZSBkb2N1bWVudHMgaW4gY2FzZXMgd2hlcmUgdGhlIHJlc3VsdFxyXG4gKiBzZXQgaXMgcHJvaGliaXRpdmVseSBsYXJnZSB0byBkb3dubG9hZCBlbnRpcmVseSAodGhvdXNhbmRzIG9mIGRvY3VtZW50cykuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSBUaGUgcXVlcnkgd2hvc2UgcmVzdWx0IHNldCBpcyBhZ2dyZWdhdGVkIG92ZXIuXHJcbiAqIEBwYXJhbSBhZ2dyZWdhdGVTcGVjIEFuIGBBZ2dyZWdhdGVTcGVjYCBvYmplY3QgdGhhdCBzcGVjaWZpZXMgdGhlIGFnZ3JlZ2F0ZXNcclxuICogdG8gcGVyZm9ybSBvdmVyIHRoZSByZXN1bHQgc2V0LiBUaGUgQWdncmVnYXRlU3BlYyBzcGVjaWZpZXMgYWxpYXNlcyBmb3IgZWFjaFxyXG4gKiBhZ2dyZWdhdGUsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlIHRoZSBhZ2dyZWdhdGUgcmVzdWx0LlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IGFnZ3JlZ2F0ZVNuYXBzaG90ID0gYXdhaXQgZ2V0QWdncmVnYXRlKHF1ZXJ5LCB7XHJcbiAqICAgY291bnRPZkRvY3M6IGNvdW50KCksXHJcbiAqICAgdG90YWxIb3Vyczogc3VtKCdob3VycycpLFxyXG4gKiAgIGF2ZXJhZ2VTY29yZTogYXZlcmFnZSgnc2NvcmUnKVxyXG4gKiB9KTtcclxuICpcclxuICogY29uc3QgY291bnRPZkRvY3M6IG51bWJlciA9IGFnZ3JlZ2F0ZVNuYXBzaG90LmRhdGEoKS5jb3VudE9mRG9jcztcclxuICogY29uc3QgdG90YWxIb3VyczogbnVtYmVyID0gYWdncmVnYXRlU25hcHNob3QuZGF0YSgpLnRvdGFsSG91cnM7XHJcbiAqIGNvbnN0IGF2ZXJhZ2VTY29yZTogbnVtYmVyIHwgbnVsbCA9IGFnZ3JlZ2F0ZVNuYXBzaG90LmRhdGEoKS5hdmVyYWdlU2NvcmU7XHJcbiAqIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QWdncmVnYXRlKHF1ZXJ5LCBhZ2dyZWdhdGVTcGVjKSB7XHJcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHF1ZXJ5LmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGRhdGFzdG9yZSA9IGdldERhdGFzdG9yZShmaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgaW50ZXJuYWxBZ2dyZWdhdGVzID0gbWFwVG9BcnJheShhZ2dyZWdhdGVTcGVjLCAoYWdncmVnYXRlLCBhbGlhcykgPT4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgQWdncmVnYXRlSW1wbChhbGlhcywgYWdncmVnYXRlLmFnZ3JlZ2F0ZVR5cGUsIGFnZ3JlZ2F0ZS5faW50ZXJuYWxGaWVsZFBhdGgpO1xyXG4gICAgfSk7XHJcbiAgICAvLyBSdW4gdGhlIGFnZ3JlZ2F0aW9uIGFuZCBjb252ZXJ0IHRoZSByZXN1bHRzXHJcbiAgICByZXR1cm4gaW52b2tlUnVuQWdncmVnYXRpb25RdWVyeVJwYyhkYXRhc3RvcmUsIHF1ZXJ5Ll9xdWVyeSwgaW50ZXJuYWxBZ2dyZWdhdGVzKS50aGVuKGFnZ3JlZ2F0ZVJlc3VsdCA9PiBjb252ZXJ0VG9BZ2dyZWdhdGVRdWVyeVNuYXBzaG90KGZpcmVzdG9yZSwgcXVlcnksIGFnZ3JlZ2F0ZVJlc3VsdCkpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbnZlcnRUb0FnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCBxdWVyeSwgYWdncmVnYXRlUmVzdWx0KSB7XHJcbiAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBMaXRlVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBuZXcgQWdncmVnYXRlUXVlcnlTbmFwc2hvdChxdWVyeSwgdXNlckRhdGFXcml0ZXIsIGFnZ3JlZ2F0ZVJlc3VsdCk7XHJcbiAgICByZXR1cm4gcXVlcnlTbmFwc2hvdDtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGFuIEFnZ3JlZ2F0ZUZpZWxkIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIHN1bSBvZlxyXG4gKiBhIHNwZWNpZmllZCBmaWVsZCBvdmVyIGEgcmFuZ2Ugb2YgZG9jdW1lbnRzIGluIHRoZSByZXN1bHQgc2V0IG9mIGEgcXVlcnkuXHJcbiAqIEBwYXJhbSBmaWVsZCBTcGVjaWZpZXMgdGhlIGZpZWxkIHRvIHN1bSBhY3Jvc3MgdGhlIHJlc3VsdCBzZXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdW0oZmllbGQpIHtcclxuICAgIHJldHVybiBuZXcgQWdncmVnYXRlRmllbGQoJ3N1bScsIGZpZWxkUGF0aEZyb21Bcmd1bWVudCQxKCdzdW0nLCBmaWVsZCkpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYW4gQWdncmVnYXRlRmllbGQgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgYXZlcmFnZSBvZlxyXG4gKiBhIHNwZWNpZmllZCBmaWVsZCBvdmVyIGEgcmFuZ2Ugb2YgZG9jdW1lbnRzIGluIHRoZSByZXN1bHQgc2V0IG9mIGEgcXVlcnkuXHJcbiAqIEBwYXJhbSBmaWVsZCBTcGVjaWZpZXMgdGhlIGZpZWxkIHRvIGF2ZXJhZ2UgYWNyb3NzIHRoZSByZXN1bHQgc2V0LlxyXG4gKi9cclxuZnVuY3Rpb24gYXZlcmFnZShmaWVsZCkge1xyXG4gICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGVGaWVsZCgnYXZnJywgZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEoJ2F2ZXJhZ2UnLCBmaWVsZCkpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYW4gQWdncmVnYXRlRmllbGQgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgY291bnQgb2ZcclxuICogZG9jdW1lbnRzIGluIHRoZSByZXN1bHQgc2V0IG9mIGEgcXVlcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb3VudCgpIHtcclxuICAgIHJldHVybiBuZXcgQWdncmVnYXRlRmllbGQoJ2NvdW50Jyk7XHJcbn1cclxuLyoqXHJcbiAqIENvbXBhcmVzIHR3byAnQWdncmVnYXRlRmllbGRgIGluc3RhbmNlcyBmb3IgZXF1YWxpdHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBsZWZ0IENvbXBhcmUgdGhpcyBBZ2dyZWdhdGVGaWVsZCB0byB0aGUgYHJpZ2h0YC5cclxuICogQHBhcmFtIHJpZ2h0IENvbXBhcmUgdGhpcyBBZ2dyZWdhdGVGaWVsZCB0byB0aGUgYGxlZnRgLlxyXG4gKi9cclxuZnVuY3Rpb24gYWdncmVnYXRlRmllbGRFcXVhbChsZWZ0LCByaWdodCkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHJldHVybiAobGVmdCBpbnN0YW5jZW9mIEFnZ3JlZ2F0ZUZpZWxkICYmXHJcbiAgICAgICAgcmlnaHQgaW5zdGFuY2VvZiBBZ2dyZWdhdGVGaWVsZCAmJlxyXG4gICAgICAgIGxlZnQuYWdncmVnYXRlVHlwZSA9PT0gcmlnaHQuYWdncmVnYXRlVHlwZSAmJlxyXG4gICAgICAgICgoX2EgPSBsZWZ0Ll9pbnRlcm5hbEZpZWxkUGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbm9uaWNhbFN0cmluZygpKSA9PT1cclxuICAgICAgICAgICAgKChfYiA9IHJpZ2h0Ll9pbnRlcm5hbEZpZWxkUGF0aCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbm9uaWNhbFN0cmluZygpKSk7XHJcbn1cclxuLyoqXHJcbiAqIENvbXBhcmVzIHR3byBgQWdncmVnYXRlUXVlcnlTbmFwc2hvdGAgaW5zdGFuY2VzIGZvciBlcXVhbGl0eS5cclxuICpcclxuICogVHdvIGBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90YCBpbnN0YW5jZXMgYXJlIGNvbnNpZGVyZWQgXCJlcXVhbFwiIGlmIHRoZXkgaGF2ZVxyXG4gKiB1bmRlcmx5aW5nIHF1ZXJpZXMgdGhhdCBjb21wYXJlIGVxdWFsLCBhbmQgdGhlIHNhbWUgZGF0YS5cclxuICpcclxuICogQHBhcmFtIGxlZnQgLSBUaGUgZmlyc3QgYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgIHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSByaWdodCAtIFRoZSBzZWNvbmQgYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgIHRvIGNvbXBhcmUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgXCJlcXVhbFwiLCBhcyBkZWZpbmVkIGFib3ZlLCBvciBgZmFsc2VgXHJcbiAqIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIGFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RFcXVhbChsZWZ0LCByaWdodCkge1xyXG4gICAgcmV0dXJuIChxdWVyeUVxdWFsKGxlZnQucXVlcnksIHJpZ2h0LnF1ZXJ5KSAmJiBkZWVwRXF1YWwobGVmdC5kYXRhKCksIHJpZ2h0LmRhdGEoKSkpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc2VudGluZWwgZm9yIHVzZSB3aXRoIHtAbGluayBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHVwZGF0ZURvYzoxKX0gb3JcclxuICoge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSMoc2V0RG9jOjEpfSB3aXRoIGB7bWVyZ2U6IHRydWV9YCB0byBtYXJrIGEgZmllbGQgZm9yIGRlbGV0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVsZXRlRmllbGQoKSB7XHJcbiAgICByZXR1cm4gbmV3IERlbGV0ZUZpZWxkVmFsdWVJbXBsKCdkZWxldGVGaWVsZCcpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc2VudGluZWwgdXNlZCB3aXRoIHtAbGluayBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHNldERvYzoxKX0gb3Ige0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSModXBkYXRlRG9jOjEpfSB0b1xyXG4gKiBpbmNsdWRlIGEgc2VydmVyLWdlbmVyYXRlZCB0aW1lc3RhbXAgaW4gdGhlIHdyaXR0ZW4gZGF0YS5cclxuICovXHJcbmZ1bmN0aW9uIHNlcnZlclRpbWVzdGFtcCgpIHtcclxuICAgIHJldHVybiBuZXcgU2VydmVyVGltZXN0YW1wRmllbGRWYWx1ZUltcGwoJ3NlcnZlclRpbWVzdGFtcCcpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3BlY2lhbCB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHdpdGgge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSMoc2V0RG9jOjEpfSBvciB7QGxpbmtcclxuICogQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyh1cGRhdGVEb2M6MSl9IHRoYXQgdGVsbHMgdGhlIHNlcnZlciB0byB1bmlvbiB0aGUgZ2l2ZW4gZWxlbWVudHMgd2l0aCBhbnkgYXJyYXlcclxuICogdmFsdWUgdGhhdCBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgc2VydmVyLiBFYWNoIHNwZWNpZmllZCBlbGVtZW50IHRoYXQgZG9lc24ndFxyXG4gKiBhbHJlYWR5IGV4aXN0IGluIHRoZSBhcnJheSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBlbmQuIElmIHRoZSBmaWVsZCBiZWluZ1xyXG4gKiBtb2RpZmllZCBpcyBub3QgYWxyZWFkeSBhbiBhcnJheSBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggYW4gYXJyYXlcclxuICogY29udGFpbmluZyBleGFjdGx5IHRoZSBzcGVjaWZpZWQgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBlbGVtZW50cyAtIFRoZSBlbGVtZW50cyB0byB1bmlvbiBpbnRvIHRoZSBhcnJheS5cclxuICogQHJldHVybnMgVGhlIGBGaWVsZFZhbHVlYCBzZW50aW5lbCBmb3IgdXNlIGluIGEgY2FsbCB0byBgc2V0RG9jKClgIG9yXHJcbiAqIGB1cGRhdGVEb2MoKWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcnJheVVuaW9uKC4uLmVsZW1lbnRzKSB7XHJcbiAgICAvLyBOT1RFOiBXZSBkb24ndCBhY3R1YWxseSBwYXJzZSB0aGUgZGF0YSB1bnRpbCBpdCdzIHVzZWQgaW4gc2V0KCkgb3JcclxuICAgIC8vIHVwZGF0ZSgpIHNpbmNlIHdlJ2QgbmVlZCB0aGUgRmlyZXN0b3JlIGluc3RhbmNlIHRvIGRvIHRoaXMuXHJcbiAgICByZXR1cm4gbmV3IEFycmF5VW5pb25GaWVsZFZhbHVlSW1wbCgnYXJyYXlVbmlvbicsIGVsZW1lbnRzKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHNwZWNpYWwgdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHtAbGluayAoc2V0RG9jOjEpfSBvciB7QGxpbmtcclxuICogdXBkYXRlRG9jOjF9IHRoYXQgdGVsbHMgdGhlIHNlcnZlciB0byByZW1vdmUgdGhlIGdpdmVuIGVsZW1lbnRzIGZyb20gYW55XHJcbiAqIGFycmF5IHZhbHVlIHRoYXQgYWxyZWFkeSBleGlzdHMgb24gdGhlIHNlcnZlci4gQWxsIGluc3RhbmNlcyBvZiBlYWNoIGVsZW1lbnRcclxuICogc3BlY2lmaWVkIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBhcnJheS4gSWYgdGhlIGZpZWxkIGJlaW5nIG1vZGlmaWVkIGlzIG5vdFxyXG4gKiBhbHJlYWR5IGFuIGFycmF5IGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCBhbiBlbXB0eSBhcnJheS5cclxuICpcclxuICogQHBhcmFtIGVsZW1lbnRzIC0gVGhlIGVsZW1lbnRzIHRvIHJlbW92ZSBmcm9tIHRoZSBhcnJheS5cclxuICogQHJldHVybnMgVGhlIGBGaWVsZFZhbHVlYCBzZW50aW5lbCBmb3IgdXNlIGluIGEgY2FsbCB0byBgc2V0RG9jKClgIG9yXHJcbiAqIGB1cGRhdGVEb2MoKWBcclxuICovXHJcbmZ1bmN0aW9uIGFycmF5UmVtb3ZlKC4uLmVsZW1lbnRzKSB7XHJcbiAgICAvLyBOT1RFOiBXZSBkb24ndCBhY3R1YWxseSBwYXJzZSB0aGUgZGF0YSB1bnRpbCBpdCdzIHVzZWQgaW4gc2V0KCkgb3JcclxuICAgIC8vIHVwZGF0ZSgpIHNpbmNlIHdlJ2QgbmVlZCB0aGUgRmlyZXN0b3JlIGluc3RhbmNlIHRvIGRvIHRoaXMuXHJcbiAgICByZXR1cm4gbmV3IEFycmF5UmVtb3ZlRmllbGRWYWx1ZUltcGwoJ2FycmF5UmVtb3ZlJywgZWxlbWVudHMpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3BlY2lhbCB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHdpdGgge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSMoc2V0RG9jOjEpfSBvciB7QGxpbmtcclxuICogQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyh1cGRhdGVEb2M6MSl9IHRoYXQgdGVsbHMgdGhlIHNlcnZlciB0byBpbmNyZW1lbnQgdGhlIGZpZWxkJ3MgY3VycmVudCB2YWx1ZSBieVxyXG4gKiB0aGUgZ2l2ZW4gdmFsdWUuXHJcbiAqXHJcbiAqIElmIGVpdGhlciB0aGUgb3BlcmFuZCBvciB0aGUgY3VycmVudCBmaWVsZCB2YWx1ZSB1c2VzIGZsb2F0aW5nIHBvaW50XHJcbiAqIHByZWNpc2lvbiwgYWxsIGFyaXRobWV0aWMgZm9sbG93cyBJRUVFIDc1NCBzZW1hbnRpY3MuIElmIGJvdGggdmFsdWVzIGFyZVxyXG4gKiBpbnRlZ2VycywgdmFsdWVzIG91dHNpZGUgb2YgSmF2YVNjcmlwdCdzIHNhZmUgbnVtYmVyIHJhbmdlXHJcbiAqIChgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJgIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmApIGFyZSBhbHNvIHN1YmplY3QgdG9cclxuICogcHJlY2lzaW9uIGxvc3MuIEZ1cnRoZXJtb3JlLCBvbmNlIHByb2Nlc3NlZCBieSB0aGUgRmlyZXN0b3JlIGJhY2tlbmQsIGFsbFxyXG4gKiBpbnRlZ2VyIG9wZXJhdGlvbnMgYXJlIGNhcHBlZCBiZXR3ZWVuIC0yXjYzIGFuZCAyXjYzLTEuXHJcbiAqXHJcbiAqIElmIHRoZSBjdXJyZW50IGZpZWxkIHZhbHVlIGlzIG5vdCBvZiB0eXBlIGBudW1iZXJgLCBvciBpZiB0aGUgZmllbGQgZG9lcyBub3RcclxuICogeWV0IGV4aXN0LCB0aGUgdHJhbnNmb3JtYXRpb24gc2V0cyB0aGUgZmllbGQgdG8gdGhlIGdpdmVuIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0gbiAtIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgYnkuXHJcbiAqIEByZXR1cm5zIFRoZSBgRmllbGRWYWx1ZWAgc2VudGluZWwgZm9yIHVzZSBpbiBhIGNhbGwgdG8gYHNldERvYygpYCBvclxyXG4gKiBgdXBkYXRlRG9jKClgXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmNyZW1lbnQobikge1xyXG4gICAgcmV0dXJuIG5ldyBOdW1lcmljSW5jcmVtZW50RmllbGRWYWx1ZUltcGwoJ2luY3JlbWVudCcsIG4pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIHdyaXRlIGJhdGNoLCB1c2VkIHRvIHBlcmZvcm0gbXVsdGlwbGUgd3JpdGVzIGFzIGEgc2luZ2xlIGF0b21pYyB1bml0LlxyXG4gKlxyXG4gKiBBIGBXcml0ZUJhdGNoYCBvYmplY3QgY2FuIGJlIGFjcXVpcmVkIGJ5IGNhbGxpbmcge0BsaW5rIHdyaXRlQmF0Y2h9LiBJdFxyXG4gKiBwcm92aWRlcyBtZXRob2RzIGZvciBhZGRpbmcgd3JpdGVzIHRvIHRoZSB3cml0ZSBiYXRjaC4gTm9uZSBvZiB0aGUgd3JpdGVzXHJcbiAqIHdpbGwgYmUgY29tbWl0dGVkIChvciB2aXNpYmxlIGxvY2FsbHkpIHVudGlsIHtAbGluayBXcml0ZUJhdGNoLmNvbW1pdH0gaXNcclxuICogY2FsbGVkLlxyXG4gKi9cclxuY2xhc3MgV3JpdGVCYXRjaCB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSwgX2NvbW1pdEhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xyXG4gICAgICAgIHRoaXMuX2NvbW1pdEhhbmRsZXIgPSBfY29tbWl0SGFuZGxlcjtcclxuICAgICAgICB0aGlzLl9tdXRhdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9jb21taXR0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9kYXRhUmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIoX2ZpcmVzdG9yZSk7XHJcbiAgICB9XHJcbiAgICBzZXQoZG9jdW1lbnRSZWYsIGRhdGEsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl92ZXJpZnlOb3RDb21taXR0ZWQoKTtcclxuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcclxuICAgICAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGFwcGx5RmlyZXN0b3JlRGF0YUNvbnZlcnRlcihyZWYuY29udmVydGVyLCBkYXRhLCBvcHRpb25zKTtcclxuICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVNldERhdGEodGhpcy5fZGF0YVJlYWRlciwgJ1dyaXRlQmF0Y2guc2V0JywgcmVmLl9rZXksIGNvbnZlcnRlZFZhbHVlLCByZWYuY29udmVydGVyICE9PSBudWxsLCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9tdXRhdGlvbnMucHVzaChwYXJzZWQudG9NdXRhdGlvbihyZWYuX2tleSwgUHJlY29uZGl0aW9uLm5vbmUoKSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGRvY3VtZW50UmVmLCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIC4uLm1vcmVGaWVsZHNBbmRWYWx1ZXMpIHtcclxuICAgICAgICB0aGlzLl92ZXJpZnlOb3RDb21taXR0ZWQoKTtcclxuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcclxuICAgICAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxyXG4gICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cclxuICAgICAgICBmaWVsZE9yVXBkYXRlRGF0YSA9IGdldE1vZHVsYXJJbnN0YW5jZShmaWVsZE9yVXBkYXRlRGF0YSk7XHJcbiAgICAgICAgbGV0IHBhcnNlZDtcclxuICAgICAgICBpZiAodHlwZW9mIGZpZWxkT3JVcGRhdGVEYXRhID09PSAnc3RyaW5nJyB8fFxyXG4gICAgICAgICAgICBmaWVsZE9yVXBkYXRlRGF0YSBpbnN0YW5jZW9mIEZpZWxkUGF0aCkge1xyXG4gICAgICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZVZhcmFyZ3ModGhpcy5fZGF0YVJlYWRlciwgJ1dyaXRlQmF0Y2gudXBkYXRlJywgcmVmLl9rZXksIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgbW9yZUZpZWxkc0FuZFZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZURhdGEodGhpcy5fZGF0YVJlYWRlciwgJ1dyaXRlQmF0Y2gudXBkYXRlJywgcmVmLl9rZXksIGZpZWxkT3JVcGRhdGVEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbXV0YXRpb25zLnB1c2gocGFyc2VkLnRvTXV0YXRpb24ocmVmLl9rZXksIFByZWNvbmRpdGlvbi5leGlzdHModHJ1ZSkpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhlIHByb3ZpZGVkIHtAbGluayBEb2N1bWVudFJlZmVyZW5jZX0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRvY3VtZW50UmVmIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGJlIGRlbGV0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGlzIGBXcml0ZUJhdGNoYCBpbnN0YW5jZS4gVXNlZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxyXG4gICAgICovXHJcbiAgICBkZWxldGUoZG9jdW1lbnRSZWYpIHtcclxuICAgICAgICB0aGlzLl92ZXJpZnlOb3RDb21taXR0ZWQoKTtcclxuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcclxuICAgICAgICB0aGlzLl9tdXRhdGlvbnMgPSB0aGlzLl9tdXRhdGlvbnMuY29uY2F0KG5ldyBEZWxldGVNdXRhdGlvbihyZWYuX2tleSwgUHJlY29uZGl0aW9uLm5vbmUoKSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21taXRzIGFsbCBvZiB0aGUgd3JpdGVzIGluIHRoaXMgd3JpdGUgYmF0Y2ggYXMgYSBzaW5nbGUgYXRvbWljIHVuaXQuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHJlc3VsdCBvZiB0aGVzZSB3cml0ZXMgd2lsbCBvbmx5IGJlIHJlZmxlY3RlZCBpbiBkb2N1bWVudCByZWFkcyB0aGF0XHJcbiAgICAgKiBvY2N1ciBhZnRlciB0aGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcy4gSWYgdGhlIGNsaWVudCBpcyBvZmZsaW5lLCB0aGVcclxuICAgICAqIHdyaXRlIGZhaWxzLiBJZiB5b3Ugd291bGQgbGlrZSB0byBzZWUgbG9jYWwgbW9kaWZpY2F0aW9ucyBvciBidWZmZXIgd3JpdGVzXHJcbiAgICAgKiB1bnRpbCB0aGUgY2xpZW50IGlzIG9ubGluZSwgdXNlIHRoZSBmdWxsIEZpcmVzdG9yZSBTREsuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQSBgUHJvbWlzZWAgcmVzb2x2ZWQgb25jZSBhbGwgb2YgdGhlIHdyaXRlcyBpbiB0aGUgYmF0Y2ggaGF2ZSBiZWVuXHJcbiAgICAgKiBzdWNjZXNzZnVsbHkgd3JpdHRlbiB0byB0aGUgYmFja2VuZCBhcyBhbiBhdG9taWMgdW5pdCAobm90ZSB0aGF0IGl0IHdvbid0XHJcbiAgICAgKiByZXNvbHZlIHdoaWxlIHlvdSdyZSBvZmZsaW5lKS5cclxuICAgICAqL1xyXG4gICAgY29tbWl0KCkge1xyXG4gICAgICAgIHRoaXMuX3ZlcmlmeU5vdENvbW1pdHRlZCgpO1xyXG4gICAgICAgIHRoaXMuX2NvbW1pdHRlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMuX211dGF0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21taXRIYW5kbGVyKHRoaXMuX211dGF0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIF92ZXJpZnlOb3RDb21taXR0ZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbW1pdHRlZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnQSB3cml0ZSBiYXRjaCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgYWZ0ZXIgY29tbWl0KCkgJyArXHJcbiAgICAgICAgICAgICAgICAnaGFzIGJlZW4gY2FsbGVkLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgZmlyZXN0b3JlKSB7XHJcbiAgICBkb2N1bWVudFJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShkb2N1bWVudFJlZik7XHJcbiAgICBpZiAoZG9jdW1lbnRSZWYuZmlyZXN0b3JlICE9PSBmaXJlc3RvcmUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnUHJvdmlkZWQgZG9jdW1lbnQgcmVmZXJlbmNlIGlzIGZyb20gYSBkaWZmZXJlbnQgRmlyZXN0b3JlIGluc3RhbmNlLicpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50UmVmO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgd3JpdGUgYmF0Y2gsIHVzZWQgZm9yIHBlcmZvcm1pbmcgbXVsdGlwbGUgd3JpdGVzIGFzIGEgc2luZ2xlXHJcbiAqIGF0b21pYyBvcGVyYXRpb24uIFRoZSBtYXhpbXVtIG51bWJlciBvZiB3cml0ZXMgYWxsb3dlZCBpbiBhIHNpbmdsZSBXcml0ZUJhdGNoXHJcbiAqIGlzIDUwMC5cclxuICpcclxuICogVGhlIHJlc3VsdCBvZiB0aGVzZSB3cml0ZXMgd2lsbCBvbmx5IGJlIHJlZmxlY3RlZCBpbiBkb2N1bWVudCByZWFkcyB0aGF0XHJcbiAqIG9jY3VyIGFmdGVyIHRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzLiBJZiB0aGUgY2xpZW50IGlzIG9mZmxpbmUsIHRoZVxyXG4gKiB3cml0ZSBmYWlscy4gSWYgeW91IHdvdWxkIGxpa2UgdG8gc2VlIGxvY2FsIG1vZGlmaWNhdGlvbnMgb3IgYnVmZmVyIHdyaXRlc1xyXG4gKiB1bnRpbCB0aGUgY2xpZW50IGlzIG9ubGluZSwgdXNlIHRoZSBmdWxsIEZpcmVzdG9yZSBTREsuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgYFdyaXRlQmF0Y2hgIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXRvbWljYWxseSBleGVjdXRlIG11bHRpcGxlXHJcbiAqIHdyaXRlcy5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlQmF0Y2goZmlyZXN0b3JlKSB7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGRhdGFzdG9yZSA9IGdldERhdGFzdG9yZShmaXJlc3RvcmUpO1xyXG4gICAgcmV0dXJuIG5ldyBXcml0ZUJhdGNoKGZpcmVzdG9yZSwgd3JpdGVzID0+IGludm9rZUNvbW1pdFJwYyhkYXRhc3RvcmUsIHdyaXRlcykpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfVFJBTlNBQ1RJT05fT1BUSU9OUyA9IHtcclxuICAgIG1heEF0dGVtcHRzOiA1XHJcbn07XHJcbmZ1bmN0aW9uIHZhbGlkYXRlVHJhbnNhY3Rpb25PcHRpb25zKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zLm1heEF0dGVtcHRzIDwgMSkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdNYXggYXR0ZW1wdHMgbXVzdCBiZSBhdCBsZWFzdCAxJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEludGVybmFsIHRyYW5zYWN0aW9uIG9iamVjdCByZXNwb25zaWJsZSBmb3IgYWNjdW11bGF0aW5nIHRoZSBtdXRhdGlvbnMgdG9cclxuICogcGVyZm9ybSBhbmQgdGhlIGJhc2UgdmVyc2lvbnMgZm9yIGFueSBkb2N1bWVudHMgcmVhZC5cclxuICovXHJcbmNsYXNzIFRyYW5zYWN0aW9uJDEge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YXN0b3JlKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhc3RvcmUgPSBkYXRhc3RvcmU7XHJcbiAgICAgICAgLy8gVGhlIHZlcnNpb24gb2YgZWFjaCBkb2N1bWVudCB0aGF0IHdhcyByZWFkIGR1cmluZyB0aGlzIHRyYW5zYWN0aW9uLlxyXG4gICAgICAgIHRoaXMucmVhZFZlcnNpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25zID0gW107XHJcbiAgICAgICAgdGhpcy5jb21taXR0ZWQgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGRlZmVycmVkIHVzYWdlIGVycm9yIHRoYXQgb2NjdXJyZWQgcHJldmlvdXNseSBpbiB0aGlzIHRyYW5zYWN0aW9uIHRoYXRcclxuICAgICAgICAgKiB3aWxsIGNhdXNlIHRoZSB0cmFuc2FjdGlvbiB0byBmYWlsIG9uY2UgaXQgYWN0dWFsbHkgY29tbWl0cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbkVycm9yID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgb2YgZG9jdW1lbnRzIHRoYXQgaGF2ZSBiZWVuIHdyaXR0ZW4gaW4gdGhlIHRyYW5zYWN0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiB0aGVyZSdzIG1vcmUgdGhhbiBvbmUgd3JpdGUgdG8gdGhlIHNhbWUga2V5IGluIGEgdHJhbnNhY3Rpb24sIGFueVxyXG4gICAgICAgICAqIHdyaXRlcyBhZnRlciB0aGUgZmlyc3QgYXJlIGhhbmRsZWQgZGlmZmVyZW50bHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53cml0dGVuRG9jcyA9IG5ldyBTZXQoKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGxvb2t1cChrZXlzKSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVDb21taXROb3RDYWxsZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5tdXRhdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbkVycm9yID0gbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ZpcmVzdG9yZSB0cmFuc2FjdGlvbnMgcmVxdWlyZSBhbGwgcmVhZHMgdG8gYmUgZXhlY3V0ZWQgYmVmb3JlIGFsbCB3cml0ZXMuJyk7XHJcbiAgICAgICAgICAgIHRocm93IHRoaXMubGFzdFRyYW5zYWN0aW9uRXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRvY3MgPSBhd2FpdCBpbnZva2VCYXRjaEdldERvY3VtZW50c1JwYyh0aGlzLmRhdGFzdG9yZSwga2V5cyk7XHJcbiAgICAgICAgZG9jcy5mb3JFYWNoKGRvYyA9PiB0aGlzLnJlY29yZFZlcnNpb24oZG9jKSk7XHJcbiAgICAgICAgcmV0dXJuIGRvY3M7XHJcbiAgICB9XHJcbiAgICBzZXQoa2V5LCBkYXRhKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZShkYXRhLnRvTXV0YXRpb24oa2V5LCB0aGlzLnByZWNvbmRpdGlvbihrZXkpKSk7XHJcbiAgICAgICAgdGhpcy53cml0dGVuRG9jcy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGtleSwgZGF0YSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGUoZGF0YS50b011dGF0aW9uKGtleSwgdGhpcy5wcmVjb25kaXRpb25Gb3JVcGRhdGUoa2V5KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbkVycm9yID0gZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53cml0dGVuRG9jcy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlKGtleSkge1xyXG4gICAgICAgIHRoaXMud3JpdGUobmV3IERlbGV0ZU11dGF0aW9uKGtleSwgdGhpcy5wcmVjb25kaXRpb24oa2V5KSkpO1xyXG4gICAgICAgIHRoaXMud3JpdHRlbkRvY3MuYWRkKGtleS50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGNvbW1pdCgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUNvbW1pdE5vdENhbGxlZCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RUcmFuc2FjdGlvbkVycm9yKSB7XHJcbiAgICAgICAgICAgIHRocm93IHRoaXMubGFzdFRyYW5zYWN0aW9uRXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVud3JpdHRlbiA9IHRoaXMucmVhZFZlcnNpb25zO1xyXG4gICAgICAgIC8vIEZvciBlYWNoIG11dGF0aW9uLCBub3RlIHRoYXQgdGhlIGRvYyB3YXMgd3JpdHRlbi5cclxuICAgICAgICB0aGlzLm11dGF0aW9ucy5mb3JFYWNoKG11dGF0aW9uID0+IHtcclxuICAgICAgICAgICAgdW53cml0dGVuLmRlbGV0ZShtdXRhdGlvbi5rZXkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gRm9yIGVhY2ggZG9jdW1lbnQgdGhhdCB3YXMgcmVhZCBidXQgbm90IHdyaXR0ZW4gdG8sIHdlIHdhbnQgdG8gcGVyZm9ybVxyXG4gICAgICAgIC8vIGEgYHZlcmlmeWAgb3BlcmF0aW9uLlxyXG4gICAgICAgIHVud3JpdHRlbi5mb3JFYWNoKChfLCBwYXRoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IERvY3VtZW50S2V5LmZyb21QYXRoKHBhdGgpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9ucy5wdXNoKG5ldyBWZXJpZnlNdXRhdGlvbihrZXksIHRoaXMucHJlY29uZGl0aW9uKGtleSkpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBhd2FpdCBpbnZva2VDb21taXRScGModGhpcy5kYXRhc3RvcmUsIHRoaXMubXV0YXRpb25zKTtcclxuICAgICAgICB0aGlzLmNvbW1pdHRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZWNvcmRWZXJzaW9uKGRvYykge1xyXG4gICAgICAgIGxldCBkb2NWZXJzaW9uO1xyXG4gICAgICAgIGlmIChkb2MuaXNGb3VuZERvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgZG9jVmVyc2lvbiA9IGRvYy52ZXJzaW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkb2MuaXNOb0RvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgLy8gUmVwcmVzZW50IGEgZGVsZXRlZCBkb2MgdXNpbmcgU25hcHNob3RWZXJzaW9uLm1pbigpLlxyXG4gICAgICAgICAgICBkb2NWZXJzaW9uID0gU25hcHNob3RWZXJzaW9uLm1pbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBleGlzdGluZ1ZlcnNpb24gPSB0aGlzLnJlYWRWZXJzaW9ucy5nZXQoZG9jLmtleS50b1N0cmluZygpKTtcclxuICAgICAgICBpZiAoZXhpc3RpbmdWZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIGlmICghZG9jVmVyc2lvbi5pc0VxdWFsKGV4aXN0aW5nVmVyc2lvbikpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgdHJhbnNhY3Rpb24gd2lsbCBmYWlsIG5vIG1hdHRlciB3aGF0LlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuQUJPUlRFRCwgJ0RvY3VtZW50IHZlcnNpb24gY2hhbmdlZCBiZXR3ZWVuIHR3byByZWFkcy4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZWFkVmVyc2lvbnMuc2V0KGRvYy5rZXkudG9TdHJpbmcoKSwgZG9jVmVyc2lvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2ZXJzaW9uIG9mIHRoaXMgZG9jdW1lbnQgd2hlbiBpdCB3YXMgcmVhZCBpbiB0aGlzIHRyYW5zYWN0aW9uLFxyXG4gICAgICogYXMgYSBwcmVjb25kaXRpb24sIG9yIG5vIHByZWNvbmRpdGlvbiBpZiBpdCB3YXMgbm90IHJlYWQuXHJcbiAgICAgKi9cclxuICAgIHByZWNvbmRpdGlvbihrZXkpIHtcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5yZWFkVmVyc2lvbnMuZ2V0KGtleS50b1N0cmluZygpKTtcclxuICAgICAgICBpZiAoIXRoaXMud3JpdHRlbkRvY3MuaGFzKGtleS50b1N0cmluZygpKSAmJiB2ZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5leGlzdHMoZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi51cGRhdGVUaW1lKHZlcnNpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJlY29uZGl0aW9uLm5vbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHByZWNvbmRpdGlvbiBmb3IgYSBkb2N1bWVudCBpZiB0aGUgb3BlcmF0aW9uIGlzIGFuIHVwZGF0ZS5cclxuICAgICAqL1xyXG4gICAgcHJlY29uZGl0aW9uRm9yVXBkYXRlKGtleSkge1xyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLnJlYWRWZXJzaW9ucy5nZXQoa2V5LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIGEgZG9jdW1lbnQgaXMgd3JpdHRlbiwgd2Ugd2FudCB0byB0YWtlIGludG8gYWNjb3VudCB0aGVcclxuICAgICAgICAvLyByZWFkIHRpbWUgYW5kIGV4aXN0ZW5jZVxyXG4gICAgICAgIGlmICghdGhpcy53cml0dGVuRG9jcy5oYXMoa2V5LnRvU3RyaW5nKCkpICYmIHZlcnNpb24pIHtcclxuICAgICAgICAgICAgaWYgKHZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdCwgc28gZmFpbCB0aGUgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGhhcyB0byBiZSB2YWxpZGF0ZWQgbG9jYWxseSBiZWNhdXNlIHlvdSBjYW4ndCBzZW5kIGFcclxuICAgICAgICAgICAgICAgIC8vIHByZWNvbmRpdGlvbiB0aGF0IGEgZG9jdW1lbnQgZG9lcyBub3QgZXhpc3Qgd2l0aG91dCBjaGFuZ2luZyB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgYmFja2VuZCB3cml0ZSB0byBiZSBhbiBpbnNlcnQuIFRoaXMgaXMgdGhlIHJldmVyc2VcclxuICAgICAgICAgICAgICAgIC8vIG9mIHdoYXQgd2Ugd2FudCwgc2luY2Ugd2Ugd2FudCB0byBhc3NlcnQgdGhhdCB0aGUgZG9jdW1lbnQgZG9lc24ndFxyXG4gICAgICAgICAgICAgICAgLy8gZXhpc3QgYnV0IHRoZW4gc2VuZCB0aGUgdXBkYXRlIGFuZCBoYXZlIGl0IGZhaWwuIFNpbmNlIHdlIGNhbid0XHJcbiAgICAgICAgICAgICAgICAvLyBleHByZXNzIHRoYXQgdG8gdGhlIGJhY2tlbmQsIHdlIGhhdmUgdG8gdmFsaWRhdGUgbG9jYWxseS5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgY2FuIGNoYW5nZSBvbmNlIHdlIGNhbiBzZW5kIHNlcGFyYXRlIHZlcmlmeSB3cml0ZXMgaW4gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbi5cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIFwiQ2FuJ3QgdXBkYXRlIGEgZG9jdW1lbnQgdGhhdCBkb2Vzbid0IGV4aXN0LlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBEb2N1bWVudCBleGlzdHMsIGJhc2UgcHJlY29uZGl0aW9uIG9uIGRvY3VtZW50IHVwZGF0ZSB0aW1lLlxyXG4gICAgICAgICAgICByZXR1cm4gUHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUodmVyc2lvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEb2N1bWVudCB3YXMgbm90IHJlYWQsIHNvIHdlIGp1c3QgdXNlIHRoZSBwcmVjb25kaXRpb25zIGZvciBhIGJsaW5kXHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZS5cclxuICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5leGlzdHModHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd3JpdGUobXV0YXRpb24pIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUNvbW1pdE5vdENhbGxlZCgpO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25zLnB1c2gobXV0YXRpb24pO1xyXG4gICAgfVxyXG4gICAgZW5zdXJlQ29tbWl0Tm90Q2FsbGVkKCkge1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUcmFuc2FjdGlvblJ1bm5lciBlbmNhcHN1bGF0ZXMgdGhlIGxvZ2ljIG5lZWRlZCB0byBydW4gYW5kIHJldHJ5IHRyYW5zYWN0aW9uc1xyXG4gKiB3aXRoIGJhY2tvZmYuXHJcbiAqL1xyXG5jbGFzcyBUcmFuc2FjdGlvblJ1bm5lciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihhc3luY1F1ZXVlLCBkYXRhc3RvcmUsIG9wdGlvbnMsIHVwZGF0ZUZ1bmN0aW9uLCBkZWZlcnJlZCkge1xyXG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZSA9IGFzeW5jUXVldWU7XHJcbiAgICAgICAgdGhpcy5kYXRhc3RvcmUgPSBkYXRhc3RvcmU7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLnVwZGF0ZUZ1bmN0aW9uID0gdXBkYXRlRnVuY3Rpb247XHJcbiAgICAgICAgdGhpcy5kZWZlcnJlZCA9IGRlZmVycmVkO1xyXG4gICAgICAgIHRoaXMuYXR0ZW1wdHNSZW1haW5pbmcgPSBvcHRpb25zLm1heEF0dGVtcHRzO1xyXG4gICAgICAgIHRoaXMuYmFja29mZiA9IG5ldyBFeHBvbmVudGlhbEJhY2tvZmYodGhpcy5hc3luY1F1ZXVlLCBcInRyYW5zYWN0aW9uX3JldHJ5XCIgLyogVGltZXJJZC5UcmFuc2FjdGlvblJldHJ5ICovKTtcclxuICAgIH1cclxuICAgIC8qKiBSdW5zIHRoZSB0cmFuc2FjdGlvbiBhbmQgc2V0cyB0aGUgcmVzdWx0IG9uIGRlZmVycmVkLiAqL1xyXG4gICAgcnVuKCkge1xyXG4gICAgICAgIHRoaXMuYXR0ZW1wdHNSZW1haW5pbmcgLT0gMTtcclxuICAgICAgICB0aGlzLnJ1bldpdGhCYWNrT2ZmKCk7XHJcbiAgICB9XHJcbiAgICBydW5XaXRoQmFja09mZigpIHtcclxuICAgICAgICB0aGlzLmJhY2tvZmYuYmFja29mZkFuZFJ1bihhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uJDEodGhpcy5kYXRhc3RvcmUpO1xyXG4gICAgICAgICAgICBjb25zdCB1c2VyUHJvbWlzZSA9IHRoaXMudHJ5UnVuVXBkYXRlRnVuY3Rpb24odHJhbnNhY3Rpb24pO1xyXG4gICAgICAgICAgICBpZiAodXNlclByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgIHVzZXJQcm9taXNlXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbW1pdCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChjb21taXRFcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRyYW5zYWN0aW9uRXJyb3IoY29tbWl0RXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHVzZXJQcm9taXNlRXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNhY3Rpb25FcnJvcih1c2VyUHJvbWlzZUVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0cnlSdW5VcGRhdGVGdW5jdGlvbih0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9taXNlID0gdGhpcy51cGRhdGVGdW5jdGlvbih0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh1c2VyUHJvbWlzZSkgfHxcclxuICAgICAgICAgICAgICAgICF1c2VyUHJvbWlzZS5jYXRjaCB8fFxyXG4gICAgICAgICAgICAgICAgIXVzZXJQcm9taXNlLnRoZW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KEVycm9yKCdUcmFuc2FjdGlvbiBjYWxsYmFjayBtdXN0IHJldHVybiBhIFByb21pc2UnKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdXNlclByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAvLyBEbyBub3QgcmV0cnkgZXJyb3JzIHRocm93biBieSB1c2VyIHByb3ZpZGVkIHVwZGF0ZUZ1bmN0aW9uLlxyXG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhbmRsZVRyYW5zYWN0aW9uRXJyb3IoZXJyb3IpIHtcclxuICAgICAgICBpZiAodGhpcy5hdHRlbXB0c1JlbWFpbmluZyA+IDAgJiYgdGhpcy5pc1JldHJ5YWJsZVRyYW5zYWN0aW9uRXJyb3IoZXJyb3IpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdHNSZW1haW5pbmcgLT0gMTtcclxuICAgICAgICAgICAgdGhpcy5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ydW5XaXRoQmFja09mZigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc1JldHJ5YWJsZVRyYW5zYWN0aW9uRXJyb3IoZXJyb3IpIHtcclxuICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0ZpcmViYXNlRXJyb3InKSB7XHJcbiAgICAgICAgICAgIC8vIEluIHRyYW5zYWN0aW9ucywgdGhlIGJhY2tlbmQgd2lsbCBmYWlsIG91dGRhdGVkIHJlYWRzIHdpdGggRkFJTEVEX1BSRUNPTkRJVElPTiBhbmRcclxuICAgICAgICAgICAgLy8gbm9uLW1hdGNoaW5nIGRvY3VtZW50IHZlcnNpb25zIHdpdGggQUJPUlRFRC4gVGhlc2UgZXJyb3JzIHNob3VsZCBiZSByZXRyaWVkLlxyXG4gICAgICAgICAgICBjb25zdCBjb2RlID0gZXJyb3IuY29kZTtcclxuICAgICAgICAgICAgcmV0dXJuIChjb2RlID09PSAnYWJvcnRlZCcgfHxcclxuICAgICAgICAgICAgICAgIGNvZGUgPT09ICdmYWlsZWQtcHJlY29uZGl0aW9uJyB8fFxyXG4gICAgICAgICAgICAgICAgY29kZSA9PT0gJ2FscmVhZHktZXhpc3RzJyB8fFxyXG4gICAgICAgICAgICAgICAgIWlzUGVybWFuZW50RXJyb3IoY29kZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gb3BlcmF0aW9uIHNjaGVkdWxlZCB0byBiZSBydW4gaW4gdGhlIGZ1dHVyZSBvbiBhbiBBc3luY1F1ZXVlLlxyXG4gKlxyXG4gKiBJdCBpcyBjcmVhdGVkIHZpYSBEZWxheWVkT3BlcmF0aW9uLmNyZWF0ZUFuZFNjaGVkdWxlKCkuXHJcbiAqXHJcbiAqIFN1cHBvcnRzIGNhbmNlbGxhdGlvbiAodmlhIGNhbmNlbCgpKSBhbmQgZWFybHkgZXhlY3V0aW9uICh2aWEgc2tpcERlbGF5KCkpLlxyXG4gKlxyXG4gKiBOb3RlOiBXZSBpbXBsZW1lbnQgYFByb21pc2VMaWtlYCBpbnN0ZWFkIG9mIGBQcm9taXNlYCwgYXMgdGhlIGBQcm9taXNlYCB0eXBlXHJcbiAqIGluIG5ld2VyIHZlcnNpb25zIG9mIFR5cGVTY3JpcHQgZGVmaW5lcyBgZmluYWxseWAsIHdoaWNoIGlzIG5vdCBhdmFpbGFibGUgaW5cclxuICogSUUuXHJcbiAqL1xyXG5jbGFzcyBEZWxheWVkT3BlcmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGFzeW5jUXVldWUsIHRpbWVySWQsIHRhcmdldFRpbWVNcywgb3AsIHJlbW92YWxDYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZSA9IGFzeW5jUXVldWU7XHJcbiAgICAgICAgdGhpcy50aW1lcklkID0gdGltZXJJZDtcclxuICAgICAgICB0aGlzLnRhcmdldFRpbWVNcyA9IHRhcmdldFRpbWVNcztcclxuICAgICAgICB0aGlzLm9wID0gb3A7XHJcbiAgICAgICAgdGhpcy5yZW1vdmFsQ2FsbGJhY2sgPSByZW1vdmFsQ2FsbGJhY2s7XHJcbiAgICAgICAgdGhpcy5kZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHRoaXMudGhlbiA9IHRoaXMuZGVmZXJyZWQucHJvbWlzZS50aGVuLmJpbmQodGhpcy5kZWZlcnJlZC5wcm9taXNlKTtcclxuICAgICAgICAvLyBJdCdzIG5vcm1hbCBmb3IgdGhlIGRlZmVycmVkIHByb21pc2UgdG8gYmUgY2FuY2VsZWQgKGR1ZSB0byBjYW5jZWxsYXRpb24pXHJcbiAgICAgICAgLy8gYW5kIHNvIHdlIGF0dGFjaCBhIGR1bW15IGNhdGNoIGNhbGxiYWNrIHRvIGF2b2lkXHJcbiAgICAgICAgLy8gJ1VuaGFuZGxlZFByb21pc2VSZWplY3Rpb25XYXJuaW5nJyBsb2cgc3BhbS5cclxuICAgICAgICB0aGlzLmRlZmVycmVkLnByb21pc2UuY2F0Y2goZXJyID0+IHsgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQgcHJvbWlzZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgRGVsYXllZE9wZXJhdGlvbiB0aGF0IGhhcyBiZWVuIHNjaGVkdWxlZCB0byBiZVxyXG4gICAgICogZXhlY3V0ZWQgb24gdGhlIHByb3ZpZGVkIGFzeW5jUXVldWUgYWZ0ZXIgdGhlIHByb3ZpZGVkIGRlbGF5TXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFzeW5jUXVldWUgLSBUaGUgcXVldWUgdG8gc2NoZWR1bGUgdGhlIG9wZXJhdGlvbiBvbi5cclxuICAgICAqIEBwYXJhbSBpZCAtIEEgVGltZXIgSUQgaWRlbnRpZnlpbmcgdGhlIHR5cGUgb2Ygb3BlcmF0aW9uIHRoaXMgaXMuXHJcbiAgICAgKiBAcGFyYW0gZGVsYXlNcyAtIFRoZSBkZWxheSAobXMpIGJlZm9yZSB0aGUgb3BlcmF0aW9uIHNob3VsZCBiZSBzY2hlZHVsZWQuXHJcbiAgICAgKiBAcGFyYW0gb3AgLSBUaGUgb3BlcmF0aW9uIHRvIHJ1bi5cclxuICAgICAqIEBwYXJhbSByZW1vdmFsQ2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5IG9uY2UgdGhlXHJcbiAgICAgKiAgIG9wZXJhdGlvbiBpcyBleGVjdXRlZCBvciBjYW5jZWxlZCwgbm90aWZ5aW5nIHRoZSBBc3luY1F1ZXVlIHRvIHJlbW92ZSBpdFxyXG4gICAgICogICBmcm9tIGl0cyBkZWxheWVkT3BlcmF0aW9ucyBsaXN0LlxyXG4gICAgICogICBQT1JUSU5HIE5PVEU6IFRoaXMgZXhpc3RzIHRvIHByZXZlbnQgbWFraW5nIHJlbW92ZURlbGF5ZWRPcGVyYXRpb24oKSBhbmRcclxuICAgICAqICAgdGhlIERlbGF5ZWRPcGVyYXRpb24gY2xhc3MgcHVibGljLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlQW5kU2NoZWR1bGUoYXN5bmNRdWV1ZSwgdGltZXJJZCwgZGVsYXlNcywgb3AsIHJlbW92YWxDYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBEYXRlLm5vdygpICsgZGVsYXlNcztcclxuICAgICAgICBjb25zdCBkZWxheWVkT3AgPSBuZXcgRGVsYXllZE9wZXJhdGlvbihhc3luY1F1ZXVlLCB0aW1lcklkLCB0YXJnZXRUaW1lLCBvcCwgcmVtb3ZhbENhbGxiYWNrKTtcclxuICAgICAgICBkZWxheWVkT3Auc3RhcnQoZGVsYXlNcyk7XHJcbiAgICAgICAgcmV0dXJuIGRlbGF5ZWRPcDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIHRoZSB0aW1lci4gVGhpcyBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgY29uc3RydWN0aW9uIGJ5XHJcbiAgICAgKiBjcmVhdGVBbmRTY2hlZHVsZSgpLlxyXG4gICAgICovXHJcbiAgICBzdGFydChkZWxheU1zKSB7XHJcbiAgICAgICAgdGhpcy50aW1lckhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oYW5kbGVEZWxheUVsYXBzZWQoKSwgZGVsYXlNcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFF1ZXVlcyB0aGUgb3BlcmF0aW9uIHRvIHJ1biBpbW1lZGlhdGVseSAoaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBydW4gb3JcclxuICAgICAqIGNhbmNlbGVkKS5cclxuICAgICAqL1xyXG4gICAgc2tpcERlbGF5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZURlbGF5RWxhcHNlZCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW5jZWxzIHRoZSBvcGVyYXRpb24gaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBleGVjdXRlZCBvciBjYW5jZWxlZC4gVGhlXHJcbiAgICAgKiBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQXMgbG9uZyBhcyB0aGUgb3BlcmF0aW9uIGhhcyBub3QgeWV0IGJlZW4gcnVuLCBjYWxsaW5nIGNhbmNlbCgpIHByb3ZpZGVzIGFcclxuICAgICAqIGd1YXJhbnRlZSB0aGF0IHRoZSBvcGVyYXRpb24gd2lsbCBub3QgYmUgcnVuLlxyXG4gICAgICovXHJcbiAgICBjYW5jZWwocmVhc29uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZXJIYW5kbGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcclxuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuQ0FOQ0VMTEVELCAnT3BlcmF0aW9uIGNhbmNlbGxlZCcgKyAocmVhc29uID8gJzogJyArIHJlYXNvbiA6ICcnKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhbmRsZURlbGF5RWxhcHNlZCgpIHtcclxuICAgICAgICB0aGlzLmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVySGFuZGxlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AoKS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNsZWFyVGltZW91dCgpIHtcclxuICAgICAgICBpZiAodGhpcy50aW1lckhhbmRsZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92YWxDYWxsYmFjayh0aGlzKTtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJIYW5kbGUpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVySGFuZGxlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HX1RBRyA9ICdBc3luY1F1ZXVlJztcclxuY2xhc3MgQXN5bmNRdWV1ZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLy8gVGhlIGxhc3QgcHJvbWlzZSBpbiB0aGUgcXVldWUuXHJcbiAgICAgICAgdGhpcy50YWlsID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgLy8gQSBsaXN0IG9mIHJldHJ5YWJsZSBvcGVyYXRpb25zLiBSZXRyeWFibGUgb3BlcmF0aW9ucyBhcmUgcnVuIGluIG9yZGVyIGFuZFxyXG4gICAgICAgIC8vIHJldHJpZWQgd2l0aCBiYWNrb2ZmLlxyXG4gICAgICAgIHRoaXMucmV0cnlhYmxlT3BzID0gW107XHJcbiAgICAgICAgLy8gSXMgdGhpcyBBc3luY1F1ZXVlIGJlaW5nIHNodXQgZG93bj8gT25jZSBpdCBpcyBzZXQgdG8gdHJ1ZSwgaXQgd2lsbCBub3RcclxuICAgICAgICAvLyBiZSBjaGFuZ2VkIGFnYWluLlxyXG4gICAgICAgIHRoaXMuX2lzU2h1dHRpbmdEb3duID0gZmFsc2U7XHJcbiAgICAgICAgLy8gT3BlcmF0aW9ucyBzY2hlZHVsZWQgdG8gYmUgcXVldWVkIGluIHRoZSBmdXR1cmUuIE9wZXJhdGlvbnMgYXJlXHJcbiAgICAgICAgLy8gYXV0b21hdGljYWxseSByZW1vdmVkIGFmdGVyIHRoZXkgYXJlIHJ1biBvciBjYW5jZWxlZC5cclxuICAgICAgICB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zID0gW107XHJcbiAgICAgICAgLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xyXG4gICAgICAgIHRoaXMuZmFpbHVyZSA9IG51bGw7XHJcbiAgICAgICAgLy8gRmxhZyBzZXQgd2hpbGUgdGhlcmUncyBhbiBvdXRzdGFuZGluZyBBc3luY1F1ZXVlIG9wZXJhdGlvbiwgdXNlZCBmb3JcclxuICAgICAgICAvLyBhc3NlcnRpb24gc2FuaXR5LWNoZWNrcy5cclxuICAgICAgICB0aGlzLm9wZXJhdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcclxuICAgICAgICAvLyBFbmFibGVkIGR1cmluZyBzaHV0ZG93biBvbiBTYWZhcmkgdG8gcHJldmVudCBmdXR1cmUgYWNjZXNzIHRvIEluZGV4ZWREQi5cclxuICAgICAgICB0aGlzLnNraXBOb25SZXN0cmljdGVkVGFza3MgPSBmYWxzZTtcclxuICAgICAgICAvLyBMaXN0IG9mIFRpbWVySWRzIHRvIGZhc3QtZm9yd2FyZCBkZWxheXMgZm9yLlxyXG4gICAgICAgIHRoaXMudGltZXJJZHNUb1NraXAgPSBbXTtcclxuICAgICAgICAvLyBCYWNrb2ZmIHRpbWVyIHVzZWQgdG8gc2NoZWR1bGUgcmV0cmllcyBmb3IgcmV0cnlhYmxlIG9wZXJhdGlvbnNcclxuICAgICAgICB0aGlzLmJhY2tvZmYgPSBuZXcgRXhwb25lbnRpYWxCYWNrb2ZmKHRoaXMsIFwiYXN5bmNfcXVldWVfcmV0cnlcIiAvKiBUaW1lcklkLkFzeW5jUXVldWVSZXRyeSAqLyk7XHJcbiAgICAgICAgLy8gVmlzaWJpbGl0eSBoYW5kbGVyIHRoYXQgdHJpZ2dlcnMgYW4gaW1tZWRpYXRlIHJldHJ5IG9mIGFsbCByZXRyeWFibGVcclxuICAgICAgICAvLyBvcGVyYXRpb25zLiBNZWFudCB0byBzcGVlZCB1cCByZWNvdmVyeSB3aGVuIHdlIHJlZ2FpbiBmaWxlIHN5c3RlbSBhY2Nlc3NcclxuICAgICAgICAvLyBhZnRlciBwYWdlIGNvbWVzIGludG8gZm9yZWdyb3VuZC5cclxuICAgICAgICB0aGlzLnZpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYuc2tpcEJhY2tvZmYoKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzU2h1dHRpbmdEb3duKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NodXR0aW5nRG93bjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlIHdpdGhvdXQgd2FpdGluZyBmb3IgaXQgdG8gY29tcGxldGUgKGkuZS5cclxuICAgICAqIHdlIGlnbm9yZSB0aGUgUHJvbWlzZSByZXN1bHQpLlxyXG4gICAgICovXHJcbiAgICBlbnF1ZXVlQW5kRm9yZ2V0KG9wKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgIHRoaXMuZW5xdWV1ZShvcCk7XHJcbiAgICB9XHJcbiAgICBlbnF1ZXVlQW5kRm9yZ2V0RXZlbldoaWxlUmVzdHJpY3RlZChvcCkge1xyXG4gICAgICAgIHRoaXMudmVyaWZ5Tm90RmFpbGVkKCk7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgIHRoaXMuZW5xdWV1ZUludGVybmFsKG9wKTtcclxuICAgIH1cclxuICAgIGVudGVyUmVzdHJpY3RlZE1vZGUocHVyZ2VFeGlzdGluZ1Rhc2tzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc1NodXR0aW5nRG93bikge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1NodXR0aW5nRG93biA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc2tpcE5vblJlc3RyaWN0ZWRUYXNrcyA9IHB1cmdlRXhpc3RpbmdUYXNrcyB8fCBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbnF1ZXVlKG9wKSB7XHJcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RGYWlsZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5faXNTaHV0dGluZ0Rvd24pIHtcclxuICAgICAgICAgICAgLy8gUmV0dXJuIGEgUHJvbWlzZSB3aGljaCBuZXZlciByZXNvbHZlcy5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENyZWF0ZSBhIGRlZmVycmVkIFByb21pc2UgdGhhdCB3ZSBjYW4gcmV0dXJuIHRvIHRoZSBjYWxsZWUuIFRoaXNcclxuICAgICAgICAvLyBhbGxvd3MgdXMgdG8gcmV0dXJuIGEgXCJoYW5naW5nIFByb21pc2VcIiBvbmx5IHRvIHRoZSBjYWxsZWUgYW5kIHN0aWxsXHJcbiAgICAgICAgLy8gYWR2YW5jZSB0aGUgcXVldWUgZXZlbiB3aGVuIHRoZSBvcGVyYXRpb24gaXMgbm90IHJ1bi5cclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5xdWV1ZUludGVybmFsKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2h1dHRpbmdEb3duICYmIHRoaXMuc2tpcE5vblJlc3RyaWN0ZWRUYXNrcykge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gbm90IHJlc29sdmUgJ3Rhc2snXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AoKS50aGVuKHRhc2sucmVzb2x2ZSwgdGFzay5yZWplY3QpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGFzay5wcm9taXNlO1xyXG4gICAgICAgIH0pLnRoZW4oKCkgPT4gdGFzay5wcm9taXNlKTtcclxuICAgIH1cclxuICAgIGVucXVldWVSZXRyeWFibGUob3ApIHtcclxuICAgICAgICB0aGlzLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJldHJ5YWJsZU9wcy5wdXNoKG9wKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0cnlOZXh0T3AoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUnVucyB0aGUgbmV4dCBvcGVyYXRpb24gZnJvbSB0aGUgcmV0cnlhYmxlIHF1ZXVlLiBJZiB0aGUgb3BlcmF0aW9uIGZhaWxzLFxyXG4gICAgICogcmVzY2hlZHVsZXMgd2l0aCBiYWNrb2ZmLlxyXG4gICAgICovXHJcbiAgICBhc3luYyByZXRyeU5leHRPcCgpIHtcclxuICAgICAgICBpZiAodGhpcy5yZXRyeWFibGVPcHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZXRyeWFibGVPcHNbMF0oKTtcclxuICAgICAgICAgICAgdGhpcy5yZXRyeWFibGVPcHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUcsICdPcGVyYXRpb24gZmFpbGVkIHdpdGggcmV0cnlhYmxlIGVycm9yOiAnICsgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlOyAvLyBGYWlsdXJlIHdpbGwgYmUgaGFuZGxlZCBieSBBc3luY1F1ZXVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucmV0cnlhYmxlT3BzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGFkZGl0aW9uYWwgb3BlcmF0aW9ucywgd2UgcmUtc2NoZWR1bGUgYHJldHJ5TmV4dE9wKClgLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byBydW4gcmV0cnlhYmxlIG9wZXJhdGlvbnMgdGhhdCBmYWlsZWQgZHVyaW5nXHJcbiAgICAgICAgICAgIC8vIHRoZWlyIGluaXRpYWwgYXR0ZW1wdCBzaW5jZSB3ZSBkb24ndCBrbm93IHdoZXRoZXIgdGhleSBhcmUgYWxyZWFkeVxyXG4gICAgICAgICAgICAvLyBlbnF1ZXVlZC4gSWYsIGZvciBleGFtcGxlLCBgb3AxYCwgYG9wMmAsIGBvcDNgIGFyZSBlbnF1ZXVlZCBhbmQgYG9wMWBcclxuICAgICAgICAgICAgLy8gbmVlZHMgdG8gIGJlIHJlLXJ1biwgd2Ugd2lsbCBydW4gYG9wMWAsIGBvcDFgLCBgb3AyYCB1c2luZyB0aGVcclxuICAgICAgICAgICAgLy8gYWxyZWFkeSBlbnF1ZXVlZCBjYWxscyB0byBgcmV0cnlOZXh0T3AoKWAuIGBvcDMoKWAgd2lsbCB0aGVuIHJ1biBpbiB0aGVcclxuICAgICAgICAgICAgLy8gY2FsbCBzY2hlZHVsZWQgaGVyZS5cclxuICAgICAgICAgICAgLy8gU2luY2UgYGJhY2tvZmZBbmRSdW4oKWAgY2FuY2VscyBhbiBleGlzdGluZyBiYWNrb2ZmIGFuZCBzY2hlZHVsZXMgYVxyXG4gICAgICAgICAgICAvLyBuZXcgYmFja29mZiBvbiBldmVyeSBjYWxsLCB0aGVyZSBpcyBvbmx5IGV2ZXIgYSBzaW5nbGUgYWRkaXRpb25hbFxyXG4gICAgICAgICAgICAvLyBvcGVyYXRpb24gaW4gdGhlIHF1ZXVlLlxyXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYuYmFja29mZkFuZFJ1bigoKSA9PiB0aGlzLnJldHJ5TmV4dE9wKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVucXVldWVJbnRlcm5hbChvcCkge1xyXG4gICAgICAgIGNvbnN0IG5ld1RhaWwgPSB0aGlzLnRhaWwudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlcmF0aW9uSW5Qcm9ncmVzcyA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBvcCgpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWx1cmUgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgIHRoaXMub3BlcmF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdldE1lc3NhZ2VPclN0YWNrKGVycm9yKTtcclxuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdJTlRFUk5BTCBVTkhBTkRMRUQgRVJST1I6ICcsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlIGVycm9yIHNvIHRoYXQgdGhpcy50YWlsIGJlY29tZXMgYSByZWplY3RlZCBQcm9taXNlIGFuZFxyXG4gICAgICAgICAgICAgICAgLy8gYWxsIGZ1cnRoZXIgYXR0ZW1wdHMgdG8gY2hhaW4gKHZpYSAudGhlbikgd2lsbCBqdXN0IHNob3J0LWNpcmN1aXRcclxuICAgICAgICAgICAgICAgIC8vIGFuZCByZXR1cm4gdGhlIHJlamVjdGVkIFByb21pc2UuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wZXJhdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudGFpbCA9IG5ld1RhaWw7XHJcbiAgICAgICAgcmV0dXJuIG5ld1RhaWw7XHJcbiAgICB9XHJcbiAgICBlbnF1ZXVlQWZ0ZXJEZWxheSh0aW1lcklkLCBkZWxheU1zLCBvcCkge1xyXG4gICAgICAgIHRoaXMudmVyaWZ5Tm90RmFpbGVkKCk7XHJcbiAgICAgICAgLy8gRmFzdC1mb3J3YXJkIGRlbGF5cyBmb3IgdGltZXJJZHMgdGhhdCBoYXZlIGJlZW4gb3ZlcnJpZGVuLlxyXG4gICAgICAgIGlmICh0aGlzLnRpbWVySWRzVG9Ta2lwLmluZGV4T2YodGltZXJJZCkgPiAtMSkge1xyXG4gICAgICAgICAgICBkZWxheU1zID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGVsYXllZE9wID0gRGVsYXllZE9wZXJhdGlvbi5jcmVhdGVBbmRTY2hlZHVsZSh0aGlzLCB0aW1lcklkLCBkZWxheU1zLCBvcCwgcmVtb3ZlZE9wID0+IHRoaXMucmVtb3ZlRGVsYXllZE9wZXJhdGlvbihyZW1vdmVkT3ApKTtcclxuICAgICAgICB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zLnB1c2goZGVsYXllZE9wKTtcclxuICAgICAgICByZXR1cm4gZGVsYXllZE9wO1xyXG4gICAgfVxyXG4gICAgdmVyaWZ5Tm90RmFpbGVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZhaWx1cmUpIHtcclxuICAgICAgICAgICAgZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZlcmlmeU9wZXJhdGlvbkluUHJvZ3Jlc3MoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdhaXRzIHVudGlsIGFsbCBjdXJyZW50bHkgcXVldWVkIHRhc2tzIGFyZSBmaW5pc2hlZCBleGVjdXRpbmcuIERlbGF5ZWRcclxuICAgICAqIG9wZXJhdGlvbnMgYXJlIG5vdCBydW4uXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGRyYWluKCkge1xyXG4gICAgICAgIC8vIE9wZXJhdGlvbnMgaW4gdGhlIHF1ZXVlIHByaW9yIHRvIGRyYWluaW5nIG1heSBoYXZlIGVucXVldWVkIGFkZGl0aW9uYWxcclxuICAgICAgICAvLyBvcGVyYXRpb25zLiBLZWVwIGRyYWluaW5nIHRoZSBxdWV1ZSB1bnRpbCB0aGUgdGFpbCBpcyBubyBsb25nZXIgYWR2YW5jZWQsXHJcbiAgICAgICAgLy8gd2hpY2ggaW5kaWNhdGVzIHRoYXQgbm8gbW9yZSBuZXcgb3BlcmF0aW9ucyB3ZXJlIGVucXVldWVkIGFuZCB0aGF0IGFsbFxyXG4gICAgICAgIC8vIG9wZXJhdGlvbnMgd2VyZSBleGVjdXRlZC5cclxuICAgICAgICBsZXQgY3VycmVudFRhaWw7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBjdXJyZW50VGFpbCA9IHRoaXMudGFpbDtcclxuICAgICAgICAgICAgYXdhaXQgY3VycmVudFRhaWw7XHJcbiAgICAgICAgfSB3aGlsZSAoY3VycmVudFRhaWwgIT09IHRoaXMudGFpbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZvciBUZXN0czogRGV0ZXJtaW5lIGlmIGEgZGVsYXllZCBvcGVyYXRpb24gd2l0aCBhIHBhcnRpY3VsYXIgVGltZXJJZFxyXG4gICAgICogZXhpc3RzLlxyXG4gICAgICovXHJcbiAgICBjb250YWluc0RlbGF5ZWRPcGVyYXRpb24odGltZXJJZCkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgb3Agb2YgdGhpcy5kZWxheWVkT3BlcmF0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAob3AudGltZXJJZCA9PT0gdGltZXJJZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgVGVzdHM6IFJ1bnMgc29tZSBvciBhbGwgZGVsYXllZCBvcGVyYXRpb25zIGVhcmx5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXN0VGltZXJJZCAtIERlbGF5ZWQgb3BlcmF0aW9ucyB1cCB0byBhbmQgaW5jbHVkaW5nIHRoaXMgVGltZXJJZFxyXG4gICAgICogd2lsbCBiZSBkcmFpbmVkLiBQYXNzIFRpbWVySWQuQWxsIHRvIHJ1biBhbGwgZGVsYXllZCBvcGVyYXRpb25zLlxyXG4gICAgICogQHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSBhbGwgb3BlcmF0aW9ucyBoYXZlIGJlZW4gcnVuLlxyXG4gICAgICovXHJcbiAgICBydW5BbGxEZWxheWVkT3BlcmF0aW9uc1VudGlsKGxhc3RUaW1lcklkKSB7XHJcbiAgICAgICAgLy8gTm90ZSB0aGF0IGRyYWluaW5nIG1heSBnZW5lcmF0ZSBtb3JlIGRlbGF5ZWQgb3BzLCBzbyB3ZSBkbyB0aGF0IGZpcnN0LlxyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWluKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFJ1biBvcHMgaW4gdGhlIHNhbWUgb3JkZXIgdGhleSdkIHJ1biBpZiB0aGV5IHJhbiBuYXR1cmFsbHkuXHJcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZE9wZXJhdGlvbnMuc29ydCgoYSwgYikgPT4gYS50YXJnZXRUaW1lTXMgLSBiLnRhcmdldFRpbWVNcyk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3Agb2YgdGhpcy5kZWxheWVkT3BlcmF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgb3Auc2tpcERlbGF5KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRpbWVySWQgIT09IFwiYWxsXCIgLyogVGltZXJJZC5BbGwgKi8gJiYgb3AudGltZXJJZCA9PT0gbGFzdFRpbWVySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcmFpbigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgVGVzdHM6IFNraXAgYWxsIHN1YnNlcXVlbnQgZGVsYXlzIGZvciBhIHRpbWVyIGlkLlxyXG4gICAgICovXHJcbiAgICBza2lwRGVsYXlzRm9yVGltZXJJZCh0aW1lcklkKSB7XHJcbiAgICAgICAgdGhpcy50aW1lcklkc1RvU2tpcC5wdXNoKHRpbWVySWQpO1xyXG4gICAgfVxyXG4gICAgLyoqIENhbGxlZCBvbmNlIGEgRGVsYXllZE9wZXJhdGlvbiBpcyBydW4gb3IgY2FuY2VsZWQuICovXHJcbiAgICByZW1vdmVEZWxheWVkT3BlcmF0aW9uKG9wKSB7XHJcbiAgICAgICAgLy8gTk9URTogaW5kZXhPZiAvIHNsaWNlIGFyZSBPKG4pLCBidXQgZGVsYXllZE9wZXJhdGlvbnMgaXMgZXhwZWN0ZWQgdG8gYmUgc21hbGwuXHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zLmluZGV4T2Yob3ApO1xyXG4gICAgICAgIHRoaXMuZGVsYXllZE9wZXJhdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXdBc3luY1F1ZXVlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBBc3luY1F1ZXVlSW1wbCgpO1xyXG59XHJcbi8qKlxyXG4gKiBDaHJvbWUgaW5jbHVkZXMgRXJyb3IubWVzc2FnZSBpbiBFcnJvci5zdGFjay4gT3RoZXIgYnJvd3NlcnMgZG8gbm90LlxyXG4gKiBUaGlzIHJldHVybnMgZXhwZWN0ZWQgb3V0cHV0IG9mIG1lc3NhZ2UgKyBzdGFjayB3aGVuIGF2YWlsYWJsZS5cclxuICogQHBhcmFtIGVycm9yIC0gRXJyb3Igb3IgRmlyZXN0b3JlRXJyb3JcclxuICovXHJcbmZ1bmN0aW9uIGdldE1lc3NhZ2VPclN0YWNrKGVycm9yKSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHwgJyc7XHJcbiAgICBpZiAoZXJyb3Iuc3RhY2spIHtcclxuICAgICAgICBpZiAoZXJyb3Iuc3RhY2suaW5jbHVkZXMoZXJyb3IubWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLnN0YWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgKyAnXFxuJyArIGVycm9yLnN0YWNrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtZXNzYWdlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIFRPRE8obXJzY2htaWR0KSBDb25zaWRlciB1c2luZyBgQmFzZVRyYW5zYWN0aW9uYCBhcyB0aGUgYmFzZSBjbGFzcyBpbiB0aGVcclxuLy8gbGVnYWN5IFNESy5cclxuLyoqXHJcbiAqIEEgcmVmZXJlbmNlIHRvIGEgdHJhbnNhY3Rpb24uXHJcbiAqXHJcbiAqIFRoZSBgVHJhbnNhY3Rpb25gIG9iamVjdCBwYXNzZWQgdG8gYSB0cmFuc2FjdGlvbidzIGB1cGRhdGVGdW5jdGlvbmAgcHJvdmlkZXNcclxuICogdGhlIG1ldGhvZHMgdG8gcmVhZCBhbmQgd3JpdGUgZGF0YSB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIGNvbnRleHQuIFNlZVxyXG4gKiB7QGxpbmsgcnVuVHJhbnNhY3Rpb259LlxyXG4gKi9cclxuY2xhc3MgVHJhbnNhY3Rpb24ge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9maXJlc3RvcmUsIF90cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSBfdHJhbnNhY3Rpb247XHJcbiAgICAgICAgdGhpcy5fZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKF9maXJlc3RvcmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyB0aGUgZG9jdW1lbnQgcmVmZXJlbmNlZCBieSB0aGUgcHJvdmlkZWQge0BsaW5rIERvY3VtZW50UmVmZXJlbmNlfS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRSZWYgLSBBIHJlZmVyZW5jZSB0byB0aGUgZG9jdW1lbnQgdG8gYmUgcmVhZC5cclxuICAgICAqIEByZXR1cm5zIEEgYERvY3VtZW50U25hcHNob3RgIHdpdGggdGhlIHJlYWQgZGF0YS5cclxuICAgICAqL1xyXG4gICAgZ2V0KGRvY3VtZW50UmVmKSB7XHJcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgTGl0ZVVzZXJEYXRhV3JpdGVyKHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uLmxvb2t1cChbcmVmLl9rZXldKS50aGVuKGRvY3MgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWRvY3MgfHwgZG9jcy5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZG9jID0gZG9jc1swXTtcclxuICAgICAgICAgICAgaWYgKGRvYy5pc0ZvdW5kRG9jdW1lbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFNuYXBzaG90KHRoaXMuX2ZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIGRvYy5rZXksIGRvYywgcmVmLmNvbnZlcnRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZG9jLmlzTm9Eb2N1bWVudCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50U25hcHNob3QodGhpcy5fZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcmVmLl9rZXksIG51bGwsIHJlZi5jb252ZXJ0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzZXQoZG9jdW1lbnRSZWYsIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBhcHBseUZpcmVzdG9yZURhdGFDb252ZXJ0ZXIocmVmLmNvbnZlcnRlciwgdmFsdWUsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2V0RGF0YSh0aGlzLl9kYXRhUmVhZGVyLCAnVHJhbnNhY3Rpb24uc2V0JywgcmVmLl9rZXksIGNvbnZlcnRlZFZhbHVlLCByZWYuY29udmVydGVyICE9PSBudWxsLCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbi5zZXQocmVmLl9rZXksIHBhcnNlZCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZG9jdW1lbnRSZWYsIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgLi4ubW9yZUZpZWxkc0FuZFZhbHVlcykge1xyXG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xyXG4gICAgICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXHJcbiAgICAgICAgLy8gcGVyZm9ybWluZyB2YWxpZGF0aW9uLlxyXG4gICAgICAgIGZpZWxkT3JVcGRhdGVEYXRhID0gZ2V0TW9kdWxhckluc3RhbmNlKGZpZWxkT3JVcGRhdGVEYXRhKTtcclxuICAgICAgICBsZXQgcGFyc2VkO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRPclVwZGF0ZURhdGEgPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgICAgIGZpZWxkT3JVcGRhdGVEYXRhIGluc3RhbmNlb2YgRmllbGRQYXRoKSB7XHJcbiAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlVXBkYXRlVmFyYXJncyh0aGlzLl9kYXRhUmVhZGVyLCAnVHJhbnNhY3Rpb24udXBkYXRlJywgcmVmLl9rZXksIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgbW9yZUZpZWxkc0FuZFZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZURhdGEodGhpcy5fZGF0YVJlYWRlciwgJ1RyYW5zYWN0aW9uLnVwZGF0ZScsIHJlZi5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uLnVwZGF0ZShyZWYuX2tleSwgcGFyc2VkKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhlIHByb3ZpZGVkIHtAbGluayBEb2N1bWVudFJlZmVyZW5jZX0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRvY3VtZW50UmVmIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGJlIGRlbGV0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGlzIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIFVzZWQgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICAgICAqL1xyXG4gICAgZGVsZXRlKGRvY3VtZW50UmVmKSB7XHJcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24uZGVsZXRlKHJlZi5fa2V5KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXhlY3V0ZXMgdGhlIGdpdmVuIGB1cGRhdGVGdW5jdGlvbmAgYW5kIHRoZW4gYXR0ZW1wdHMgdG8gY29tbWl0IHRoZSBjaGFuZ2VzXHJcbiAqIGFwcGxpZWQgd2l0aGluIHRoZSB0cmFuc2FjdGlvbi4gSWYgYW55IGRvY3VtZW50IHJlYWQgd2l0aGluIHRoZSB0cmFuc2FjdGlvblxyXG4gKiBoYXMgY2hhbmdlZCwgQ2xvdWQgRmlyZXN0b3JlIHJldHJpZXMgdGhlIGB1cGRhdGVGdW5jdGlvbmAuIElmIGl0IGZhaWxzIHRvXHJcbiAqIGNvbW1pdCBhZnRlciA1IGF0dGVtcHRzLCB0aGUgdHJhbnNhY3Rpb24gZmFpbHMuXHJcbiAqXHJcbiAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiB3cml0ZXMgYWxsb3dlZCBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvbiBpcyA1MDAuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBBIHJlZmVyZW5jZSB0byB0aGUgRmlyZXN0b3JlIGRhdGFiYXNlIHRvIHJ1biB0aGlzXHJcbiAqIHRyYW5zYWN0aW9uIGFnYWluc3QuXHJcbiAqIEBwYXJhbSB1cGRhdGVGdW5jdGlvbiAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb25cclxuICogY29udGV4dC5cclxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdCB0byBjb25maWd1cmUgbWF4aW11bSBudW1iZXIgb2YgYXR0ZW1wdHMgdG9cclxuICogY29tbWl0LlxyXG4gKiBAcmV0dXJucyBJZiB0aGUgdHJhbnNhY3Rpb24gY29tcGxldGVkIHN1Y2Nlc3NmdWxseSBvciB3YXMgZXhwbGljaXRseSBhYm9ydGVkXHJcbiAqICh0aGUgYHVwZGF0ZUZ1bmN0aW9uYCByZXR1cm5lZCBhIGZhaWxlZCBwcm9taXNlKSwgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlXHJcbiAqIGB1cGRhdGVGdW5jdGlvbiBgaXMgcmV0dXJuZWQgaGVyZS4gT3RoZXJ3aXNlLCBpZiB0aGUgdHJhbnNhY3Rpb24gZmFpbGVkLCBhXHJcbiAqIHJlamVjdGVkIHByb21pc2Ugd2l0aCB0aGUgY29ycmVzcG9uZGluZyBmYWlsdXJlIGVycm9yIGlzIHJldHVybmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gcnVuVHJhbnNhY3Rpb24oZmlyZXN0b3JlLCB1cGRhdGVGdW5jdGlvbiwgb3B0aW9ucykge1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBkYXRhc3RvcmUgPSBnZXREYXRhc3RvcmUoZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IG9wdGlvbnNXaXRoRGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfVFJBTlNBQ1RJT05fT1BUSU9OUyksIG9wdGlvbnMpO1xyXG4gICAgdmFsaWRhdGVUcmFuc2FjdGlvbk9wdGlvbnMob3B0aW9uc1dpdGhEZWZhdWx0cyk7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgbmV3IFRyYW5zYWN0aW9uUnVubmVyKG5ld0FzeW5jUXVldWUoKSwgZGF0YXN0b3JlLCBvcHRpb25zV2l0aERlZmF1bHRzLCBpbnRlcm5hbFRyYW5zYWN0aW9uID0+IHVwZGF0ZUZ1bmN0aW9uKG5ldyBUcmFuc2FjdGlvbihmaXJlc3RvcmUsIGludGVybmFsVHJhbnNhY3Rpb24pKSwgZGVmZXJyZWQpLnJ1bigpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cblxuLyoqXHJcbiAqIEZpcmVzdG9yZSBMaXRlXHJcbiAqXHJcbiAqIEByZW1hcmtzIEZpcmVzdG9yZSBMaXRlIGlzIGEgc21hbGwgb25saW5lLW9ubHkgU0RLIHRoYXQgYWxsb3dzIHJlYWRcclxuICogYW5kIHdyaXRlIGFjY2VzcyB0byB5b3VyIEZpcmVzdG9yZSBkYXRhYmFzZS4gQWxsIG9wZXJhdGlvbnMgY29ubmVjdFxyXG4gKiBkaXJlY3RseSB0byB0aGUgYmFja2VuZCwgYW5kIGBvblNuYXBzaG90KClgIEFQSXMgYXJlIG5vdCBzdXBwb3J0ZWQuXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cclxucmVnaXN0ZXJGaXJlc3RvcmUoKTtcblxuZXhwb3J0IHsgQWdncmVnYXRlRmllbGQsIEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QsIEJ5dGVzLCBDb2xsZWN0aW9uUmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSwgRG9jdW1lbnRTbmFwc2hvdCwgRmllbGRQYXRoLCBGaWVsZFZhbHVlLCBGaXJlc3RvcmUsIEZpcmVzdG9yZUVycm9yLCBHZW9Qb2ludCwgUXVlcnksIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCwgUXVlcnlDb25zdHJhaW50LCBRdWVyeURvY3VtZW50U25hcHNob3QsIFF1ZXJ5RW5kQXRDb25zdHJhaW50LCBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludCwgUXVlcnlMaW1pdENvbnN0cmFpbnQsIFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnQsIFF1ZXJ5U25hcHNob3QsIFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQsIFRpbWVzdGFtcCwgVHJhbnNhY3Rpb24sIFdyaXRlQmF0Y2gsIGFkZERvYywgYWdncmVnYXRlRmllbGRFcXVhbCwgYWdncmVnYXRlUXVlcnlTbmFwc2hvdEVxdWFsLCBhbmQsIGFycmF5UmVtb3ZlLCBhcnJheVVuaW9uLCBhdmVyYWdlLCBjb2xsZWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvciwgY291bnQsIGRlbGV0ZURvYywgZGVsZXRlRmllbGQsIGRvYywgZG9jdW1lbnRJZCwgZW5kQXQsIGVuZEJlZm9yZSwgZ2V0QWdncmVnYXRlLCBnZXRDb3VudCwgZ2V0RG9jLCBnZXREb2NzLCBnZXRGaXJlc3RvcmUsIGluY3JlbWVudCwgaW5pdGlhbGl6ZUZpcmVzdG9yZSwgbGltaXQsIGxpbWl0VG9MYXN0LCBvciwgb3JkZXJCeSwgcXVlcnksIHF1ZXJ5RXF1YWwsIHJlZkVxdWFsLCBydW5UcmFuc2FjdGlvbiwgc2VydmVyVGltZXN0YW1wLCBzZXREb2MsIHNldExvZ0xldmVsLCBzbmFwc2hvdEVxdWFsLCBzdGFydEFmdGVyLCBzdGFydEF0LCBzdW0sIHRlcm1pbmF0ZSwgdXBkYXRlRG9jLCB3aGVyZSwgd3JpdGVCYXRjaCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4iXSwibmFtZXMiOlsiX2dldFByb3ZpZGVyIiwiZ2V0QXBwIiwiX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSIsIl9yZWdpc3RlckNvbXBvbmVudCIsInJlZ2lzdGVyVmVyc2lvbiIsIlNES19WRVJTSU9OIiwiU0RLX1ZFUlNJT04kMSIsIkNvbXBvbmVudCIsIkxvZ2dlciIsIkxvZ0xldmVsIiwiaW5zcGVjdCIsIkZpcmViYXNlRXJyb3IiLCJnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQiLCJjcmVhdGVNb2NrVXNlclRva2VuIiwiZ2V0TW9kdWxhckluc3RhbmNlIiwiZGVlcEVxdWFsIiwiZmV0Y2giLCJyYW5kb21CeXRlcyIsInJhbmRvbUJ5dGVzJDEiLCJ2ZXJzaW9uJDEiLCJVc2VyIiwiY29uc3RydWN0b3IiLCJ1aWQiLCJpc0F1dGhlbnRpY2F0ZWQiLCJ0b0tleSIsImlzRXF1YWwiLCJvdGhlclVzZXIiLCJVTkFVVEhFTlRJQ0FURUQiLCJHT09HTEVfQ1JFREVOVElBTFMiLCJGSVJTVF9QQVJUWSIsIk1PQ0tfVVNFUiIsInZlcnNpb24iLCJzZXRTREtWZXJzaW9uIiwiZm9ybWF0SlNPTiIsInZhbHVlIiwiZGVwdGgiLCJsb2dDbGllbnQiLCJzZXRMb2dMZXZlbCIsImxvZ0xldmVsIiwibG9nRGVidWciLCJtc2ciLCJvYmoiLCJERUJVRyIsImFyZ3MiLCJtYXAiLCJhcmdUb1N0cmluZyIsImRlYnVnIiwibG9nRXJyb3IiLCJFUlJPUiIsImVycm9yIiwibG9nV2FybiIsIldBUk4iLCJ3YXJuIiwiZSIsImZhaWwiLCJmYWlsdXJlIiwibWVzc2FnZSIsIkVycm9yIiwiaGFyZEFzc2VydCIsImFzc2VydGlvbiIsImRlYnVnQ2FzdCIsIkNvZGUiLCJPSyIsIkNBTkNFTExFRCIsIlVOS05PV04iLCJJTlZBTElEX0FSR1VNRU5UIiwiREVBRExJTkVfRVhDRUVERUQiLCJOT1RfRk9VTkQiLCJBTFJFQURZX0VYSVNUUyIsIlBFUk1JU1NJT05fREVOSUVEIiwiUkVTT1VSQ0VfRVhIQVVTVEVEIiwiRkFJTEVEX1BSRUNPTkRJVElPTiIsIkFCT1JURUQiLCJPVVRfT0ZfUkFOR0UiLCJVTklNUExFTUVOVEVEIiwiSU5URVJOQUwiLCJVTkFWQUlMQUJMRSIsIkRBVEFfTE9TUyIsIkZpcmVzdG9yZUVycm9yIiwiY29kZSIsInRvU3RyaW5nIiwibmFtZSIsIkRlZmVycmVkIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiT0F1dGhUb2tlbiIsInVzZXIiLCJ0eXBlIiwiaGVhZGVycyIsIk1hcCIsInNldCIsIkVtcHR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIiLCJnZXRUb2tlbiIsImludmFsaWRhdGVUb2tlbiIsInN0YXJ0IiwiYXN5bmNRdWV1ZSIsImNoYW5nZUxpc3RlbmVyIiwiZW5xdWV1ZVJldHJ5YWJsZSIsInNodXRkb3duIiwiRW11bGF0b3JBdXRoQ3JlZGVudGlhbHNQcm92aWRlciIsInRva2VuIiwiTGl0ZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIiwiYXV0aFByb3ZpZGVyIiwiYXV0aCIsIm9uSW5pdCIsInRoZW4iLCJ0b2tlbkRhdGEiLCJhY2Nlc3NUb2tlbiIsImdldFVpZCIsIkZpcnN0UGFydHlUb2tlbiIsInNlc3Npb25JbmRleCIsImlhbVRva2VuIiwiYXV0aFRva2VuRmFjdG9yeSIsIl9oZWFkZXJzIiwiZ2V0QXV0aFRva2VuIiwiYXV0aEhlYWRlclRva2VuVmFsdWUiLCJGaXJzdFBhcnR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIiLCJBcHBDaGVja1Rva2VuIiwibGVuZ3RoIiwiTGl0ZUFwcENoZWNrVG9rZW5Qcm92aWRlciIsImFwcENoZWNrUHJvdmlkZXIiLCJhcHBDaGVjayIsInRva2VuUmVzdWx0IiwibWFrZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIiwiY3JlZGVudGlhbHMiLCJEYXRhYmFzZUluZm8iLCJkYXRhYmFzZUlkIiwiYXBwSWQiLCJwZXJzaXN0ZW5jZUtleSIsImhvc3QiLCJzc2wiLCJmb3JjZUxvbmdQb2xsaW5nIiwiYXV0b0RldGVjdExvbmdQb2xsaW5nIiwibG9uZ1BvbGxpbmdPcHRpb25zIiwidXNlRmV0Y2hTdHJlYW1zIiwiREVGQVVMVF9EQVRBQkFTRV9OQU1FIiwiRGF0YWJhc2VJZCIsInByb2plY3RJZCIsImRhdGFiYXNlIiwiZW1wdHkiLCJpc0RlZmF1bHREYXRhYmFzZSIsIm90aGVyIiwiZGF0YWJhc2VJZEZyb21BcHAiLCJhcHAiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImFwcGx5Iiwib3B0aW9ucyIsIkRPQ1VNRU5UX0tFWV9OQU1FIiwiQmFzZVBhdGgiLCJzZWdtZW50cyIsIm9mZnNldCIsInVuZGVmaW5lZCIsImxlbiIsImNvbXBhcmF0b3IiLCJjaGlsZCIsIm5hbWVPclBhdGgiLCJzbGljZSIsImxpbWl0IiwiZm9yRWFjaCIsInNlZ21lbnQiLCJwdXNoIiwiY29uc3RydWN0IiwicG9wRmlyc3QiLCJzaXplIiwicG9wTGFzdCIsImZpcnN0U2VnbWVudCIsImxhc3RTZWdtZW50IiwiZ2V0IiwiaW5kZXgiLCJpc0VtcHR5IiwiaXNQcmVmaXhPZiIsImkiLCJpc0ltbWVkaWF0ZVBhcmVudE9mIiwicG90ZW50aWFsQ2hpbGQiLCJmbiIsImVuZCIsInRvQXJyYXkiLCJwMSIsInAyIiwiTWF0aCIsIm1pbiIsImxlZnQiLCJyaWdodCIsIlJlc291cmNlUGF0aCIsImNhbm9uaWNhbFN0cmluZyIsImpvaW4iLCJ0b1VyaUVuY29kZWRTdHJpbmciLCJlbmNvZGVVUklDb21wb25lbnQiLCJmcm9tU3RyaW5nIiwicGF0aENvbXBvbmVudHMiLCJwYXRoIiwiaW5kZXhPZiIsInNwbGl0IiwiZmlsdGVyIiwiZW1wdHlQYXRoIiwiaWRlbnRpZmllclJlZ0V4cCIsIkZpZWxkUGF0aCQxIiwiaXNWYWxpZElkZW50aWZpZXIiLCJ0ZXN0Iiwic3RyIiwicmVwbGFjZSIsImlzS2V5RmllbGQiLCJrZXlGaWVsZCIsImZyb21TZXJ2ZXJGb3JtYXQiLCJjdXJyZW50IiwiYWRkQ3VycmVudFNlZ21lbnQiLCJpbkJhY2t0aWNrcyIsImMiLCJuZXh0IiwiRG9jdW1lbnRLZXkiLCJmcm9tUGF0aCIsImZyb21OYW1lIiwiY29sbGVjdGlvbkdyb3VwIiwiaGFzQ29sbGVjdGlvbklkIiwiY29sbGVjdGlvbklkIiwiZ2V0Q29sbGVjdGlvbkdyb3VwIiwiZ2V0Q29sbGVjdGlvblBhdGgiLCJrMSIsImsyIiwiaXNEb2N1bWVudEtleSIsImZyb21TZWdtZW50cyIsInZhbGlkYXRlTm9uRW1wdHlBcmd1bWVudCIsImZ1bmN0aW9uTmFtZSIsImFyZ3VtZW50TmFtZSIsImFyZ3VtZW50IiwidmFsaWRhdGVJc05vdFVzZWRUb2dldGhlciIsIm9wdGlvbk5hbWUxIiwiYXJndW1lbnQxIiwib3B0aW9uTmFtZTIiLCJhcmd1bWVudDIiLCJ2YWxpZGF0ZURvY3VtZW50UGF0aCIsInZhbGlkYXRlQ29sbGVjdGlvblBhdGgiLCJpc1BsYWluT2JqZWN0IiwiaW5wdXQiLCJnZXRQcm90b3R5cGVPZiIsInZhbHVlRGVzY3JpcHRpb24iLCJzdWJzdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwiQXJyYXkiLCJjdXN0b21PYmplY3ROYW1lIiwidHJ5R2V0Q3VzdG9tT2JqZWN0VHlwZSIsImNhc3QiLCJfZGVsZWdhdGUiLCJkZXNjcmlwdGlvbiIsInZhbGlkYXRlUG9zaXRpdmVOdW1iZXIiLCJuIiwibG9uZ1BvbGxpbmdPcHRpb25zRXF1YWwiLCJvcHRpb25zMSIsIm9wdGlvbnMyIiwidGltZW91dFNlY29uZHMiLCJjbG9uZUxvbmdQb2xsaW5nT3B0aW9ucyIsImNsb25lIiwibGFzdFVuaXF1ZURlYnVnSWQiLCJnZW5lcmF0ZUluaXRpYWxVbmlxdWVEZWJ1Z0lkIiwibWluUmVzdWx0IiwibWF4UmVzdWx0IiwicmVzdWx0UmFuZ2UiLCJyZXN1bHRPZmZzZXQiLCJyb3VuZCIsInJhbmRvbSIsImdlbmVyYXRlVW5pcXVlRGVidWdJZCIsIkxPR19UQUckMyIsIlJQQ19OQU1FX1VSTF9NQVBQSU5HIiwiUlBDX1VSTF9WRVJTSU9OIiwiZ2V0R29vZ0FwaUNsaWVudFZhbHVlIiwiUmVzdENvbm5lY3Rpb24iLCJkYXRhYmFzZUluZm8iLCJwcm90byIsImJhc2VVcmwiLCJkYXRhYmFzZVBhdGgiLCJyZXF1ZXN0UGFyYW1zIiwic2hvdWxkUmVzb3VyY2VQYXRoQmVJbmNsdWRlZEluUmVxdWVzdCIsImludm9rZVJQQyIsInJwY05hbWUiLCJyZXEiLCJhdXRoVG9rZW4iLCJhcHBDaGVja1Rva2VuIiwic3RyZWFtSWQiLCJ1cmwiLCJtYWtlVXJsIiwibW9kaWZ5SGVhZGVyc0ZvclJlcXVlc3QiLCJwZXJmb3JtUlBDUmVxdWVzdCIsInJlc3BvbnNlIiwiZXJyIiwiaW52b2tlU3RyZWFtaW5nUlBDIiwicmVxdWVzdCIsImV4cGVjdGVkUmVzcG9uc2VDb3VudCIsImtleSIsInVybFJwY05hbWUiLCJ0ZXJtaW5hdGUiLCJScGNDb2RlIiwiaXNQZXJtYW5lbnRFcnJvciIsIm1hcENvZGVGcm9tSHR0cFN0YXR1cyIsInN0YXR1cyIsIkZldGNoQ29ubmVjdGlvbiIsImZldGNoSW1wbCIsIm9wZW5TdHJlYW0iLCJib2R5IiwiX2EiLCJyZXF1ZXN0SnNvbiIsIm1ldGhvZCIsInN0YXR1c1RleHQiLCJvayIsImVycm9yUmVzcG9uc2UiLCJqc29uIiwiaXNBcnJheSIsImVycm9yTWVzc2FnZSIsIm5ld0Nvbm5lY3Rpb24iLCJuQnl0ZXMiLCJBdXRvSWQiLCJuZXdJZCIsImNoYXJzIiwibWF4TXVsdGlwbGUiLCJmbG9vciIsImF1dG9JZCIsInRhcmdldExlbmd0aCIsImJ5dGVzIiwiY2hhckF0IiwicHJpbWl0aXZlQ29tcGFyYXRvciIsImFycmF5RXF1YWxzIiwiZXZlcnkiLCJvYmplY3RTaXplIiwiY291bnQiLCJjYWxsIiwibWFwVG9BcnJheSIsInJlc3VsdCIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNOZWdhdGl2ZVplcm8iLCJpc1NhZmVJbnRlZ2VyIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiTUFYX1NBRkVfSU5URUdFUiIsIk1JTl9TQUZFX0lOVEVHRVIiLCJkZWNvZGVCYXNlNjQiLCJlbmNvZGVkIiwiQnVmZmVyIiwiZnJvbSIsImVuY29kZUJhc2U2NCIsInJhdyIsIkJ5dGVTdHJpbmciLCJiaW5hcnlTdHJpbmciLCJmcm9tQmFzZTY0U3RyaW5nIiwiYmFzZTY0IiwiZnJvbVVpbnQ4QXJyYXkiLCJhcnJheSIsImJpbmFyeVN0cmluZ0Zyb21VaW50OEFycmF5IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjaGFyQ29kZUF0IiwiZG9uZSIsInRvQmFzZTY0IiwidG9VaW50OEFycmF5IiwidWludDhBcnJheUZyb21CaW5hcnlTdHJpbmciLCJhcHByb3hpbWF0ZUJ5dGVTaXplIiwiY29tcGFyZVRvIiwiRU1QVFlfQllURV9TVFJJTkciLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJidWZmZXIiLCJVaW50OEFycmF5IiwiSVNPX1RJTUVTVEFNUF9SRUdfRVhQIiwiUmVnRXhwIiwibm9ybWFsaXplVGltZXN0YW1wIiwiZGF0ZSIsIm5hbm9zIiwiZnJhY3Rpb24iLCJleGVjIiwibmFub1N0ciIsInN1YnN0ciIsInBhcnNlZERhdGUiLCJEYXRlIiwic2Vjb25kcyIsImdldFRpbWUiLCJub3JtYWxpemVOdW1iZXIiLCJub3JtYWxpemVCeXRlU3RyaW5nIiwiYmxvYiIsIk1JTl9TRUNPTkRTIiwiTVNfVE9fTkFOT1MiLCJUaW1lc3RhbXAiLCJuYW5vc2Vjb25kcyIsIm5vdyIsImZyb21NaWxsaXMiLCJmcm9tRGF0ZSIsIm1pbGxpc2Vjb25kcyIsInRvRGF0ZSIsInRvTWlsbGlzIiwiX2NvbXBhcmVUbyIsInRvSlNPTiIsInZhbHVlT2YiLCJhZGp1c3RlZFNlY29uZHMiLCJmb3JtYXR0ZWRTZWNvbmRzIiwicGFkU3RhcnQiLCJmb3JtYXR0ZWROYW5vc2Vjb25kcyIsIlNFUlZFUl9USU1FU1RBTVBfU0VOVElORUwiLCJUWVBFX0tFWSIsIlBSRVZJT1VTX1ZBTFVFX0tFWSIsIkxPQ0FMX1dSSVRFX1RJTUVfS0VZIiwiaXNTZXJ2ZXJUaW1lc3RhbXAiLCJfYiIsIm1hcFZhbHVlIiwiZmllbGRzIiwic3RyaW5nVmFsdWUiLCJnZXRQcmV2aW91c1ZhbHVlIiwicHJldmlvdXNWYWx1ZSIsImdldExvY2FsV3JpdGVUaW1lIiwibG9jYWxXcml0ZVRpbWUiLCJ0aW1lc3RhbXBWYWx1ZSIsIk1BWF9WQUxVRV9UWVBFIiwiTUFYX1ZBTFVFIiwidHlwZU9yZGVyIiwiaXNNYXhWYWx1ZSIsInZhbHVlRXF1YWxzIiwibGVmdFR5cGUiLCJyaWdodFR5cGUiLCJib29sZWFuVmFsdWUiLCJ0aW1lc3RhbXBFcXVhbHMiLCJibG9iRXF1YWxzIiwicmVmZXJlbmNlVmFsdWUiLCJnZW9Qb2ludEVxdWFscyIsIm51bWJlckVxdWFscyIsImFycmF5VmFsdWUiLCJ2YWx1ZXMiLCJvYmplY3RFcXVhbHMiLCJsZWZ0VGltZXN0YW1wIiwicmlnaHRUaW1lc3RhbXAiLCJnZW9Qb2ludFZhbHVlIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJieXRlc1ZhbHVlIiwiaW50ZWdlclZhbHVlIiwibjEiLCJkb3VibGVWYWx1ZSIsIm4yIiwiaXNOYU4iLCJsZWZ0TWFwIiwicmlnaHRNYXAiLCJhcnJheVZhbHVlQ29udGFpbnMiLCJoYXlzdGFjayIsIm5lZWRsZSIsImZpbmQiLCJ2IiwidmFsdWVDb21wYXJlIiwiY29tcGFyZU51bWJlcnMiLCJjb21wYXJlVGltZXN0YW1wcyIsImNvbXBhcmVCbG9icyIsImNvbXBhcmVSZWZlcmVuY2VzIiwiY29tcGFyZUdlb1BvaW50cyIsImNvbXBhcmVBcnJheXMiLCJjb21wYXJlTWFwcyIsImxlZnROdW1iZXIiLCJyaWdodE51bWJlciIsImNvbXBhcmlzb24iLCJsZWZ0UGF0aCIsInJpZ2h0UGF0aCIsImxlZnRTZWdtZW50cyIsInJpZ2h0U2VnbWVudHMiLCJsZWZ0Qnl0ZXMiLCJyaWdodEJ5dGVzIiwibGVmdEFycmF5IiwicmlnaHRBcnJheSIsImNvbXBhcmUiLCJsZWZ0S2V5cyIsImtleXMiLCJyaWdodEtleXMiLCJzb3J0Iiwia2V5Q29tcGFyZSIsInJlZlZhbHVlIiwiaXNOdWxsVmFsdWUiLCJpc05hblZhbHVlIiwiaXNNYXBWYWx1ZSIsImRlZXBDbG9uZSIsInNvdXJjZSIsImFzc2lnbiIsInRhcmdldCIsInZhbCIsIkJvdW5kIiwicG9zaXRpb24iLCJpbmNsdXNpdmUiLCJib3VuZEVxdWFscyIsImxlZnRQb3NpdGlvbiIsInJpZ2h0UG9zaXRpb24iLCJGaWx0ZXIiLCJGaWVsZEZpbHRlciIsImZpZWxkIiwib3AiLCJjcmVhdGUiLCJjcmVhdGVLZXlGaWVsZEluRmlsdGVyIiwiS2V5RmllbGRGaWx0ZXIiLCJBcnJheUNvbnRhaW5zRmlsdGVyIiwiSW5GaWx0ZXIiLCJOb3RJbkZpbHRlciIsIkFycmF5Q29udGFpbnNBbnlGaWx0ZXIiLCJLZXlGaWVsZEluRmlsdGVyIiwiS2V5RmllbGROb3RJbkZpbHRlciIsIm1hdGNoZXMiLCJkb2MiLCJkYXRhIiwibWF0Y2hlc0NvbXBhcmlzb24iLCJpc0luZXF1YWxpdHkiLCJnZXRGbGF0dGVuZWRGaWx0ZXJzIiwiZ2V0RmlsdGVycyIsIkNvbXBvc2l0ZUZpbHRlciIsImZpbHRlcnMiLCJtZW1vaXplZEZsYXR0ZW5lZEZpbHRlcnMiLCJjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uIiwicmVkdWNlIiwic3ViZmlsdGVyIiwiY29uY2F0IiwiY29tcG9zaXRlRmlsdGVyIiwiZmlsdGVyRXF1YWxzIiwiZjEiLCJmMiIsImZpZWxkRmlsdGVyRXF1YWxzIiwiY29tcG9zaXRlRmlsdGVyRXF1YWxzIiwic3ViRmlsdGVyc01hdGNoIiwiZjFGaWx0ZXIiLCJleHRyYWN0RG9jdW1lbnRLZXlzRnJvbUFycmF5VmFsdWUiLCJzb21lIiwibnVsbFZhbHVlIiwiT3JkZXJCeSIsImRpciIsIm9yZGVyQnlFcXVhbHMiLCJTbmFwc2hvdFZlcnNpb24iLCJ0aW1lc3RhbXAiLCJmcm9tVGltZXN0YW1wIiwibWF4IiwidG9NaWNyb3NlY29uZHMiLCJ0b1RpbWVzdGFtcCIsIlNvcnRlZE1hcCIsInJvb3QiLCJMTFJCTm9kZSIsIkVNUFRZIiwiaW5zZXJ0IiwiY29weSIsIkJMQUNLIiwicmVtb3ZlIiwibm9kZSIsImNtcCIsInBydW5lZE5vZGVzIiwibWluS2V5IiwibWF4S2V5IiwiaW5vcmRlclRyYXZlcnNhbCIsImFjdGlvbiIsImsiLCJkZXNjcmlwdGlvbnMiLCJyZXZlcnNlVHJhdmVyc2FsIiwiZ2V0SXRlcmF0b3IiLCJTb3J0ZWRNYXBJdGVyYXRvciIsImdldEl0ZXJhdG9yRnJvbSIsImdldFJldmVyc2VJdGVyYXRvciIsImdldFJldmVyc2VJdGVyYXRvckZyb20iLCJzdGFydEtleSIsImlzUmV2ZXJzZSIsIm5vZGVTdGFjayIsImdldE5leHQiLCJwb3AiLCJoYXNOZXh0IiwicGVlayIsImNvbG9yIiwiUkVEIiwiZml4VXAiLCJyZW1vdmVNaW4iLCJpc1JlZCIsIm1vdmVSZWRMZWZ0Iiwic21hbGxlc3QiLCJyb3RhdGVSaWdodCIsIm1vdmVSZWRSaWdodCIsInJvdGF0ZUxlZnQiLCJjb2xvckZsaXAiLCJubCIsIm5yIiwiY2hlY2tNYXhEZXB0aCIsImJsYWNrRGVwdGgiLCJjaGVjayIsInBvdyIsIkxMUkJFbXB0eU5vZGUiLCJTb3J0ZWRTZXQiLCJoYXMiLCJlbGVtIiwiZmlyc3QiLCJsYXN0IiwiY2IiLCJmb3JFYWNoSW5SYW5nZSIsInJhbmdlIiwiaXRlciIsImZvckVhY2hXaGlsZSIsImZpcnN0QWZ0ZXJPckVxdWFsIiwiU29ydGVkU2V0SXRlcmF0b3IiLCJhZGQiLCJkZWxldGUiLCJ1bmlvbldpdGgiLCJ0aGlzSXQiLCJvdGhlckl0IiwidGhpc0VsZW0iLCJvdGhlckVsZW0iLCJyZXMiLCJ0YXJnZXRJZCIsIkZpZWxkTWFzayIsImV4dHJhRmllbGRzIiwibWVyZ2VkTWFza1NldCIsImZpZWxkUGF0aCIsImNvdmVycyIsImZpZWxkTWFza1BhdGgiLCJsIiwiciIsIk9iamVjdFZhbHVlIiwiY3VycmVudExldmVsIiwiZmllbGRzTWFwIiwiZ2V0RmllbGRzTWFwIiwic2V0QWxsIiwicGFyZW50IiwidXBzZXJ0cyIsImRlbGV0ZXMiLCJhcHBseUNoYW5nZXMiLCJuZXN0ZWRWYWx1ZSIsImluc2VydHMiLCJNdXRhYmxlRG9jdW1lbnQiLCJkb2N1bWVudFR5cGUiLCJyZWFkVGltZSIsImNyZWF0ZVRpbWUiLCJkb2N1bWVudFN0YXRlIiwibmV3SW52YWxpZERvY3VtZW50IiwiZG9jdW1lbnRLZXkiLCJuZXdGb3VuZERvY3VtZW50IiwibmV3Tm9Eb2N1bWVudCIsIm5ld1Vua25vd25Eb2N1bWVudCIsImNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQiLCJjb252ZXJ0VG9Ob0RvY3VtZW50IiwiY29udmVydFRvVW5rbm93bkRvY3VtZW50Iiwic2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zIiwic2V0SGFzTG9jYWxNdXRhdGlvbnMiLCJzZXRSZWFkVGltZSIsImhhc0xvY2FsTXV0YXRpb25zIiwiaGFzQ29tbWl0dGVkTXV0YXRpb25zIiwiaGFzUGVuZGluZ1dyaXRlcyIsImlzVmFsaWREb2N1bWVudCIsImlzRm91bmREb2N1bWVudCIsImlzTm9Eb2N1bWVudCIsImlzVW5rbm93bkRvY3VtZW50IiwibXV0YWJsZUNvcHkiLCJUYXJnZXRJbXBsIiwib3JkZXJCeSIsInN0YXJ0QXQiLCJlbmRBdCIsIm1lbW9pemVkQ2Fub25pY2FsSWQiLCJuZXdUYXJnZXQiLCJ0YXJnZXRFcXVhbHMiLCJRdWVyeUltcGwiLCJleHBsaWNpdE9yZGVyQnkiLCJsaW1pdFR5cGUiLCJtZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5IiwibWVtb2l6ZWRUYXJnZXQiLCJtZW1vaXplZEFnZ3JlZ2F0ZVRhcmdldCIsIm5ld1F1ZXJ5Rm9yUGF0aCIsImdldEluZXF1YWxpdHlGaWx0ZXJGaWVsZHMiLCJxdWVyeSIsInN1YkZpbHRlcnMiLCJuZXdRdWVyeUZvckNvbGxlY3Rpb25Hcm91cCIsImlzQ29sbGVjdGlvbkdyb3VwUXVlcnkiLCJxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5IiwicXVlcnlJbXBsIiwiZmllbGRzTm9ybWFsaXplZCIsIlNldCIsImxhc3REaXJlY3Rpb24iLCJpbmVxdWFsaXR5RmllbGRzIiwicXVlcnlUb1RhcmdldCIsIl9xdWVyeVRvVGFyZ2V0IiwicXVlcnlUb0FnZ3JlZ2F0ZVRhcmdldCIsIm9yZGVyQnlzIiwicXVlcnlXaXRoQWRkZWRGaWx0ZXIiLCJuZXdGaWx0ZXJzIiwicXVlcnlXaXRoQWRkZWRPcmRlckJ5IiwibmV3T3JkZXJCeSIsInF1ZXJ5V2l0aExpbWl0IiwicXVlcnlXaXRoU3RhcnRBdCIsImJvdW5kIiwicXVlcnlXaXRoRW5kQXQiLCJxdWVyeUVxdWFscyIsInRvRG91YmxlIiwic2VyaWFsaXplciIsInVzZVByb3RvM0pzb24iLCJJbmZpbml0eSIsInRvSW50ZWdlciIsInRvTnVtYmVyIiwiVHJhbnNmb3JtT3BlcmF0aW9uIiwiXyIsIlNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSIsIkFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24iLCJlbGVtZW50cyIsIkFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uIiwiTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbiIsIm9wZXJhbmQiLCJGaWVsZFRyYW5zZm9ybSIsInRyYW5zZm9ybSIsIlByZWNvbmRpdGlvbiIsInVwZGF0ZVRpbWUiLCJleGlzdHMiLCJub25lIiwiaXNOb25lIiwiTXV0YXRpb24iLCJTZXRNdXRhdGlvbiIsInByZWNvbmRpdGlvbiIsImZpZWxkVHJhbnNmb3JtcyIsImdldEZpZWxkTWFzayIsIlBhdGNoTXV0YXRpb24iLCJmaWVsZE1hc2siLCJEZWxldGVNdXRhdGlvbiIsIlZlcmlmeU11dGF0aW9uIiwiRElSRUNUSU9OUyIsImRpcnMiLCJPUEVSQVRPUlMiLCJvcHMiLCJDT01QT1NJVEVfT1BFUkFUT1JTIiwiYXNzZXJ0UHJlc2VudCIsIkpzb25Qcm90b1NlcmlhbGl6ZXIiLCJ0b0ludDMyUHJvdG8iLCJqc0RhdGVTdHIiLCJ0b0lTT1N0cmluZyIsInN0clVudGlsU2Vjb25kcyIsInRvQnl0ZXMiLCJ0b1ZlcnNpb24iLCJmcm9tVmVyc2lvbiIsInRvUmVzb3VyY2VOYW1lIiwidG9SZXNvdXJjZVBhdGgiLCJyZXNvdXJjZVBhdGgiLCJmdWxseVF1YWxpZmllZFByZWZpeFBhdGgiLCJmcm9tUmVzb3VyY2VOYW1lIiwicmVzb3VyY2UiLCJpc1ZhbGlkUmVzb3VyY2VOYW1lIiwidG9OYW1lIiwiZXh0cmFjdExvY2FsUGF0aEZyb21SZXNvdXJjZU5hbWUiLCJ0b1F1ZXJ5UGF0aCIsInJlc291cmNlTmFtZSIsInRvTXV0YXRpb25Eb2N1bWVudCIsImZyb21Eb2N1bWVudCIsImRvY3VtZW50IiwiZnJvbUZvdW5kIiwiZm91bmQiLCJmcm9tTWlzc2luZyIsIm1pc3NpbmciLCJmcm9tQmF0Y2hHZXREb2N1bWVudHNSZXNwb25zZSIsInRvTXV0YXRpb24iLCJtdXRhdGlvbiIsInVwZGF0ZSIsInVwZGF0ZU1hc2siLCJ0b0RvY3VtZW50TWFzayIsInZlcmlmeSIsInVwZGF0ZVRyYW5zZm9ybXMiLCJ0b0ZpZWxkVHJhbnNmb3JtIiwiY3VycmVudERvY3VtZW50IiwidG9QcmVjb25kaXRpb24iLCJmaWVsZFRyYW5zZm9ybSIsInNldFRvU2VydmVyVmFsdWUiLCJhcHBlbmRNaXNzaW5nRWxlbWVudHMiLCJyZW1vdmVBbGxGcm9tQXJyYXkiLCJpbmNyZW1lbnQiLCJ0b1F1ZXJ5VGFyZ2V0IiwicXVlcnlUYXJnZXQiLCJzdHJ1Y3R1cmVkUXVlcnkiLCJhbGxEZXNjZW5kYW50cyIsIndoZXJlIiwidG9GaWx0ZXJzIiwidG9PcmRlciIsInRvU3RhcnRBdEN1cnNvciIsInRvRW5kQXRDdXJzb3IiLCJ0b1J1bkFnZ3JlZ2F0aW9uUXVlcnlSZXF1ZXN0IiwiYWdncmVnYXRlcyIsImFsaWFzTWFwIiwiYWdncmVnYXRpb25zIiwiYWdncmVnYXRpb25OdW0iLCJhZ2dyZWdhdGUiLCJzZXJ2ZXJBbGlhcyIsImFsaWFzIiwiYWdncmVnYXRlVHlwZSIsImF2ZyIsInRvRmllbGRQYXRoUmVmZXJlbmNlIiwic3VtIiwic3RydWN0dXJlZEFnZ3JlZ2F0aW9uUXVlcnkiLCJ0b0ZpbHRlciIsIm9yZGVyIiwidG9Qcm9wZXJ0eU9yZGVyIiwiY3Vyc29yIiwiYmVmb3JlIiwidG9EaXJlY3Rpb24iLCJ0b09wZXJhdG9yTmFtZSIsInRvQ29tcG9zaXRlT3BlcmF0b3JOYW1lIiwiZGlyZWN0aW9uIiwidG9VbmFyeU9yRmllbGRGaWx0ZXIiLCJ0b0NvbXBvc2l0ZUZpbHRlciIsInByb3RvcyIsInVuYXJ5RmlsdGVyIiwiZmllbGRGaWx0ZXIiLCJjYW5vbmljYWxGaWVsZHMiLCJmaWVsZFBhdGhzIiwibmV3U2VyaWFsaXplciIsIkxPR19UQUckMiIsIkRFRkFVTFRfQkFDS09GRl9JTklUSUFMX0RFTEFZX01TIiwiREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUiIsIkRFRkFVTFRfQkFDS09GRl9NQVhfREVMQVlfTVMiLCJFeHBvbmVudGlhbEJhY2tvZmYiLCJxdWV1ZSIsInRpbWVySWQiLCJpbml0aWFsRGVsYXlNcyIsImJhY2tvZmZGYWN0b3IiLCJtYXhEZWxheU1zIiwiY3VycmVudEJhc2VNcyIsInRpbWVyUHJvbWlzZSIsImxhc3RBdHRlbXB0VGltZSIsInJlc2V0IiwicmVzZXRUb01heCIsImJhY2tvZmZBbmRSdW4iLCJjYW5jZWwiLCJkZXNpcmVkRGVsYXlXaXRoSml0dGVyTXMiLCJqaXR0ZXJEZWxheU1zIiwiZGVsYXlTb0Zhck1zIiwicmVtYWluaW5nRGVsYXlNcyIsImVucXVldWVBZnRlckRlbGF5Iiwic2tpcEJhY2tvZmYiLCJza2lwRGVsYXkiLCJEYXRhc3RvcmUiLCJEYXRhc3RvcmVJbXBsIiwiYXV0aENyZWRlbnRpYWxzIiwiYXBwQ2hlY2tDcmVkZW50aWFscyIsImNvbm5lY3Rpb24iLCJ0ZXJtaW5hdGVkIiwidmVyaWZ5SW5pdGlhbGl6ZWQiLCJhbGwiLCJjYXRjaCIsIm5ld0RhdGFzdG9yZSIsImludm9rZUNvbW1pdFJwYyIsImRhdGFzdG9yZSIsIm11dGF0aW9ucyIsImRhdGFzdG9yZUltcGwiLCJ3cml0ZXMiLCJtIiwiaW52b2tlQmF0Y2hHZXREb2N1bWVudHNScGMiLCJkb2N1bWVudHMiLCJkb2NzIiwiaW52b2tlUnVuUXVlcnlScGMiLCJpbnZva2VSdW5BZ2dyZWdhdGlvblF1ZXJ5UnBjIiwiZmlsdGVyZWRSZXN1bHQiLCJ1bm1hcHBlZEFnZ3JlZ2F0ZUZpZWxkcyIsImFnZ3JlZ2F0ZUZpZWxkcyIsInJlbWFwcGVkRmllbGRzIiwiYWNjdW11bGF0b3IiLCJMT0dfVEFHJDEiLCJkYXRhc3RvcmVJbnN0YW5jZXMiLCJnZXREYXRhc3RvcmUiLCJmaXJlc3RvcmUiLCJfdGVybWluYXRlZCIsIm1ha2VEYXRhYmFzZUluZm8iLCJfZGF0YWJhc2VJZCIsIl9wZXJzaXN0ZW5jZUtleSIsIl9mcmVlemVTZXR0aW5ncyIsIl9hdXRoQ3JlZGVudGlhbHMiLCJfYXBwQ2hlY2tDcmVkZW50aWFscyIsInJlbW92ZUNvbXBvbmVudHMiLCJzZXR0aW5ncyIsImV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmciLCJleHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmciLCJleHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMiLCJMUlVfQ09MTEVDVElPTl9ESVNBQkxFRCIsIkxSVV9ERUZBVUxUX0NBQ0hFX1NJWkVfQllURVMiLCJpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IiLCJMUlVfTUlOSU1VTV9DQUNIRV9TSVpFX0JZVEVTIiwiREVGQVVMVF9IT1NUIiwiREVGQVVMVF9TU0wiLCJNSU5fTE9OR19QT0xMSU5HX1RJTUVPVVRfU0VDT05EUyIsIk1BWF9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTIiwiREVGQVVMVF9BVVRPX0RFVEVDVF9MT05HX1BPTExJTkciLCJGaXJlc3RvcmVTZXR0aW5nc0ltcGwiLCJpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzIiwibG9jYWxDYWNoZSIsImNhY2hlU2l6ZUJ5dGVzIiwidmFsaWRhdGVMb25nUG9sbGluZ09wdGlvbnMiLCJGaXJlc3RvcmUiLCJfYXBwIiwiX3NldHRpbmdzIiwiX3NldHRpbmdzRnJvemVuIiwiX2luaXRpYWxpemVkIiwiX3Rlcm1pbmF0ZVRhc2siLCJfc2V0U2V0dGluZ3MiLCJfZ2V0U2V0dGluZ3MiLCJfZGVsZXRlIiwiX3Rlcm1pbmF0ZSIsImluaXRpYWxpemVGaXJlc3RvcmUiLCJwcm92aWRlciIsImlzSW5pdGlhbGl6ZWQiLCJpbml0aWFsaXplIiwiaW5zdGFuY2VJZGVudGlmaWVyIiwiZ2V0RmlyZXN0b3JlIiwiYXBwT3JEYXRhYmFzZUlkIiwib3B0aW9uYWxEYXRhYmFzZUlkIiwiZGIiLCJnZXRJbW1lZGlhdGUiLCJpZGVudGlmaWVyIiwiZW11bGF0b3IiLCJjb25uZWN0RmlyZXN0b3JlRW11bGF0b3IiLCJwb3J0IiwibmV3SG9zdFNldHRpbmciLCJtb2NrVXNlclRva2VuIiwic3ViIiwidXNlcl9pZCIsInJlZ2lzdGVyRmlyZXN0b3JlIiwiY29udGFpbmVyIiwiZ2V0UHJvdmlkZXIiLCJmaXJlc3RvcmVJbnN0YW5jZSIsInNldE11bHRpcGxlSW5zdGFuY2VzIiwiQWdncmVnYXRlSW1wbCIsIkFnZ3JlZ2F0ZUZpZWxkIiwiX2ludGVybmFsRmllbGRQYXRoIiwiQWdncmVnYXRlUXVlcnlTbmFwc2hvdCIsIl91c2VyRGF0YVdyaXRlciIsIl9kYXRhIiwiY29udmVydE9iamVjdE1hcCIsIlF1ZXJ5IiwiY29udmVydGVyIiwiX3F1ZXJ5Iiwid2l0aENvbnZlcnRlciIsIkRvY3VtZW50UmVmZXJlbmNlIiwiX2tleSIsIl9wYXRoIiwiaWQiLCJDb2xsZWN0aW9uUmVmZXJlbmNlIiwicGFyZW50UGF0aCIsImNvbGxlY3Rpb24iLCJwYXRoU2VnbWVudHMiLCJhYnNvbHV0ZVBhdGgiLCJhcmd1bWVudHMiLCJyZWZFcXVhbCIsInF1ZXJ5RXF1YWwiLCJCeXRlcyIsImJ5dGVTdHJpbmciLCJfYnl0ZVN0cmluZyIsIkZpZWxkUGF0aCIsImZpZWxkTmFtZXMiLCJfaW50ZXJuYWxQYXRoIiwiZG9jdW1lbnRJZCIsIkZpZWxkVmFsdWUiLCJfbWV0aG9kTmFtZSIsIkdlb1BvaW50IiwiaXNGaW5pdGUiLCJfbGF0IiwiX2xvbmciLCJSRVNFUlZFRF9GSUVMRF9SRUdFWCIsIlBhcnNlZFNldERhdGEiLCJQYXJzZWRVcGRhdGVEYXRhIiwiaXNXcml0ZSIsImRhdGFTb3VyY2UiLCJQYXJzZUNvbnRleHRJbXBsIiwidmFsaWRhdGVQYXRoIiwiY29udGV4dFdpdGgiLCJjb25maWd1cmF0aW9uIiwiY2hpbGRDb250ZXh0Rm9yRmllbGQiLCJjaGlsZFBhdGgiLCJjb250ZXh0IiwiYXJyYXlFbGVtZW50IiwidmFsaWRhdGVQYXRoU2VnbWVudCIsImNoaWxkQ29udGV4dEZvckZpZWxkUGF0aCIsImNoaWxkQ29udGV4dEZvckFycmF5IiwiY3JlYXRlRXJyb3IiLCJyZWFzb24iLCJtZXRob2ROYW1lIiwiaGFzQ29udmVydGVyIiwidGFyZ2V0RG9jIiwiY29udGFpbnMiLCJVc2VyRGF0YVJlYWRlciIsImNyZWF0ZUNvbnRleHQiLCJuZXdVc2VyRGF0YVJlYWRlciIsInBhcnNlU2V0RGF0YSIsInVzZXJEYXRhUmVhZGVyIiwibWVyZ2UiLCJtZXJnZUZpZWxkcyIsInZhbGlkYXRlUGxhaW5PYmplY3QiLCJ1cGRhdGVEYXRhIiwicGFyc2VPYmplY3QiLCJ2YWxpZGF0ZWRGaWVsZFBhdGhzIiwic3RyaW5nT3JGaWVsZFBhdGgiLCJmaWVsZFBhdGhGcm9tQXJndW1lbnQkMSIsImZpZWxkTWFza0NvbnRhaW5zIiwiRGVsZXRlRmllbGRWYWx1ZUltcGwiLCJfdG9GaWVsZFRyYW5zZm9ybSIsImNyZWF0ZVNlbnRpbmVsQ2hpbGRDb250ZXh0IiwiZmllbGRWYWx1ZSIsIlNlcnZlclRpbWVzdGFtcEZpZWxkVmFsdWVJbXBsIiwiQXJyYXlVbmlvbkZpZWxkVmFsdWVJbXBsIiwiX2VsZW1lbnRzIiwicGFyc2VDb250ZXh0IiwicGFyc2VkRWxlbWVudHMiLCJlbGVtZW50IiwicGFyc2VEYXRhIiwiYXJyYXlVbmlvbiIsIkFycmF5UmVtb3ZlRmllbGRWYWx1ZUltcGwiLCJOdW1lcmljSW5jcmVtZW50RmllbGRWYWx1ZUltcGwiLCJfb3BlcmFuZCIsIm51bWVyaWNJbmNyZW1lbnQiLCJwYXJzZVVwZGF0ZURhdGEiLCJmaWVsZE1hc2tQYXRocyIsImZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmciLCJjaGlsZENvbnRleHQiLCJwYXJzZWRWYWx1ZSIsIm1hc2siLCJwYXJzZVVwZGF0ZVZhcmFyZ3MiLCJtb3JlRmllbGRzQW5kVmFsdWVzIiwicGFyc2VRdWVyeVZhbHVlIiwiYWxsb3dBcnJheXMiLCJwYXJzZWQiLCJsb29rc0xpa2VKc29uT2JqZWN0IiwicGFyc2VTZW50aW5lbEZpZWxkVmFsdWUiLCJwYXJzZUFycmF5IiwicGFyc2VTY2FsYXJWYWx1ZSIsImVudHJ5SW5kZXgiLCJlbnRyeSIsInBhcnNlZEVudHJ5IiwidGhpc0RiIiwib3RoZXJEYiIsIkZJRUxEX1BBVEhfUkVTRVJWRUQiLCJzZWFyY2giLCJoYXNQYXRoIiwiaGFzRG9jdW1lbnQiLCJEb2N1bWVudFNuYXBzaG90IiwiX2ZpcmVzdG9yZSIsIl9kb2N1bWVudCIsIl9jb252ZXJ0ZXIiLCJyZWYiLCJzbmFwc2hvdCIsIlF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCIsImZyb21GaXJlc3RvcmUiLCJjb252ZXJ0VmFsdWUiLCJmaWVsZFBhdGhGcm9tQXJndW1lbnQiLCJRdWVyeVNuYXBzaG90IiwiX2RvY3MiLCJjYWxsYmFjayIsInRoaXNBcmciLCJzbmFwc2hvdEVxdWFsIiwiYXJnIiwidmFsaWRhdGVIYXNFeHBsaWNpdE9yZGVyQnlGb3JMaW1pdFRvTGFzdCIsIkFwcGxpYWJsZUNvbnN0cmFpbnQiLCJRdWVyeUNvbnN0cmFpbnQiLCJxdWVyeUNvbnN0cmFpbnQiLCJhZGRpdGlvbmFsUXVlcnlDb25zdHJhaW50cyIsInF1ZXJ5Q29uc3RyYWludHMiLCJ2YWxpZGF0ZVF1ZXJ5Q29uc3RyYWludEFycmF5IiwiY29uc3RyYWludCIsIl9hcHBseSIsIlF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50IiwiX2ZpZWxkIiwiX29wIiwiX3ZhbHVlIiwiX2NyZWF0ZSIsIl9wYXJzZSIsInZhbGlkYXRlTmV3RmllbGRGaWx0ZXIiLCJyZWFkZXIiLCJuZXdRdWVyeUZpbHRlciIsIm9wU3RyIiwiUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50IiwiX3F1ZXJ5Q29uc3RyYWludHMiLCJwYXJzZWRGaWx0ZXJzIiwicGFyc2VkRmlsdGVyIiwiX2dldE9wZXJhdG9yIiwidmFsaWRhdGVOZXdGaWx0ZXIiLCJfZ2V0UXVlcnlDb25zdHJhaW50cyIsIm9yIiwidmFsaWRhdGVRdWVyeUZpbHRlckNvbnN0cmFpbnQiLCJhbmQiLCJRdWVyeU9yZGVyQnlDb25zdHJhaW50IiwiX2RpcmVjdGlvbiIsIm5ld1F1ZXJ5T3JkZXJCeSIsImRpcmVjdGlvblN0ciIsIlF1ZXJ5TGltaXRDb25zdHJhaW50IiwiX2xpbWl0IiwiX2xpbWl0VHlwZSIsImxpbWl0VG9MYXN0IiwiUXVlcnlTdGFydEF0Q29uc3RyYWludCIsIl9kb2NPckZpZWxkcyIsIl9pbmNsdXNpdmUiLCJuZXdRdWVyeUJvdW5kRnJvbURvY09yRmllbGRzIiwiZG9jT3JGaWVsZHMiLCJzdGFydEFmdGVyIiwiUXVlcnlFbmRBdENvbnN0cmFpbnQiLCJlbmRCZWZvcmUiLCJuZXdRdWVyeUJvdW5kRnJvbURvY3VtZW50IiwibmV3UXVlcnlCb3VuZEZyb21GaWVsZHMiLCJkYXRhUmVhZGVyIiwidmFsaWRhdGVEaXNqdW5jdGl2ZUZpbHRlckVsZW1lbnRzIiwicmVmZXJlbmNlTGlzdCIsInBhcnNlRG9jdW1lbnRJZFZhbHVlIiwiY29tcG9uZW50cyIsInJhd1ZhbHVlIiwib3JkZXJCeUNvbXBvbmVudCIsIndyYXBwZWQiLCJkb2N1bWVudElkVmFsdWUiLCJvcGVyYXRvciIsImNvbmZsaWN0aW5nT3BzIiwiY29uZmxpY3RpbmdPcCIsImZpbmRPcEluc2lkZUZpbHRlcnMiLCJ0ZXN0UXVlcnkiLCJzdWJGaWx0ZXIiLCJvcGVyYXRvcnMiLCJjb21wb3NpdGVGaWx0ZXJDb3VudCIsImZpZWxkRmlsdGVyQ291bnQiLCJBYnN0cmFjdFVzZXJEYXRhV3JpdGVyIiwic2VydmVyVGltZXN0YW1wQmVoYXZpb3IiLCJjb252ZXJ0VGltZXN0YW1wIiwiY29udmVydFNlcnZlclRpbWVzdGFtcCIsImNvbnZlcnRCeXRlcyIsImNvbnZlcnRSZWZlcmVuY2UiLCJjb252ZXJ0R2VvUG9pbnQiLCJjb252ZXJ0QXJyYXkiLCJjb252ZXJ0T2JqZWN0Iiwibm9ybWFsaXplZFZhbHVlIiwiY29udmVydERvY3VtZW50S2V5IiwiZXhwZWN0ZWREYXRhYmFzZUlkIiwiYXBwbHlGaXJlc3RvcmVEYXRhQ29udmVydGVyIiwiY29udmVydGVkVmFsdWUiLCJ0b0ZpcmVzdG9yZSIsIkxpdGVVc2VyRGF0YVdyaXRlciIsImdldERvYyIsInJlZmVyZW5jZSIsInVzZXJEYXRhV3JpdGVyIiwiZ2V0RG9jcyIsInJldmVyc2UiLCJzZXREb2MiLCJ1cGRhdGVEb2MiLCJmaWVsZE9yVXBkYXRlRGF0YSIsImRlbGV0ZURvYyIsImFkZERvYyIsImRvY1JlZiIsImdldENvdW50IiwiY291bnRRdWVyeVNwZWMiLCJnZXRBZ2dyZWdhdGUiLCJhZ2dyZWdhdGVTcGVjIiwiaW50ZXJuYWxBZ2dyZWdhdGVzIiwiYWdncmVnYXRlUmVzdWx0IiwiY29udmVydFRvQWdncmVnYXRlUXVlcnlTbmFwc2hvdCIsInF1ZXJ5U25hcHNob3QiLCJhdmVyYWdlIiwiYWdncmVnYXRlRmllbGRFcXVhbCIsImFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RFcXVhbCIsImRlbGV0ZUZpZWxkIiwic2VydmVyVGltZXN0YW1wIiwiYXJyYXlSZW1vdmUiLCJXcml0ZUJhdGNoIiwiX2NvbW1pdEhhbmRsZXIiLCJfbXV0YXRpb25zIiwiX2NvbW1pdHRlZCIsIl9kYXRhUmVhZGVyIiwiZG9jdW1lbnRSZWYiLCJfdmVyaWZ5Tm90Q29tbWl0dGVkIiwidmFsaWRhdGVSZWZlcmVuY2UiLCJjb21taXQiLCJ3cml0ZUJhdGNoIiwiREVGQVVMVF9UUkFOU0FDVElPTl9PUFRJT05TIiwibWF4QXR0ZW1wdHMiLCJ2YWxpZGF0ZVRyYW5zYWN0aW9uT3B0aW9ucyIsIlRyYW5zYWN0aW9uJDEiLCJyZWFkVmVyc2lvbnMiLCJjb21taXR0ZWQiLCJsYXN0VHJhbnNhY3Rpb25FcnJvciIsIndyaXR0ZW5Eb2NzIiwibG9va3VwIiwiZW5zdXJlQ29tbWl0Tm90Q2FsbGVkIiwicmVjb3JkVmVyc2lvbiIsIndyaXRlIiwicHJlY29uZGl0aW9uRm9yVXBkYXRlIiwidW53cml0dGVuIiwiZG9jVmVyc2lvbiIsImV4aXN0aW5nVmVyc2lvbiIsIlRyYW5zYWN0aW9uUnVubmVyIiwidXBkYXRlRnVuY3Rpb24iLCJkZWZlcnJlZCIsImF0dGVtcHRzUmVtYWluaW5nIiwiYmFja29mZiIsInJ1biIsInJ1bldpdGhCYWNrT2ZmIiwidHJhbnNhY3Rpb24iLCJ1c2VyUHJvbWlzZSIsInRyeVJ1blVwZGF0ZUZ1bmN0aW9uIiwiZW5xdWV1ZUFuZEZvcmdldCIsImNvbW1pdEVycm9yIiwiaGFuZGxlVHJhbnNhY3Rpb25FcnJvciIsInVzZXJQcm9taXNlRXJyb3IiLCJpc1JldHJ5YWJsZVRyYW5zYWN0aW9uRXJyb3IiLCJEZWxheWVkT3BlcmF0aW9uIiwidGFyZ2V0VGltZU1zIiwicmVtb3ZhbENhbGxiYWNrIiwiYmluZCIsImNyZWF0ZUFuZFNjaGVkdWxlIiwiZGVsYXlNcyIsInRhcmdldFRpbWUiLCJkZWxheWVkT3AiLCJ0aW1lckhhbmRsZSIsInNldFRpbWVvdXQiLCJoYW5kbGVEZWxheUVsYXBzZWQiLCJjbGVhclRpbWVvdXQiLCJMT0dfVEFHIiwiQXN5bmNRdWV1ZUltcGwiLCJ0YWlsIiwicmV0cnlhYmxlT3BzIiwiX2lzU2h1dHRpbmdEb3duIiwiZGVsYXllZE9wZXJhdGlvbnMiLCJvcGVyYXRpb25JblByb2dyZXNzIiwic2tpcE5vblJlc3RyaWN0ZWRUYXNrcyIsInRpbWVySWRzVG9Ta2lwIiwidmlzaWJpbGl0eUhhbmRsZXIiLCJpc1NodXR0aW5nRG93biIsImVucXVldWUiLCJlbnF1ZXVlQW5kRm9yZ2V0RXZlbldoaWxlUmVzdHJpY3RlZCIsInZlcmlmeU5vdEZhaWxlZCIsImVucXVldWVJbnRlcm5hbCIsImVudGVyUmVzdHJpY3RlZE1vZGUiLCJwdXJnZUV4aXN0aW5nVGFza3MiLCJ0YXNrIiwicmV0cnlOZXh0T3AiLCJzaGlmdCIsIm5ld1RhaWwiLCJnZXRNZXNzYWdlT3JTdGFjayIsInJlbW92ZWRPcCIsInJlbW92ZURlbGF5ZWRPcGVyYXRpb24iLCJ2ZXJpZnlPcGVyYXRpb25JblByb2dyZXNzIiwiZHJhaW4iLCJjdXJyZW50VGFpbCIsImNvbnRhaW5zRGVsYXllZE9wZXJhdGlvbiIsInJ1bkFsbERlbGF5ZWRPcGVyYXRpb25zVW50aWwiLCJsYXN0VGltZXJJZCIsImEiLCJiIiwic2tpcERlbGF5c0ZvclRpbWVySWQiLCJzcGxpY2UiLCJuZXdBc3luY1F1ZXVlIiwic3RhY2siLCJpbmNsdWRlcyIsIlRyYW5zYWN0aW9uIiwiX3RyYW5zYWN0aW9uIiwicnVuVHJhbnNhY3Rpb24iLCJvcHRpb25zV2l0aERlZmF1bHRzIiwiaW50ZXJuYWxUcmFuc2FjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/firestore/dist/lite/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@firebase/logger/dist/esm/index.esm2017.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setUserLogHandler: () => (/* binding */ setUserLogHandler)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A container for all of the Logger instances\r\n */ const instances = [];\n/**\r\n * The JS SDK supports 5 log levels and also allows a user the ability to\r\n * silence the logs altogether.\r\n *\r\n * The order is a follows:\r\n * DEBUG < VERBOSE < INFO < WARN < ERROR\r\n *\r\n * All of the log types above the current log level will be captured (i.e. if\r\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\r\n * `VERBOSE` logs will not)\r\n */ var LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nconst levelStringToEnum = {\n    \"debug\": LogLevel.DEBUG,\n    \"verbose\": LogLevel.VERBOSE,\n    \"info\": LogLevel.INFO,\n    \"warn\": LogLevel.WARN,\n    \"error\": LogLevel.ERROR,\n    \"silent\": LogLevel.SILENT\n};\n/**\r\n * The default log level\r\n */ const defaultLogLevel = LogLevel.INFO;\n/**\r\n * By default, `console.debug` is not displayed in the developer console (in\r\n * chrome). To avoid forcing users to have to opt-in to these logs twice\r\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\r\n * logs to the `console.log` function.\r\n */ const ConsoleMethod = {\n    [LogLevel.DEBUG]: \"log\",\n    [LogLevel.VERBOSE]: \"log\",\n    [LogLevel.INFO]: \"info\",\n    [LogLevel.WARN]: \"warn\",\n    [LogLevel.ERROR]: \"error\"\n};\n/**\r\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\r\n * messages on to their corresponding console counterparts (if the log method\r\n * is supported by the current log level)\r\n */ const defaultLogHandler = (instance, logType, ...args)=>{\n    if (logType < instance.logLevel) {\n        return;\n    }\n    const now = new Date().toISOString();\n    const method = ConsoleMethod[logType];\n    if (method) {\n        console[method](`[${now}]  ${instance.name}:`, ...args);\n    } else {\n        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\n    }\n};\nclass Logger {\n    /**\r\n     * Gives you an instance of a Logger to capture messages according to\r\n     * Firebase's logging scheme.\r\n     *\r\n     * @param name The name that the logs will be associated with\r\n     */ constructor(name){\n        this.name = name;\n        /**\r\n         * The log level of the given Logger instance.\r\n         */ this._logLevel = defaultLogLevel;\n        /**\r\n         * The main (internal) log handler for the Logger instance.\r\n         * Can be set to a new function in internal package code but not by user.\r\n         */ this._logHandler = defaultLogHandler;\n        /**\r\n         * The optional, additional, user-defined log handler for the Logger instance.\r\n         */ this._userLogHandler = null;\n        /**\r\n         * Capture the current instance for later use\r\n         */ instances.push(this);\n    }\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(val) {\n        if (!(val in LogLevel)) {\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n        }\n        this._logLevel = val;\n    }\n    // Workaround for setter/getter having to be the same type.\n    setLogLevel(val) {\n        this._logLevel = typeof val === \"string\" ? levelStringToEnum[val] : val;\n    }\n    get logHandler() {\n        return this._logHandler;\n    }\n    set logHandler(val) {\n        if (typeof val !== \"function\") {\n            throw new TypeError(\"Value assigned to `logHandler` must be a function\");\n        }\n        this._logHandler = val;\n    }\n    get userLogHandler() {\n        return this._userLogHandler;\n    }\n    set userLogHandler(val) {\n        this._userLogHandler = val;\n    }\n    /**\r\n     * The functions below are all based on the `console` interface\r\n     */ debug(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\n        this._logHandler(this, LogLevel.DEBUG, ...args);\n    }\n    log(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);\n        this._logHandler(this, LogLevel.VERBOSE, ...args);\n    }\n    info(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\n        this._logHandler(this, LogLevel.INFO, ...args);\n    }\n    warn(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\n        this._logHandler(this, LogLevel.WARN, ...args);\n    }\n    error(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\n        this._logHandler(this, LogLevel.ERROR, ...args);\n    }\n}\nfunction setLogLevel(level) {\n    instances.forEach((inst)=>{\n        inst.setLogLevel(level);\n    });\n}\nfunction setUserLogHandler(logCallback, options) {\n    for (const instance of instances){\n        let customLogLevel = null;\n        if (options && options.level) {\n            customLogLevel = levelStringToEnum[options.level];\n        }\n        if (logCallback === null) {\n            instance.userLogHandler = null;\n        } else {\n            instance.userLogHandler = (instance, level, ...args)=>{\n                const message = args.map((arg)=>{\n                    if (arg == null) {\n                        return null;\n                    } else if (typeof arg === \"string\") {\n                        return arg;\n                    } else if (typeof arg === \"number\" || typeof arg === \"boolean\") {\n                        return arg.toString();\n                    } else if (arg instanceof Error) {\n                        return arg.message;\n                    } else {\n                        try {\n                            return JSON.stringify(arg);\n                        } catch (ignored) {\n                            return null;\n                        }\n                    }\n                }).filter((arg)=>arg).join(\" \");\n                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\n                    logCallback({\n                        level: LogLevel[level].toLowerCase(),\n                        message,\n                        args,\n                        type: instance.name\n                    });\n                }\n            };\n        }\n    }\n}\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1BLFlBQVksRUFBRTtBQUNwQjs7Ozs7Ozs7OztDQVVDLEdBQ0QsSUFBSUM7QUFDSCxVQUFVQSxRQUFRO0lBQ2ZBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDbENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDcENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDakNBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDakNBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDbENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7QUFDdkMsR0FBR0EsWUFBYUEsQ0FBQUEsV0FBVyxDQUFDO0FBQzVCLE1BQU1DLG9CQUFvQjtJQUN0QixTQUFTRCxTQUFTRSxLQUFLO0lBQ3ZCLFdBQVdGLFNBQVNHLE9BQU87SUFDM0IsUUFBUUgsU0FBU0ksSUFBSTtJQUNyQixRQUFRSixTQUFTSyxJQUFJO0lBQ3JCLFNBQVNMLFNBQVNNLEtBQUs7SUFDdkIsVUFBVU4sU0FBU08sTUFBTTtBQUM3QjtBQUNBOztDQUVDLEdBQ0QsTUFBTUMsa0JBQWtCUixTQUFTSSxJQUFJO0FBQ3JDOzs7OztDQUtDLEdBQ0QsTUFBTUssZ0JBQWdCO0lBQ2xCLENBQUNULFNBQVNFLEtBQUssQ0FBQyxFQUFFO0lBQ2xCLENBQUNGLFNBQVNHLE9BQU8sQ0FBQyxFQUFFO0lBQ3BCLENBQUNILFNBQVNJLElBQUksQ0FBQyxFQUFFO0lBQ2pCLENBQUNKLFNBQVNLLElBQUksQ0FBQyxFQUFFO0lB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Szt3QkFDRCxJQUFJOzRCQUNBLE9BQU9JLEtBQUtDLFNBQVMsQ0FBQ0g7d0JBQzFCLEVBQ0EsT0FBT0ksU0FBUzs0QkFDWixPQUFPO3dCQUNYO29CQUNKO2dCQUNKLEdBQ0tDLE1BQU0sQ0FBQ0wsQ0FBQUEsTUFBT0EsS0FDZE0sSUFBSSxDQUFDO2dCQUNWLElBQUlmLFNBQVVNLENBQUFBLG1CQUFtQixRQUFRQSxtQkFBbUIsS0FBSyxJQUFJQSxpQkFBaUJqQyxTQUFTRyxRQUFRLEdBQUc7b0JBQ3RHNEIsWUFBWTt3QkFDUkosT0FBT3RDLFFBQVEsQ0FBQ3NDLE1BQU0sQ0FBQ2dCLFdBQVc7d0JBQ2xDVDt3QkFDQWhDO3dCQUNBMEMsTUFBTTVDLFNBQVNTLElBQUk7b0JBQ3ZCO2dCQUNKO1lBQ0o7UUFDSjtJQUNKO0FBQ0o7QUFFNEQsQ0FDNUQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2lnYXNwYW5kdS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbG9nZ2VyL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanM/Mzk4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBjb250YWluZXIgZm9yIGFsbCBvZiB0aGUgTG9nZ2VyIGluc3RhbmNlc1xyXG4gKi9cclxuY29uc3QgaW5zdGFuY2VzID0gW107XHJcbi8qKlxyXG4gKiBUaGUgSlMgU0RLIHN1cHBvcnRzIDUgbG9nIGxldmVscyBhbmQgYWxzbyBhbGxvd3MgYSB1c2VyIHRoZSBhYmlsaXR5IHRvXHJcbiAqIHNpbGVuY2UgdGhlIGxvZ3MgYWx0b2dldGhlci5cclxuICpcclxuICogVGhlIG9yZGVyIGlzIGEgZm9sbG93czpcclxuICogREVCVUcgPCBWRVJCT1NFIDwgSU5GTyA8IFdBUk4gPCBFUlJPUlxyXG4gKlxyXG4gKiBBbGwgb2YgdGhlIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgd2lsbCBiZSBjYXB0dXJlZCAoaS5lLiBpZlxyXG4gKiB5b3Ugc2V0IHRoZSBsb2cgbGV2ZWwgdG8gYElORk9gLCBlcnJvcnMgd2lsbCBzdGlsbCBiZSBsb2dnZWQsIGJ1dCBgREVCVUdgIGFuZFxyXG4gKiBgVkVSQk9TRWAgbG9ncyB3aWxsIG5vdClcclxuICovXHJcbnZhciBMb2dMZXZlbDtcclxuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJERUJVR1wiXSA9IDBdID0gXCJERUJVR1wiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJWRVJCT1NFXCJdID0gMV0gPSBcIlZFUkJPU0VcIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiSU5GT1wiXSA9IDJdID0gXCJJTkZPXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldBUk5cIl0gPSAzXSA9IFwiV0FSTlwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFUlJPUlwiXSA9IDRdID0gXCJFUlJPUlwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJTSUxFTlRcIl0gPSA1XSA9IFwiU0lMRU5UXCI7XHJcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XHJcbmNvbnN0IGxldmVsU3RyaW5nVG9FbnVtID0ge1xyXG4gICAgJ2RlYnVnJzogTG9nTGV2ZWwuREVCVUcsXHJcbiAgICAndmVyYm9zZSc6IExvZ0xldmVsLlZFUkJPU0UsXHJcbiAgICAnaW5mbyc6IExvZ0xldmVsLklORk8sXHJcbiAgICAnd2Fybic6IExvZ0xldmVsLldBUk4sXHJcbiAgICAnZXJyb3InOiBMb2dMZXZlbC5FUlJPUixcclxuICAgICdzaWxlbnQnOiBMb2dMZXZlbC5TSUxFTlRcclxufTtcclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGxvZyBsZXZlbFxyXG4gKi9cclxuY29uc3QgZGVmYXVsdExvZ0xldmVsID0gTG9nTGV2ZWwuSU5GTztcclxuLyoqXHJcbiAqIEJ5IGRlZmF1bHQsIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgZGlzcGxheWVkIGluIHRoZSBkZXZlbG9wZXIgY29uc29sZSAoaW5cclxuICogY2hyb21lKS4gVG8gYXZvaWQgZm9yY2luZyB1c2VycyB0byBoYXZlIHRvIG9wdC1pbiB0byB0aGVzZSBsb2dzIHR3aWNlXHJcbiAqIChpLmUuIG9uY2UgZm9yIGZpcmViYXNlLCBhbmQgb25jZSBpbiB0aGUgY29uc29sZSksIHdlIGFyZSBzZW5kaW5nIGBERUJVR2BcclxuICogbG9ncyB0byB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbi5cclxuICovXHJcbmNvbnN0IENvbnNvbGVNZXRob2QgPSB7XHJcbiAgICBbTG9nTGV2ZWwuREVCVUddOiAnbG9nJyxcclxuICAgIFtMb2dMZXZlbC5WRVJCT1NFXTogJ2xvZycsXHJcbiAgICBbTG9nTGV2ZWwuSU5GT106ICdpbmZvJyxcclxuICAgIFtMb2dMZXZlbC5XQVJOXTogJ3dhcm4nLFxyXG4gICAgW0xvZ0xldmVsLkVSUk9SXTogJ2Vycm9yJ1xyXG59O1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgbG9nIGhhbmRsZXIgd2lsbCBmb3J3YXJkIERFQlVHLCBWRVJCT1NFLCBJTkZPLCBXQVJOLCBhbmQgRVJST1JcclxuICogbWVzc2FnZXMgb24gdG8gdGhlaXIgY29ycmVzcG9uZGluZyBjb25zb2xlIGNvdW50ZXJwYXJ0cyAoaWYgdGhlIGxvZyBtZXRob2RcclxuICogaXMgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGxvZyBsZXZlbClcclxuICovXHJcbmNvbnN0IGRlZmF1bHRMb2dIYW5kbGVyID0gKGluc3RhbmNlLCBsb2dUeXBlLCAuLi5hcmdzKSA9PiB7XHJcbiAgICBpZiAobG9nVHlwZSA8IGluc3RhbmNlLmxvZ0xldmVsKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgY29uc3QgbWV0aG9kID0gQ29uc29sZU1ldGhvZFtsb2dUeXBlXTtcclxuICAgIGlmIChtZXRob2QpIHtcclxuICAgICAgICBjb25zb2xlW21ldGhvZF0oYFske25vd31dICAke2luc3RhbmNlLm5hbWV9OmAsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gbG9nIGEgbWVzc2FnZSB3aXRoIGFuIGludmFsaWQgbG9nVHlwZSAodmFsdWU6ICR7bG9nVHlwZX0pYCk7XHJcbiAgICB9XHJcbn07XHJcbmNsYXNzIExvZ2dlciB7XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVzIHlvdSBhbiBpbnN0YW5jZSBvZiBhIExvZ2dlciB0byBjYXB0dXJlIG1lc3NhZ2VzIGFjY29yZGluZyB0b1xyXG4gICAgICogRmlyZWJhc2UncyBsb2dnaW5nIHNjaGVtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSB0aGF0IHRoZSBsb2dzIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsb2cgbGV2ZWwgb2YgdGhlIGdpdmVuIExvZ2dlciBpbnN0YW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IGRlZmF1bHRMb2dMZXZlbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWFpbiAoaW50ZXJuYWwpIGxvZyBoYW5kbGVyIGZvciB0aGUgTG9nZ2VyIGluc3RhbmNlLlxyXG4gICAgICAgICAqIENhbiBiZSBzZXQgdG8gYSBuZXcgZnVuY3Rpb24gaW4gaW50ZXJuYWwgcGFja2FnZSBjb2RlIGJ1dCBub3QgYnkgdXNlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyID0gZGVmYXVsdExvZ0hhbmRsZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG9wdGlvbmFsLCBhZGRpdGlvbmFsLCB1c2VyLWRlZmluZWQgbG9nIGhhbmRsZXIgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhcHR1cmUgdGhlIGN1cnJlbnQgaW5zdGFuY2UgZm9yIGxhdGVyIHVzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluc3RhbmNlcy5wdXNoKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvZ0xldmVsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dMZXZlbDtcclxuICAgIH1cclxuICAgIHNldCBsb2dMZXZlbCh2YWwpIHtcclxuICAgICAgICBpZiAoISh2YWwgaW4gTG9nTGV2ZWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgdmFsdWUgXCIke3ZhbH1cIiBhc3NpZ25lZCB0byBcXGBsb2dMZXZlbFxcYGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IHZhbDtcclxuICAgIH1cclxuICAgIC8vIFdvcmthcm91bmQgZm9yIHNldHRlci9nZXR0ZXIgaGF2aW5nIHRvIGJlIHRoZSBzYW1lIHR5cGUuXHJcbiAgICBzZXRMb2dMZXZlbCh2YWwpIHtcclxuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gbGV2ZWxTdHJpbmdUb0VudW1bdmFsXSA6IHZhbDtcclxuICAgIH1cclxuICAgIGdldCBsb2dIYW5kbGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dIYW5kbGVyO1xyXG4gICAgfVxyXG4gICAgc2V0IGxvZ0hhbmRsZXIodmFsKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWUgYXNzaWduZWQgdG8gYGxvZ0hhbmRsZXJgIG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyID0gdmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IHVzZXJMb2dIYW5kbGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91c2VyTG9nSGFuZGxlcjtcclxuICAgIH1cclxuICAgIHNldCB1c2VyTG9nSGFuZGxlcih2YWwpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciA9IHZhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgYWxsIGJhc2VkIG9uIHRoZSBgY29uc29sZWAgaW50ZXJmYWNlXHJcbiAgICAgKi9cclxuICAgIGRlYnVnKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5ERUJVRywgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5ERUJVRywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBsb2coLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmXHJcbiAgICAgICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLlZFUkJPU0UsIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuVkVSQk9TRSwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBpbmZvKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5JTkZPLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgd2FybiguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuV0FSTiwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGVycm9yKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5FUlJPUiwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5FUlJPUiwgLi4uYXJncyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwpIHtcclxuICAgIGluc3RhbmNlcy5mb3JFYWNoKGluc3QgPT4ge1xyXG4gICAgICAgIGluc3Quc2V0TG9nTGV2ZWwobGV2ZWwpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gc2V0VXNlckxvZ0hhbmRsZXIobG9nQ2FsbGJhY2ssIG9wdGlvbnMpIHtcclxuICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XHJcbiAgICAgICAgbGV0IGN1c3RvbUxvZ0xldmVsID0gbnVsbDtcclxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxldmVsKSB7XHJcbiAgICAgICAgICAgIGN1c3RvbUxvZ0xldmVsID0gbGV2ZWxTdHJpbmdUb0VudW1bb3B0aW9ucy5sZXZlbF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsb2dDYWxsYmFjayA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS51c2VyTG9nSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS51c2VyTG9nSGFuZGxlciA9IChpbnN0YW5jZSwgbGV2ZWwsIC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhcmdzXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChhcmcgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihhcmcgPT4gYXJnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcgJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPj0gKGN1c3RvbUxvZ0xldmVsICE9PSBudWxsICYmIGN1c3RvbUxvZ0xldmVsICE9PSB2b2lkIDAgPyBjdXN0b21Mb2dMZXZlbCA6IGluc3RhbmNlLmxvZ0xldmVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0NhbGxiYWNrKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IExvZ0xldmVsW2xldmVsXS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBpbnN0YW5jZS5uYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IExvZ0xldmVsLCBMb2dnZXIsIHNldExvZ0xldmVsLCBzZXRVc2VyTG9nSGFuZGxlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpbnN0YW5jZXMiLCJMb2dMZXZlbCIsImxldmVsU3RyaW5nVG9FbnVtIiwiREVCVUciLCJWRVJCT1NFIiwiSU5GTyIsIldBUk4iLCJFUlJPUiIsIlNJTEVOVCIsImRlZmF1bHRMb2dMZXZlbCIsIkNvbnNvbGVNZXRob2QiLCJkZWZhdWx0TG9nSGFuZGxlciIsImluc3RhbmNlIiwibG9nVHlwZSIsImFyZ3MiLCJsb2dMZXZlbCIsIm5vdyIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIm1ldGhvZCIsImNvbnNvbGUiLCJuYW1lIiwiRXJyb3IiLCJMb2dnZXIiLCJjb25zdHJ1Y3RvciIsIl9sb2dMZXZlbCIsIl9sb2dIYW5kbGVyIiwiX3VzZXJMb2dIYW5kbGVyIiwicHVzaCIsInZhbCIsIlR5cGVFcnJvciIsInNldExvZ0xldmVsIiwibG9nSGFuZGxlciIsInVzZXJMb2dIYW5kbGVyIiwiZGVidWciLCJsb2ciLCJpbmZvIiwid2FybiIsImVycm9yIiwibGV2ZWwiLCJmb3JFYWNoIiwiaW5zdCIsInNldFVzZXJMb2dIYW5kbGVyIiwibG9nQ2FsbGJhY2siLCJvcHRpb25zIiwiY3VzdG9tTG9nTGV2ZWwiLCJtZXNzYWdlIiwibWFwIiwiYXJnIiwidG9TdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwiaWdub3JlZCIsImZpbHRlciIsImpvaW4iLCJ0b0xvd2VyQ2FzZSIsInR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@firebase/util/dist/node-esm/index.node.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANTS: () => (/* binding */ CONSTANTS),\n/* harmony export */   DecodeBase64StringError: () => (/* binding */ DecodeBase64StringError),\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   ErrorFactory: () => (/* binding */ ErrorFactory),\n/* harmony export */   FirebaseError: () => (/* binding */ FirebaseError),\n/* harmony export */   MAX_VALUE_MILLIS: () => (/* binding */ MAX_VALUE_MILLIS),\n/* harmony export */   RANDOM_FACTOR: () => (/* binding */ RANDOM_FACTOR),\n/* harmony export */   Sha1: () => (/* binding */ Sha1),\n/* harmony export */   areCookiesEnabled: () => (/* binding */ areCookiesEnabled),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertionError: () => (/* binding */ assertionError),\n/* harmony export */   async: () => (/* binding */ async),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64Decode: () => (/* binding */ base64Decode),\n/* harmony export */   base64Encode: () => (/* binding */ base64Encode),\n/* harmony export */   base64urlEncodeWithoutPadding: () => (/* binding */ base64urlEncodeWithoutPadding),\n/* harmony export */   calculateBackoffMillis: () => (/* binding */ calculateBackoffMillis),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createMockUserToken: () => (/* binding */ createMockUserToken),\n/* harmony export */   createSubscribe: () => (/* binding */ createSubscribe),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   deepExtend: () => (/* binding */ deepExtend),\n/* harmony export */   errorPrefix: () => (/* binding */ errorPrefix),\n/* harmony export */   extractQuerystring: () => (/* binding */ extractQuerystring),\n/* harmony export */   getDefaultAppConfig: () => (/* binding */ getDefaultAppConfig),\n/* harmony export */   getDefaultEmulatorHost: () => (/* binding */ getDefaultEmulatorHost),\n/* harmony export */   getDefaultEmulatorHostnameAndPort: () => (/* binding */ getDefaultEmulatorHostnameAndPort),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getExperimentalSetting: () => (/* binding */ getExperimentalSetting),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   getModularInstance: () => (/* binding */ getModularInstance),\n/* harmony export */   getUA: () => (/* binding */ getUA),\n/* harmony export */   isAdmin: () => (/* binding */ isAdmin),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isBrowserExtension: () => (/* binding */ isBrowserExtension),\n/* harmony export */   isElectron: () => (/* binding */ isElectron),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isIE: () => (/* binding */ isIE),\n/* harmony export */   isIndexedDBAvailable: () => (/* binding */ isIndexedDBAvailable),\n/* harmony export */   isMobileCordova: () => (/* binding */ isMobileCordova),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isNodeSdk: () => (/* binding */ isNodeSdk),\n/* harmony export */   isReactNative: () => (/* binding */ isReactNative),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isUWP: () => (/* binding */ isUWP),\n/* harmony export */   isValidFormat: () => (/* binding */ isValidFormat),\n/* harmony export */   isValidTimestamp: () => (/* binding */ isValidTimestamp),\n/* harmony export */   issuedAtTime: () => (/* binding */ issuedAtTime),\n/* harmony export */   jsonEval: () => (/* binding */ jsonEval),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   ordinal: () => (/* binding */ ordinal),\n/* harmony export */   promiseWithTimeout: () => (/* binding */ promiseWithTimeout),\n/* harmony export */   querystring: () => (/* binding */ querystring),\n/* harmony export */   querystringDecode: () => (/* binding */ querystringDecode),\n/* harmony export */   safeGet: () => (/* binding */ safeGet),\n/* harmony export */   stringLength: () => (/* binding */ stringLength),\n/* harmony export */   stringToByteArray: () => (/* binding */ stringToByteArray),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4),\n/* harmony export */   validateArgCount: () => (/* binding */ validateArgCount),\n/* harmony export */   validateCallback: () => (/* binding */ validateCallback),\n/* harmony export */   validateContextObject: () => (/* binding */ validateContextObject),\n/* harmony export */   validateIndexedDBOpenable: () => (/* binding */ validateIndexedDBOpenable),\n/* harmony export */   validateNamespace: () => (/* binding */ validateNamespace)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\r\n */ const CONSTANTS = {\n    /**\r\n     * @define {boolean} Whether this is the client Node.js SDK.\r\n     */ NODE_CLIENT: false,\n    /**\r\n     * @define {boolean} Whether this is the Admin Node.js SDK.\r\n     */ NODE_ADMIN: false,\n    /**\r\n     * Firebase SDK Version\r\n     */ SDK_VERSION: \"${JSCORE_VERSION}\"\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Throws an error if the provided assertion is falsy\r\n */ const assert = function(assertion, message) {\n    if (!assertion) {\n        throw assertionError(message);\n    }\n};\n/**\r\n * Returns an Error object suitable for throwing.\r\n */ const assertionError = function(message) {\n    return new Error(\"Firebase Database (\" + CONSTANTS.SDK_VERSION + \") INTERNAL ASSERT FAILED: \" + message);\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const stringToByteArray$1 = function(str) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let p = 0;\n    for(let i = 0; i < str.length; i++){\n        let c = str.charCodeAt(i);\n        if (c < 128) {\n            out[p++] = c;\n        } else if (c < 2048) {\n            out[p++] = c >> 6 | 192;\n            out[p++] = c & 63 | 128;\n        } else if ((c & 0xfc00) === 0xd800 && i + 1 < str.length && (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\n            // Surrogate Pair\n            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\n            out[p++] = c >> 18 | 240;\n            out[p++] = c >> 12 & 63 | 128;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        } else {\n            out[p++] = c >> 12 | 224;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        }\n    }\n    return out;\n};\n/**\r\n * Turns an array of numbers into the string given by the concatenation of the\r\n * characters to which the numbers correspond.\r\n * @param bytes Array of numbers representing characters.\r\n * @return Stringification of the array.\r\n */ const byteArrayToString = function(bytes) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let pos = 0, c = 0;\n    while(pos < bytes.length){\n        const c1 = bytes[pos++];\n        if (c1 < 128) {\n            out[c++] = String.fromCharCode(c1);\n        } else if (c1 > 191 && c1 < 224) {\n            const c2 = bytes[pos++];\n            out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);\n        } else if (c1 > 239 && c1 < 365) {\n            // Surrogate Pair\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            const c4 = bytes[pos++];\n            const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 0x10000;\n            out[c++] = String.fromCharCode(0xd800 + (u >> 10));\n            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\n        } else {\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n        }\n    }\n    return out.join(\"\");\n};\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\n// Static lookup maps, lazily populated by init_()\nconst base64 = {\n    /**\r\n     * Maps bytes to characters.\r\n     */ byteToCharMap_: null,\n    /**\r\n     * Maps characters to bytes.\r\n     */ charToByteMap_: null,\n    /**\r\n     * Maps bytes to websafe characters.\r\n     * @private\r\n     */ byteToCharMapWebSafe_: null,\n    /**\r\n     * Maps websafe characters to bytes.\r\n     * @private\r\n     */ charToByteMapWebSafe_: null,\n    /**\r\n     * Our default alphabet, shared between\r\n     * ENCODED_VALS and ENCODED_VALS_WEBSAFE\r\n     */ ENCODED_VALS_BASE: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz\" + \"0123456789\",\n    /**\r\n     * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\r\n     */ get ENCODED_VALS () {\n        return this.ENCODED_VALS_BASE + \"+/=\";\n    },\n    /**\r\n     * Our websafe alphabet.\r\n     */ get ENCODED_VALS_WEBSAFE () {\n        return this.ENCODED_VALS_BASE + \"-_.\";\n    },\n    /**\r\n     * Whether this browser supports the atob and btoa functions. This extension\r\n     * started at Mozilla but is now implemented by many browsers. We use the\r\n     * ASSUME_* variables to avoid pulling in the full useragent detection library\r\n     * but still allowing the standard per-browser compilations.\r\n     *\r\n     */ HAS_NATIVE_SUPPORT: typeof atob === \"function\",\n    /**\r\n     * Base64-encode an array of bytes.\r\n     *\r\n     * @param input An array of bytes (numbers with\r\n     *     value in [0, 255]) to encode.\r\n     * @param webSafe Boolean indicating we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */ encodeByteArray (input, webSafe) {\n        if (!Array.isArray(input)) {\n            throw Error(\"encodeByteArray takes an array as a parameter\");\n        }\n        this.init_();\n        const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;\n        const output = [];\n        for(let i = 0; i < input.length; i += 3){\n            const byte1 = input[i];\n            const haveByte2 = i + 1 < input.length;\n            const byte2 = haveByte2 ? input[i + 1] : 0;\n            const haveByte3 = i + 2 < input.length;\n            const byte3 = haveByte3 ? input[i + 2] : 0;\n            const outByte1 = byte1 >> 2;\n            const outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;\n            let outByte3 = (byte2 & 0x0f) << 2 | byte3 >> 6;\n            let outByte4 = byte3 & 0x3f;\n            if (!haveByte3) {\n                outByte4 = 64;\n                if (!haveByte2) {\n                    outByte3 = 64;\n                }\n            }\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n        }\n        return output.join(\"\");\n    },\n    /**\r\n     * Base64-encode a string.\r\n     *\r\n     * @param input A string to encode.\r\n     * @param webSafe If true, we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */ encodeString (input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return btoa(input);\n        }\n        return this.encodeByteArray(stringToByteArray$1(input), webSafe);\n    },\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * @param input to decode.\r\n     * @param webSafe True if we should use the\r\n     *     alternative alphabet.\r\n     * @return string representing the decoded value.\r\n     */ decodeString (input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return atob(input);\n        }\n        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\n    },\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * In base-64 decoding, groups of four characters are converted into three\r\n     * bytes.  If the encoder did not apply padding, the input length may not\r\n     * be a multiple of 4.\r\n     *\r\n     * In this case, the last group will have fewer than 4 characters, and\r\n     * padding will be inferred.  If the group has one or two characters, it decodes\r\n     * to one byte.  If the group has three characters, it decodes to two bytes.\r\n     *\r\n     * @param input Input to decode.\r\n     * @param webSafe True if we should use the web-safe alphabet.\r\n     * @return bytes representing the decoded value.\r\n     */ decodeStringToByteArray (input, webSafe) {\n        this.init_();\n        const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;\n        const output = [];\n        for(let i = 0; i < input.length;){\n            const byte1 = charToByteMap[input.charAt(i++)];\n            const haveByte2 = i < input.length;\n            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n            ++i;\n            const haveByte3 = i < input.length;\n            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            const haveByte4 = i < input.length;\n            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n                throw new DecodeBase64StringError();\n            }\n            const outByte1 = byte1 << 2 | byte2 >> 4;\n            output.push(outByte1);\n            if (byte3 !== 64) {\n                const outByte2 = byte2 << 4 & 0xf0 | byte3 >> 2;\n                output.push(outByte2);\n                if (byte4 !== 64) {\n                    const outByte3 = byte3 << 6 & 0xc0 | byte4;\n                    output.push(outByte3);\n                }\n            }\n        }\n        return output;\n    },\n    /**\r\n     * Lazy static initialization function. Called before\r\n     * accessing any of the static map variables.\r\n     * @private\r\n     */ init_ () {\n        if (!this.byteToCharMap_) {\n            this.byteToCharMap_ = {};\n            this.charToByteMap_ = {};\n            this.byteToCharMapWebSafe_ = {};\n            this.charToByteMapWebSafe_ = {};\n            // We want quick mappings back and forth, so we precompute two maps.\n            for(let i = 0; i < this.ENCODED_VALS.length; i++){\n                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n                this.charToByteMap_[this.byteToCharMap_[i]] = i;\n                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n                // Be forgiving when decoding and correctly decode both encodings.\n                if (i >= this.ENCODED_VALS_BASE.length) {\n                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n                }\n            }\n        }\n    }\n};\n/**\r\n * An error encountered while decoding base64 string.\r\n */ class DecodeBase64StringError extends Error {\n    constructor(){\n        super(...arguments);\n        this.name = \"DecodeBase64StringError\";\n    }\n}\n/**\r\n * URL-safe base64 encoding\r\n */ const base64Encode = function(str) {\n    const utf8Bytes = stringToByteArray$1(str);\n    return base64.encodeByteArray(utf8Bytes, true);\n};\n/**\r\n * URL-safe base64 encoding (without \".\" padding in the end).\r\n * e.g. Used in JSON Web Token (JWT) parts.\r\n */ const base64urlEncodeWithoutPadding = function(str) {\n    // Use base64url encoding and remove padding in the end (dot characters).\n    return base64Encode(str).replace(/\\./g, \"\");\n};\n/**\r\n * URL-safe base64 decoding\r\n *\r\n * NOTE: DO NOT use the global atob() function - it does NOT support the\r\n * base64Url variant encoding.\r\n *\r\n * @param str To be decoded\r\n * @return Decoded result, if possible\r\n */ const base64Decode = function(str) {\n    try {\n        return base64.decodeString(str, true);\n    } catch (e) {\n        console.error(\"base64Decode failed: \", e);\n    }\n    return null;\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Do a deep-copy of basic JavaScript Objects or Arrays.\r\n */ function deepCopy(value) {\n    return deepExtend(undefined, value);\n}\n/**\r\n * Copy properties from source to target (recursively allows extension\r\n * of Objects and Arrays).  Scalar values in the target are over-written.\r\n * If target is undefined, an object of the appropriate type will be created\r\n * (and returned).\r\n *\r\n * We recursively copy all child properties of plain Objects in the source- so\r\n * that namespace- like dictionaries are merged.\r\n *\r\n * Note that the target can be a function, in which case the properties in\r\n * the source Object are copied onto it as static properties of the Function.\r\n *\r\n * Note: we don't merge __proto__ to prevent prototype pollution\r\n */ function deepExtend(target, source) {\n    if (!(source instanceof Object)) {\n        return source;\n    }\n    switch(source.constructor){\n        case Date:\n            // Treat Dates like scalars; if the target date object had any child\n            // properties - they will be lost!\n            const dateValue = source;\n            return new Date(dateValue.getTime());\n        case Object:\n            if (target === undefined) {\n                target = {};\n            }\n            break;\n        case Array:\n            // Always copy the array source and overwrite the target.\n            target = [];\n            break;\n        default:\n            // Not a plain Object - treat it as a scalar.\n            return source;\n    }\n    for(const prop in source){\n        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\n        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\n            continue;\n        }\n        target[prop] = deepExtend(target[prop], source[prop]);\n    }\n    return target;\n}\nfunction isValidKey(key) {\n    return key !== \"__proto__\";\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Polyfill for `globalThis` object.\r\n * @returns the `globalThis` object for the given environment.\r\n * @public\r\n */ function getGlobal() {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (false) {}\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    throw new Error(\"Unable to locate global object.\");\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const getDefaultsFromGlobal = ()=>getGlobal().__FIREBASE_DEFAULTS__;\n/**\r\n * Attempt to read defaults from a JSON string provided to\r\n * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in\r\n * process(.)env(.)__FIREBASE_DEFAULTS_PATH__\r\n * The dots are in parens because certain compilers (Vite?) cannot\r\n * handle seeing that variable in comments.\r\n * See https://github.com/firebase/firebase-js-sdk/issues/6838\r\n */ const getDefaultsFromEnvVariable = ()=>{\n    if (typeof process === \"undefined\" || typeof process.env === \"undefined\") {\n        return;\n    }\n    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\n    if (defaultsJsonString) {\n        return JSON.parse(defaultsJsonString);\n    }\n};\nconst getDefaultsFromCookie = ()=>{\n    if (typeof document === \"undefined\") {\n        return;\n    }\n    let match;\n    try {\n        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\n    } catch (e) {\n        // Some environments such as Angular Universal SSR have a\n        // `document` object but error on accessing `document.cookie`.\n        return;\n    }\n    const decoded = match && base64Decode(match[1]);\n    return decoded && JSON.parse(decoded);\n};\n/**\r\n * Get the __FIREBASE_DEFAULTS__ object. It checks in order:\r\n * (1) if such an object exists as a property of `globalThis`\r\n * (2) if such an object was provided on a shell environment variable\r\n * (3) if such an object exists in a cookie\r\n * @public\r\n */ const getDefaults = ()=>{\n    try {\n        return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();\n    } catch (e) {\n        /**\r\n         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due\r\n         * to any environment case we have not accounted for. Log to\r\n         * info instead of swallowing so we can find these unknown cases\r\n         * and add paths for them if needed.\r\n         */ console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\n        return;\n    }\n};\n/**\r\n * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available\r\n * @public\r\n */ const getDefaultEmulatorHost = (productName)=>{\n    var _a, _b;\n    return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName];\n};\n/**\r\n * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a pair of hostname and port like `[\"::1\", 4000]` if available\r\n * @public\r\n */ const getDefaultEmulatorHostnameAndPort = (productName)=>{\n    const host = getDefaultEmulatorHost(productName);\n    if (!host) {\n        return undefined;\n    }\n    const separatorIndex = host.lastIndexOf(\":\"); // Finding the last since IPv6 addr also has colons.\n    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {\n        throw new Error(`Invalid host ${host} with no separate hostname and port!`);\n    }\n    // eslint-disable-next-line no-restricted-globals\n    const port = parseInt(host.substring(separatorIndex + 1), 10);\n    if (host[0] === \"[\") {\n        // Bracket-quoted `[ipv6addr]:port` => return \"ipv6addr\" (without brackets).\n        return [\n            host.substring(1, separatorIndex - 1),\n            port\n        ];\n    } else {\n        return [\n            host.substring(0, separatorIndex),\n            port\n        ];\n    }\n};\n/**\r\n * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.\r\n * @public\r\n */ const getDefaultAppConfig = ()=>{\n    var _a;\n    return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config;\n};\n/**\r\n * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties\r\n * prefixed by \"_\")\r\n * @public\r\n */ const getExperimentalSetting = (name)=>{\n    var _a;\n    return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`];\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Deferred {\n    constructor(){\n        this.reject = ()=>{};\n        this.resolve = ()=>{};\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n    /**\r\n     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\r\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\r\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\r\n     */ wrapCallback(callback) {\n        return (error, value)=>{\n            if (error) {\n                this.reject(error);\n            } else {\n                this.resolve(value);\n            }\n            if (typeof callback === \"function\") {\n                // Attaching noop handler just in case developer wasn't expecting\n                // promises\n                this.promise.catch(()=>{});\n                // Some of our callbacks don't expect a value and our own tests\n                // assert that the parameter length is 1\n                if (callback.length === 1) {\n                    callback(error);\n                } else {\n                    callback(error, value);\n                }\n            }\n        };\n    }\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function createMockUserToken(token, projectId) {\n    if (token.uid) {\n        throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\n    }\n    // Unsecured JWTs use \"none\" as the algorithm.\n    const header = {\n        alg: \"none\",\n        type: \"JWT\"\n    };\n    const project = projectId || \"demo-project\";\n    const iat = token.iat || 0;\n    const sub = token.sub || token.user_id;\n    if (!sub) {\n        throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\n    }\n    const payload = Object.assign({\n        // Set all required fields to decent defaults\n        iss: `https://securetoken.google.com/${project}`,\n        aud: project,\n        iat,\n        exp: iat + 3600,\n        auth_time: iat,\n        sub,\n        user_id: sub,\n        firebase: {\n            sign_in_provider: \"custom\",\n            identities: {}\n        }\n    }, token);\n    // Unsecured JWTs use the empty string as a signature.\n    const signature = \"\";\n    return [\n        base64urlEncodeWithoutPadding(JSON.stringify(header)),\n        base64urlEncodeWithoutPadding(JSON.stringify(payload)),\n        signature\n    ].join(\".\");\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns navigator.userAgent string or '' if it's not defined.\r\n * @return user agent string\r\n */ function getUA() {\n    if (typeof navigator !== \"undefined\" && typeof navigator[\"userAgent\"] === \"string\") {\n        return navigator[\"userAgent\"];\n    } else {\n        return \"\";\n    }\n}\n/**\r\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\r\n *\r\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\r\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\r\n * wait for a callback.\r\n */ function isMobileCordova() {\n    return  false && 0;\n}\n/**\r\n * Detect Node.js.\r\n *\r\n * @return true if Node.js environment is detected or specified.\r\n */ // Node detection logic from: https://github.com/iliakan/detect-node/\nfunction isNode() {\n    var _a;\n    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;\n    if (forceEnvironment === \"node\") {\n        return true;\n    } else if (forceEnvironment === \"browser\") {\n        return false;\n    }\n    try {\n        return Object.prototype.toString.call(global.process) === \"[object process]\";\n    } catch (e) {\n        return false;\n    }\n}\n/**\r\n * Detect Browser Environment\r\n */ function isBrowser() {\n    return typeof self === \"object\" && self.self === self;\n}\nfunction isBrowserExtension() {\n    const runtime = typeof chrome === \"object\" ? chrome.runtime : typeof browser === \"object\" ? browser.runtime : undefined;\n    return typeof runtime === \"object\" && runtime.id !== undefined;\n}\n/**\r\n * Detect React Native.\r\n *\r\n * @return true if ReactNative environment is detected.\r\n */ function isReactNative() {\n    return typeof navigator === \"object\" && navigator[\"product\"] === \"ReactNative\";\n}\n/** Detects Electron apps. */ function isElectron() {\n    return getUA().indexOf(\"Electron/\") >= 0;\n}\n/** Detects Internet Explorer. */ function isIE() {\n    const ua = getUA();\n    return ua.indexOf(\"MSIE \") >= 0 || ua.indexOf(\"Trident/\") >= 0;\n}\n/** Detects Universal Windows Platform apps. */ function isUWP() {\n    return getUA().indexOf(\"MSAppHost/\") >= 0;\n}\n/**\r\n * Detect whether the current SDK build is the Node version.\r\n *\r\n * @return true if it's the Node SDK build.\r\n */ function isNodeSdk() {\n    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\n}\n/** Returns true if we are running in Safari. */ function isSafari() {\n    return !isNode() && !!navigator.userAgent && navigator.userAgent.includes(\"Safari\") && !navigator.userAgent.includes(\"Chrome\");\n}\n/**\r\n * This method checks if indexedDB is supported by current browser/service worker context\r\n * @return true if indexedDB is supported by current browser/service worker context\r\n */ function isIndexedDBAvailable() {\n    try {\n        return typeof indexedDB === \"object\";\n    } catch (e) {\n        return false;\n    }\n}\n/**\r\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\r\n * if errors occur during the database open operation.\r\n *\r\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\r\n * private browsing)\r\n */ function validateIndexedDBOpenable() {\n    return new Promise((resolve, reject)=>{\n        try {\n            let preExist = true;\n            const DB_CHECK_NAME = \"validate-browser-context-for-indexeddb-analytics-module\";\n            const request = self.indexedDB.open(DB_CHECK_NAME);\n            request.onsuccess = ()=>{\n                request.result.close();\n                // delete database only when it doesn't pre-exist\n                if (!preExist) {\n                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);\n                }\n                resolve(true);\n            };\n            request.onupgradeneeded = ()=>{\n                preExist = false;\n            };\n            request.onerror = ()=>{\n                var _a;\n                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || \"\");\n            };\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\r\n *\r\n * This method checks whether cookie is enabled within current browser\r\n * @return true if cookie is enabled within current browser\r\n */ function areCookiesEnabled() {\n    if (typeof navigator === \"undefined\" || !navigator.cookieEnabled) {\n        return false;\n    }\n    return true;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview Standardized Firebase Error.\r\n *\r\n * Usage:\r\n *\r\n *   // Typescript string literals for type-safe codes\r\n *   type Err =\r\n *     'unknown' |\r\n *     'object-not-found'\r\n *     ;\r\n *\r\n *   // Closure enum for type-safe error codes\r\n *   // at-enum {string}\r\n *   var Err = {\r\n *     UNKNOWN: 'unknown',\r\n *     OBJECT_NOT_FOUND: 'object-not-found',\r\n *   }\r\n *\r\n *   let errors: Map<Err, string> = {\r\n *     'generic-error': \"Unknown error\",\r\n *     'file-not-found': \"Could not find file: {$file}\",\r\n *   };\r\n *\r\n *   // Type-safe function - must pass a valid error code as param.\r\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\r\n *\r\n *   ...\r\n *   throw error.create(Err.GENERIC);\r\n *   ...\r\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\r\n *   ...\r\n *   // Service: Could not file file: foo.txt (service/file-not-found).\r\n *\r\n *   catch (e) {\r\n *     assert(e.message === \"Could not find file: foo.txt.\");\r\n *     if ((e as FirebaseError)?.code === 'service/file-not-found') {\r\n *       console.log(\"Could not read file: \" + e['file']);\r\n *     }\r\n *   }\r\n */ const ERROR_NAME = \"FirebaseError\";\n// Based on code from:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\nclass FirebaseError extends Error {\n    constructor(/** The error code for this error. */ code, message, /** Custom data for this error. */ customData){\n        super(message);\n        this.code = code;\n        this.customData = customData;\n        /** The custom name for all FirebaseErrors. */ this.name = ERROR_NAME;\n        // Fix For ES5\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, FirebaseError.prototype);\n        // Maintains proper stack trace for where our error was thrown.\n        // Only available on V8.\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ErrorFactory.prototype.create);\n        }\n    }\n}\nclass ErrorFactory {\n    constructor(service, serviceName, errors){\n        this.service = service;\n        this.serviceName = serviceName;\n        this.errors = errors;\n    }\n    create(code, ...data) {\n        const customData = data[0] || {};\n        const fullCode = `${this.service}/${code}`;\n        const template = this.errors[code];\n        const message = template ? replaceTemplate(template, customData) : \"Error\";\n        // Service Name: Error message (service/code).\n        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n        const error = new FirebaseError(fullCode, fullMessage, customData);\n        return error;\n    }\n}\nfunction replaceTemplate(template, data) {\n    return template.replace(PATTERN, (_, key)=>{\n        const value = data[key];\n        return value != null ? String(value) : `<${key}?>`;\n    });\n}\nconst PATTERN = /\\{\\$([^}]+)}/g;\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Evaluates a JSON string into a javascript object.\r\n *\r\n * @param {string} str A string containing JSON.\r\n * @return {*} The javascript object representing the specified JSON.\r\n */ function jsonEval(str) {\n    return JSON.parse(str);\n}\n/**\r\n * Returns JSON representing a javascript object.\r\n * @param {*} data Javascript object to be stringified.\r\n * @return {string} The JSON contents of the object.\r\n */ function stringify(data) {\n    return JSON.stringify(data);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Decodes a Firebase auth. token into constituent parts.\r\n *\r\n * Notes:\r\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const decode = function(token) {\n    let header = {}, claims = {}, data = {}, signature = \"\";\n    try {\n        const parts = token.split(\".\");\n        header = jsonEval(base64Decode(parts[0]) || \"\");\n        claims = jsonEval(base64Decode(parts[1]) || \"\");\n        signature = parts[2];\n        data = claims[\"d\"] || {};\n        delete claims[\"d\"];\n    } catch (e) {}\n    return {\n        header,\n        claims,\n        data,\n        signature\n    };\n};\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\r\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const isValidTimestamp = function(token) {\n    const claims = decode(token).claims;\n    const now = Math.floor(new Date().getTime() / 1000);\n    let validSince = 0, validUntil = 0;\n    if (typeof claims === \"object\") {\n        if (claims.hasOwnProperty(\"nbf\")) {\n            validSince = claims[\"nbf\"];\n        } else if (claims.hasOwnProperty(\"iat\")) {\n            validSince = claims[\"iat\"];\n        }\n        if (claims.hasOwnProperty(\"exp\")) {\n            validUntil = claims[\"exp\"];\n        } else {\n            // token will expire after 24h by default\n            validUntil = validSince + 86400;\n        }\n    }\n    return !!now && !!validSince && !!validUntil && now >= validSince && now <= validUntil;\n};\n/**\r\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\r\n *\r\n * Notes:\r\n * - May return null if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const issuedAtTime = function(token) {\n    const claims = decode(token).claims;\n    if (typeof claims === \"object\" && claims.hasOwnProperty(\"iat\")) {\n        return claims[\"iat\"];\n    }\n    return null;\n};\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const isValidFormat = function(token) {\n    const decoded = decode(token), claims = decoded.claims;\n    return !!claims && typeof claims === \"object\" && claims.hasOwnProperty(\"iat\");\n};\n/**\r\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const isAdmin = function(token) {\n    const claims = decode(token).claims;\n    return typeof claims === \"object\" && claims[\"admin\"] === true;\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction safeGet(obj, key) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return obj[key];\n    } else {\n        return undefined;\n    }\n}\nfunction isEmpty(obj) {\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction map(obj, fn, contextObj) {\n    const res = {};\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            res[key] = fn.call(contextObj, obj[key], key, obj);\n        }\n    }\n    return res;\n}\n/**\r\n * Deep equal two objects. Support Arrays and Objects.\r\n */ function deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    for (const k of aKeys){\n        if (!bKeys.includes(k)) {\n            return false;\n        }\n        const aProp = a[k];\n        const bProp = b[k];\n        if (isObject(aProp) && isObject(bProp)) {\n            if (!deepEqual(aProp, bProp)) {\n                return false;\n            }\n        } else if (aProp !== bProp) {\n            return false;\n        }\n    }\n    for (const k of bKeys){\n        if (!aKeys.includes(k)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isObject(thing) {\n    return thing !== null && typeof thing === \"object\";\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Rejects if the given promise doesn't resolve in timeInMS milliseconds.\r\n * @internal\r\n */ function promiseWithTimeout(promise, timeInMS = 2000) {\n    const deferredPromise = new Deferred();\n    setTimeout(()=>deferredPromise.reject(\"timeout!\"), timeInMS);\n    promise.then(deferredPromise.resolve, deferredPromise.reject);\n    return deferredPromise.promise;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\r\n * params object (e.g. {arg: 'val', arg2: 'val2'})\r\n * Note: You must prepend it with ? when adding it to a URL.\r\n */ function querystring(querystringParams) {\n    const params = [];\n    for (const [key, value] of Object.entries(querystringParams)){\n        if (Array.isArray(value)) {\n            value.forEach((arrayVal)=>{\n                params.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(arrayVal));\n            });\n        } else {\n            params.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(value));\n        }\n    }\n    return params.length ? \"&\" + params.join(\"&\") : \"\";\n}\n/**\r\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\r\n * (e.g. {arg: 'val', arg2: 'val2'})\r\n */ function querystringDecode(querystring) {\n    const obj = {};\n    const tokens = querystring.replace(/^\\?/, \"\").split(\"&\");\n    tokens.forEach((token)=>{\n        if (token) {\n            const [key, value] = token.split(\"=\");\n            obj[decodeURIComponent(key)] = decodeURIComponent(value);\n        }\n    });\n    return obj;\n}\n/**\r\n * Extract the query string part of a URL, including the leading question mark (if present).\r\n */ function extractQuerystring(url) {\n    const queryStart = url.indexOf(\"?\");\n    if (!queryStart) {\n        return \"\";\n    }\n    const fragmentStart = url.indexOf(\"#\", queryStart);\n    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview SHA-1 cryptographic hash.\r\n * Variable names follow the notation in FIPS PUB 180-3:\r\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\r\n *\r\n * Usage:\r\n *   var sha1 = new sha1();\r\n *   sha1.update(bytes);\r\n *   var hash = sha1.digest();\r\n *\r\n * Performance:\r\n *   Chrome 23:   ~400 Mbit/s\r\n *   Firefox 16:  ~250 Mbit/s\r\n *\r\n */ /**\r\n * SHA-1 cryptographic hash constructor.\r\n *\r\n * The properties declared here are discussed in the above algorithm document.\r\n * @constructor\r\n * @final\r\n * @struct\r\n */ class Sha1 {\n    constructor(){\n        /**\r\n         * Holds the previous values of accumulated variables a-e in the compress_\r\n         * function.\r\n         * @private\r\n         */ this.chain_ = [];\n        /**\r\n         * A buffer holding the partially computed hash result.\r\n         * @private\r\n         */ this.buf_ = [];\n        /**\r\n         * An array of 80 bytes, each a part of the message to be hashed.  Referred to\r\n         * as the message schedule in the docs.\r\n         * @private\r\n         */ this.W_ = [];\n        /**\r\n         * Contains data needed to pad messages less than 64 bytes.\r\n         * @private\r\n         */ this.pad_ = [];\n        /**\r\n         * @private {number}\r\n         */ this.inbuf_ = 0;\n        /**\r\n         * @private {number}\r\n         */ this.total_ = 0;\n        this.blockSize = 512 / 8;\n        this.pad_[0] = 128;\n        for(let i = 1; i < this.blockSize; ++i){\n            this.pad_[i] = 0;\n        }\n        this.reset();\n    }\n    reset() {\n        this.chain_[0] = 0x67452301;\n        this.chain_[1] = 0xefcdab89;\n        this.chain_[2] = 0x98badcfe;\n        this.chain_[3] = 0x10325476;\n        this.chain_[4] = 0xc3d2e1f0;\n        this.inbuf_ = 0;\n        this.total_ = 0;\n    }\n    /**\r\n     * Internal compress helper function.\r\n     * @param buf Block to compress.\r\n     * @param offset Offset of the block in the buffer.\r\n     * @private\r\n     */ compress_(buf, offset) {\n        if (!offset) {\n            offset = 0;\n        }\n        const W = this.W_;\n        // get 16 big endian words\n        if (typeof buf === \"string\") {\n            for(let i = 0; i < 16; i++){\n                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\n                // have a bug that turns the post-increment ++ operator into pre-increment\n                // during JIT compilation.  We have code that depends heavily on SHA-1 for\n                // correctness and which is affected by this bug, so I've removed all uses\n                // of post-increment ++ in which the result value is used.  We can revert\n                // this change once the Safari bug\n                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\n                // most clients have been updated.\n                W[i] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);\n                offset += 4;\n            }\n        } else {\n            for(let i = 0; i < 16; i++){\n                W[i] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];\n                offset += 4;\n            }\n        }\n        // expand to 80 words\n        for(let i = 16; i < 80; i++){\n            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n            W[i] = (t << 1 | t >>> 31) & 0xffffffff;\n        }\n        let a = this.chain_[0];\n        let b = this.chain_[1];\n        let c = this.chain_[2];\n        let d = this.chain_[3];\n        let e = this.chain_[4];\n        let f, k;\n        // TODO(user): Try to unroll this loop to speed up the computation.\n        for(let i = 0; i < 80; i++){\n            if (i < 40) {\n                if (i < 20) {\n                    f = d ^ b & (c ^ d);\n                    k = 0x5a827999;\n                } else {\n                    f = b ^ c ^ d;\n                    k = 0x6ed9eba1;\n                }\n            } else {\n                if (i < 60) {\n                    f = b & c | d & (b | c);\n                    k = 0x8f1bbcdc;\n                } else {\n                    f = b ^ c ^ d;\n                    k = 0xca62c1d6;\n                }\n            }\n            const t = (a << 5 | a >>> 27) + f + e + k + W[i] & 0xffffffff;\n            e = d;\n            d = c;\n            c = (b << 30 | b >>> 2) & 0xffffffff;\n            b = a;\n            a = t;\n        }\n        this.chain_[0] = this.chain_[0] + a & 0xffffffff;\n        this.chain_[1] = this.chain_[1] + b & 0xffffffff;\n        this.chain_[2] = this.chain_[2] + c & 0xffffffff;\n        this.chain_[3] = this.chain_[3] + d & 0xffffffff;\n        this.chain_[4] = this.chain_[4] + e & 0xffffffff;\n    }\n    update(bytes, length) {\n        // TODO(johnlenz): tighten the function signature and remove this check\n        if (bytes == null) {\n            return;\n        }\n        if (length === undefined) {\n            length = bytes.length;\n        }\n        const lengthMinusBlock = length - this.blockSize;\n        let n = 0;\n        // Using local instead of member variables gives ~5% speedup on Firefox 16.\n        const buf = this.buf_;\n        let inbuf = this.inbuf_;\n        // The outer while loop should execute at most twice.\n        while(n < length){\n            // When we have no data in the block to top up, we can directly process the\n            // input buffer (assuming it contains sufficient data). This gives ~25%\n            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\n            // the data is provided in large chunks (or in multiples of 64 bytes).\n            if (inbuf === 0) {\n                while(n <= lengthMinusBlock){\n                    this.compress_(bytes, n);\n                    n += this.blockSize;\n                }\n            }\n            if (typeof bytes === \"string\") {\n                while(n < length){\n                    buf[inbuf] = bytes.charCodeAt(n);\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        break;\n                    }\n                }\n            } else {\n                while(n < length){\n                    buf[inbuf] = bytes[n];\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        this.inbuf_ = inbuf;\n        this.total_ += length;\n    }\n    /** @override */ digest() {\n        const digest = [];\n        let totalBits = this.total_ * 8;\n        // Add pad 0x80 0x00*.\n        if (this.inbuf_ < 56) {\n            this.update(this.pad_, 56 - this.inbuf_);\n        } else {\n            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\n        }\n        // Add # bits.\n        for(let i = this.blockSize - 1; i >= 56; i--){\n            this.buf_[i] = totalBits & 255;\n            totalBits /= 256; // Don't use bit-shifting here!\n        }\n        this.compress_(this.buf_);\n        let n = 0;\n        for(let i = 0; i < 5; i++){\n            for(let j = 24; j >= 0; j -= 8){\n                digest[n] = this.chain_[i] >> j & 255;\n                ++n;\n            }\n        }\n        return digest;\n    }\n}\n/**\r\n * Helper to make a Subscribe function (just like Promise helps make a\r\n * Thenable).\r\n *\r\n * @param executor Function which can make calls to a single Observer\r\n *     as a proxy.\r\n * @param onNoObservers Callback when count of Observers goes to zero.\r\n */ function createSubscribe(executor, onNoObservers) {\n    const proxy = new ObserverProxy(executor, onNoObservers);\n    return proxy.subscribe.bind(proxy);\n}\n/**\r\n * Implement fan-out for any number of Observers attached via a subscribe\r\n * function.\r\n */ class ObserverProxy {\n    /**\r\n     * @param executor Function which can make calls to a single Observer\r\n     *     as a proxy.\r\n     * @param onNoObservers Callback when count of Observers goes to zero.\r\n     */ constructor(executor, onNoObservers){\n        this.observers = [];\n        this.unsubscribes = [];\n        this.observerCount = 0;\n        // Micro-task scheduling by calling task.then().\n        this.task = Promise.resolve();\n        this.finalized = false;\n        this.onNoObservers = onNoObservers;\n        // Call the executor asynchronously so subscribers that are called\n        // synchronously after the creation of the subscribe function\n        // can still receive the very first value generated in the executor.\n        this.task.then(()=>{\n            executor(this);\n        }).catch((e)=>{\n            this.error(e);\n        });\n    }\n    next(value) {\n        this.forEachObserver((observer)=>{\n            observer.next(value);\n        });\n    }\n    error(error) {\n        this.forEachObserver((observer)=>{\n            observer.error(error);\n        });\n        this.close(error);\n    }\n    complete() {\n        this.forEachObserver((observer)=>{\n            observer.complete();\n        });\n        this.close();\n    }\n    /**\r\n     * Subscribe function that can be used to add an Observer to the fan-out list.\r\n     *\r\n     * - We require that no event is sent to a subscriber sychronously to their\r\n     *   call to subscribe().\r\n     */ subscribe(nextOrObserver, error, complete) {\n        let observer;\n        if (nextOrObserver === undefined && error === undefined && complete === undefined) {\n            throw new Error(\"Missing Observer.\");\n        }\n        // Assemble an Observer object when passed as callback functions.\n        if (implementsAnyMethods(nextOrObserver, [\n            \"next\",\n            \"error\",\n            \"complete\"\n        ])) {\n            observer = nextOrObserver;\n        } else {\n            observer = {\n                next: nextOrObserver,\n                error,\n                complete\n            };\n        }\n        if (observer.next === undefined) {\n            observer.next = noop;\n        }\n        if (observer.error === undefined) {\n            observer.error = noop;\n        }\n        if (observer.complete === undefined) {\n            observer.complete = noop;\n        }\n        const unsub = this.unsubscribeOne.bind(this, this.observers.length);\n        // Attempt to subscribe to a terminated Observable - we\n        // just respond to the Observer with the final error or complete\n        // event.\n        if (this.finalized) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.task.then(()=>{\n                try {\n                    if (this.finalError) {\n                        observer.error(this.finalError);\n                    } else {\n                        observer.complete();\n                    }\n                } catch (e) {\n                // nothing\n                }\n                return;\n            });\n        }\n        this.observers.push(observer);\n        return unsub;\n    }\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\n    // any unsubscribed Observer.\n    unsubscribeOne(i) {\n        if (this.observers === undefined || this.observers[i] === undefined) {\n            return;\n        }\n        delete this.observers[i];\n        this.observerCount -= 1;\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n            this.onNoObservers(this);\n        }\n    }\n    forEachObserver(fn) {\n        if (this.finalized) {\n            // Already closed by previous event....just eat the additional values.\n            return;\n        }\n        // Since sendOne calls asynchronously - there is no chance that\n        // this.observers will become undefined.\n        for(let i = 0; i < this.observers.length; i++){\n            this.sendOne(i, fn);\n        }\n    }\n    // Call the Observer via one of it's callback function. We are careful to\n    // confirm that the observe has not been unsubscribed since this asynchronous\n    // function had been queued.\n    sendOne(i, fn) {\n        // Execute the callback asynchronously\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(()=>{\n            if (this.observers !== undefined && this.observers[i] !== undefined) {\n                try {\n                    fn(this.observers[i]);\n                } catch (e) {\n                    // Ignore exceptions raised in Observers or missing methods of an\n                    // Observer.\n                    // Log error to console. b/31404806\n                    if (typeof console !== \"undefined\" && console.error) {\n                        console.error(e);\n                    }\n                }\n            }\n        });\n    }\n    close(err) {\n        if (this.finalized) {\n            return;\n        }\n        this.finalized = true;\n        if (err !== undefined) {\n            this.finalError = err;\n        }\n        // Proxy is no longer needed - garbage collect references\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(()=>{\n            this.observers = undefined;\n            this.onNoObservers = undefined;\n        });\n    }\n}\n/** Turn synchronous function into one called asynchronously. */ // eslint-disable-next-line @typescript-eslint/ban-types\nfunction async(fn, onError) {\n    return (...args)=>{\n        Promise.resolve(true).then(()=>{\n            fn(...args);\n        }).catch((error)=>{\n            if (onError) {\n                onError(error);\n            }\n        });\n    };\n}\n/**\r\n * Return true if the object passed in implements any of the named methods.\r\n */ function implementsAnyMethods(obj, methods) {\n    if (typeof obj !== \"object\" || obj === null) {\n        return false;\n    }\n    for (const method of methods){\n        if (method in obj && typeof obj[method] === \"function\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction noop() {\n// do nothing\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Check to make sure the appropriate number of arguments are provided for a public function.\r\n * Throws an error if it fails.\r\n *\r\n * @param fnName The function name\r\n * @param minCount The minimum number of arguments to allow for the function call\r\n * @param maxCount The maximum number of argument to allow for the function call\r\n * @param argCount The actual number of arguments provided.\r\n */ const validateArgCount = function(fnName, minCount, maxCount, argCount) {\n    let argError;\n    if (argCount < minCount) {\n        argError = \"at least \" + minCount;\n    } else if (argCount > maxCount) {\n        argError = maxCount === 0 ? \"none\" : \"no more than \" + maxCount;\n    }\n    if (argError) {\n        const error = fnName + \" failed: Was called with \" + argCount + (argCount === 1 ? \" argument.\" : \" arguments.\") + \" Expects \" + argError + \".\";\n        throw new Error(error);\n    }\n};\n/**\r\n * Generates a string to prefix an error message about failed argument validation\r\n *\r\n * @param fnName The function name\r\n * @param argName The name of the argument\r\n * @return The prefix to add to the error thrown for validation.\r\n */ function errorPrefix(fnName, argName) {\n    return `${fnName} failed: ${argName} argument `;\n}\n/**\r\n * @param fnName\r\n * @param argumentNumber\r\n * @param namespace\r\n * @param optional\r\n */ function validateNamespace(fnName, namespace, optional) {\n    if (optional && !namespace) {\n        return;\n    }\n    if (typeof namespace !== \"string\") {\n        //TODO: I should do more validation here. We only allow certain chars in namespaces.\n        throw new Error(errorPrefix(fnName, \"namespace\") + \"must be a valid firebase namespace.\");\n    }\n}\nfunction validateCallback(fnName, argumentName, // eslint-disable-next-line @typescript-eslint/ban-types\ncallback, optional) {\n    if (optional && !callback) {\n        return;\n    }\n    if (typeof callback !== \"function\") {\n        throw new Error(errorPrefix(fnName, argumentName) + \"must be a valid function.\");\n    }\n}\nfunction validateContextObject(fnName, argumentName, context, optional) {\n    if (optional && !context) {\n        return;\n    }\n    if (typeof context !== \"object\" || context === null) {\n        throw new Error(errorPrefix(fnName, argumentName) + \"must be a valid context object.\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\n// so it's been modified.\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\n// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\n// pair).\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\n/**\r\n * @param {string} str\r\n * @return {Array}\r\n */ const stringToByteArray = function(str) {\n    const out = [];\n    let p = 0;\n    for(let i = 0; i < str.length; i++){\n        let c = str.charCodeAt(i);\n        // Is this the lead surrogate in a surrogate pair?\n        if (c >= 0xd800 && c <= 0xdbff) {\n            const high = c - 0xd800; // the high 10 bits.\n            i++;\n            assert(i < str.length, \"Surrogate pair missing trail surrogate.\");\n            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\n            c = 0x10000 + (high << 10) + low;\n        }\n        if (c < 128) {\n            out[p++] = c;\n        } else if (c < 2048) {\n            out[p++] = c >> 6 | 192;\n            out[p++] = c & 63 | 128;\n        } else if (c < 65536) {\n            out[p++] = c >> 12 | 224;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        } else {\n            out[p++] = c >> 18 | 240;\n            out[p++] = c >> 12 & 63 | 128;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        }\n    }\n    return out;\n};\n/**\r\n * Calculate length without actually converting; useful for doing cheaper validation.\r\n * @param {string} str\r\n * @return {number}\r\n */ const stringLength = function(str) {\n    let p = 0;\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 128) {\n            p++;\n        } else if (c < 2048) {\n            p += 2;\n        } else if (c >= 0xd800 && c <= 0xdbff) {\n            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\n            p += 4;\n            i++; // skip trail surrogate.\n        } else {\n            p += 3;\n        }\n    }\n    return p;\n};\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Copied from https://stackoverflow.com/a/2117523\r\n * Generates a new uuid.\r\n * @public\r\n */ const uuidv4 = function() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n        const r = Math.random() * 16 | 0, v = c === \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n};\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The amount of milliseconds to exponentially increase.\r\n */ const DEFAULT_INTERVAL_MILLIS = 1000;\n/**\r\n * The factor to backoff by.\r\n * Should be a number greater than 1.\r\n */ const DEFAULT_BACKOFF_FACTOR = 2;\n/**\r\n * The maximum milliseconds to increase to.\r\n *\r\n * <p>Visible for testing\r\n */ const MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\n/**\r\n * The percentage of backoff time to randomize by.\r\n * See\r\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\r\n * for context.\r\n *\r\n * <p>Visible for testing\r\n */ const RANDOM_FACTOR = 0.5;\n/**\r\n * Based on the backoff method from\r\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\r\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\r\n */ function calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {\n    // Calculates an exponentially increasing value.\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\n    // and count to restore state.\n    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\n    // A random \"fuzz\" to avoid waves of retries.\n    // Deviation: randomFactor is required.\n    const randomWait = Math.round(// A fraction of the backoff value to add/subtract.\n    // Deviation: changes multiplication order to improve readability.\n    RANDOM_FACTOR * currBaseValue * // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\n    // if we add or subtract.\n    (Math.random() - 0.5) * 2);\n    // Limits backoff to max to avoid effectively permanent backoff.\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provide English ordinal letters after a number\r\n */ function ordinal(i) {\n    if (!Number.isFinite(i)) {\n        return `${i}`;\n    }\n    return i + indicator(i);\n}\nfunction indicator(i) {\n    i = Math.abs(i);\n    const cent = i % 100;\n    if (cent >= 10 && cent <= 20) {\n        return \"th\";\n    }\n    const dec = i % 10;\n    if (dec === 1) {\n        return \"st\";\n    }\n    if (dec === 2) {\n        return \"nd\";\n    }\n    if (dec === 3) {\n        return \"rd\";\n    }\n    return \"th\";\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function getModularInstance(service) {\n    if (service && service._delegate) {\n        return service._delegate;\n    } else {\n        return service;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Overriding the constant (we should be the only ones doing this)\nCONSTANTS.NODE_CLIENT = true;\n //# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1BLFlBQVk7SUFDZDs7S0FFQyxHQUNEQyxhQUFhO0lBQ2I7O0tBRUMsR0FDREMsWUFBWTtJQUNaOztLQUVDLEdBQ0RDLGFBQWE7QUFDakI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1DLFNBQVMsU0FBVUMsU0FBUyxFQUFFQyxPQUFPO0lBQ3ZDLElBQUksQ0FBQ0QsV0FBVztRQUNaLE1BQU1FLGVBQWVEO0lBQ3pCO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU1DLGlCQUFpQixTQUFVRCxPQUFPO0lBQ3BDLE9BQU8sSUFBSUUsTUFBTSx3QkFDYlIsVUFBVUcsV0FBVyxHQUNyQiwrQkFDQUc7QUFDUjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELE1BQU1HLHNCQUFzQixTQUFVQyxHQUFHO0lBQ3JDLDJEQUEyRDtJQUMzRCxNQUFNQyxNQUFNLEVBQUU7SUFDZCxJQUFJQyxJQUFJO0lBQ1IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILElBQUlJLE1BQU0sRUFBRUQsSUFBSztRQUNqQyxJQUFJRSxJQUFJTCxJQUFJTSxVQUFVLENBQUNIO1FBQ3ZCLElBQUlFLElBQUksS0FBSztZQUNUSixHQUFHLENBQUNDLElBQUksR0FBR0c7UUFDZixPQUNLLElBQUlBLElBQUksTUFBTTtZQUNmSixHQUFHLENBQUNDLElBQUksR0FBRyxLQUFNLElBQUs7WUFDdEJELEdBQUcsQ0FBQ0MsSUFBSSxHQUFHLElBQUssS0FBTTtRQUMxQixPQUNLLElBQUksQ0FBQ0csSUFBSSxNQUFLLE1BQU8sVUFD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QVM7SUFDNUIsT0FDSztRQUNELE9BQU85SjtJQUNYO0FBQ0o7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxrRUFBa0U7QUFDbEUxTSxVQUFVQyxXQUFXLEdBQUc7QUFFbzhCLENBQzU5QiwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaWdhc3BhbmR1Ly4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3Qvbm9kZS1lc20vaW5kZXgubm9kZS5lc20uanM/OWU3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBGaXJlYmFzZSBjb25zdGFudHMuICBTb21lIG9mIHRoZXNlIChAZGVmaW5lcykgY2FuIGJlIG92ZXJyaWRkZW4gYXQgY29tcGlsZS10aW1lLlxyXG4gKi9cclxuY29uc3QgQ09OU1RBTlRTID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIGNsaWVudCBOb2RlLmpzIFNESy5cclxuICAgICAqL1xyXG4gICAgTk9ERV9DTElFTlQ6IGZhbHNlLFxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIEFkbWluIE5vZGUuanMgU0RLLlxyXG4gICAgICovXHJcbiAgICBOT0RFX0FETUlOOiBmYWxzZSxcclxuICAgIC8qKlxyXG4gICAgICogRmlyZWJhc2UgU0RLIFZlcnNpb25cclxuICAgICAqL1xyXG4gICAgU0RLX1ZFUlNJT046ICcke0pTQ09SRV9WRVJTSU9OfSdcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcHJvdmlkZWQgYXNzZXJ0aW9uIGlzIGZhbHN5XHJcbiAqL1xyXG5jb25zdCBhc3NlcnQgPSBmdW5jdGlvbiAoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoIWFzc2VydGlvbikge1xyXG4gICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUmV0dXJucyBhbiBFcnJvciBvYmplY3Qgc3VpdGFibGUgZm9yIHRocm93aW5nLlxyXG4gKi9cclxuY29uc3QgYXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIG5ldyBFcnJvcignRmlyZWJhc2UgRGF0YWJhc2UgKCcgK1xyXG4gICAgICAgIENPTlNUQU5UUy5TREtfVkVSU0lPTiArXHJcbiAgICAgICAgJykgSU5URVJOQUwgQVNTRVJUIEZBSUxFRDogJyArXHJcbiAgICAgICAgbWVzc2FnZSk7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5JDEgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxyXG4gICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICBsZXQgcCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSBjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxyXG4gICAgICAgICAgICBpICsgMSA8IHN0ci5sZW5ndGggJiZcclxuICAgICAgICAgICAgKHN0ci5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xyXG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxyXG4gICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAmIDB4MDNmZikgPDwgMTApICsgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDAzZmYpO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTIpIHwgMjI0O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG4vKipcclxuICogVHVybnMgYW4gYXJyYXkgb2YgbnVtYmVycyBpbnRvIHRoZSBzdHJpbmcgZ2l2ZW4gYnkgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlXHJcbiAqIGNoYXJhY3RlcnMgdG8gd2hpY2ggdGhlIG51bWJlcnMgY29ycmVzcG9uZC5cclxuICogQHBhcmFtIGJ5dGVzIEFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGNoYXJhY3RlcnMuXHJcbiAqIEByZXR1cm4gU3RyaW5naWZpY2F0aW9uIG9mIHRoZSBhcnJheS5cclxuICovXHJcbmNvbnN0IGJ5dGVBcnJheVRvU3RyaW5nID0gZnVuY3Rpb24gKGJ5dGVzKSB7XHJcbiAgICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxyXG4gICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICBsZXQgcG9zID0gMCwgYyA9IDA7XHJcbiAgICB3aGlsZSAocG9zIDwgYnl0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgYzEgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMxID4gMTkxICYmIGMxIDwgMjI0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjMSAmIDMxKSA8PCA2KSB8IChjMiAmIDYzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMxID4gMjM5ICYmIGMxIDwgMzY1KSB7XHJcbiAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBjb25zdCBjMyA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgY29uc3QgYzQgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIGNvbnN0IHUgPSAoKChjMSAmIDcpIDw8IDE4KSB8ICgoYzIgJiA2MykgPDwgMTIpIHwgKChjMyAmIDYzKSA8PCA2KSB8IChjNCAmIDYzKSkgLVxyXG4gICAgICAgICAgICAgICAgMHgxMDAwMDtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgwMCArICh1ID4+IDEwKSk7XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGRjMDAgKyAodSAmIDEwMjMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBjb25zdCBjMyA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYzEgJiAxNSkgPDwgMTIpIHwgKChjMiAmIDYzKSA8PCA2KSB8IChjMyAmIDYzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcclxufTtcclxuLy8gV2UgZGVmaW5lIGl0IGFzIGFuIG9iamVjdCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjbGFzcyBiZWNhdXNlIGEgY2xhc3MgY29tcGlsZWQgZG93biB0byBlczUgY2FuJ3RcclxuLy8gYmUgdHJlZXNoYWtlZC4gaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzE2OTFcclxuLy8gU3RhdGljIGxvb2t1cCBtYXBzLCBsYXppbHkgcG9wdWxhdGVkIGJ5IGluaXRfKClcclxuY29uc3QgYmFzZTY0ID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIGNoYXJhY3RlcnMuXHJcbiAgICAgKi9cclxuICAgIGJ5dGVUb0NoYXJNYXBfOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGNoYXJhY3RlcnMgdG8gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIGNoYXJUb0J5dGVNYXBfOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIHdlYnNhZmUgY2hhcmFjdGVycy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGJ5dGVUb0NoYXJNYXBXZWJTYWZlXzogbnVsbCxcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyB3ZWJzYWZlIGNoYXJhY3RlcnMgdG8gYnl0ZXMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjaGFyVG9CeXRlTWFwV2ViU2FmZV86IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LCBzaGFyZWQgYmV0d2VlblxyXG4gICAgICogRU5DT0RFRF9WQUxTIGFuZCBFTkNPREVEX1ZBTFNfV0VCU0FGRVxyXG4gICAgICovXHJcbiAgICBFTkNPREVEX1ZBTFNfQkFTRTogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJyArICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicgKyAnMDEyMzQ1Njc4OScsXHJcbiAgICAvKipcclxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LiBWYWx1ZSA2NCAoPSkgaXMgc3BlY2lhbDsgaXQgbWVhbnMgXCJub3RoaW5nLlwiXHJcbiAgICAgKi9cclxuICAgIGdldCBFTkNPREVEX1ZBTFMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnKy89JztcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIE91ciB3ZWJzYWZlIGFscGhhYmV0LlxyXG4gICAgICovXHJcbiAgICBnZXQgRU5DT0RFRF9WQUxTX1dFQlNBRkUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnLV8uJztcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHRoZSBhdG9iIGFuZCBidG9hIGZ1bmN0aW9ucy4gVGhpcyBleHRlbnNpb25cclxuICAgICAqIHN0YXJ0ZWQgYXQgTW96aWxsYSBidXQgaXMgbm93IGltcGxlbWVudGVkIGJ5IG1hbnkgYnJvd3NlcnMuIFdlIHVzZSB0aGVcclxuICAgICAqIEFTU1VNRV8qIHZhcmlhYmxlcyB0byBhdm9pZCBwdWxsaW5nIGluIHRoZSBmdWxsIHVzZXJhZ2VudCBkZXRlY3Rpb24gbGlicmFyeVxyXG4gICAgICogYnV0IHN0aWxsIGFsbG93aW5nIHRoZSBzdGFuZGFyZCBwZXItYnJvd3NlciBjb21waWxhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBIQVNfTkFUSVZFX1NVUFBPUlQ6IHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nLFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZW5jb2RlIGFuIGFycmF5IG9mIGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dCBBbiBhcnJheSBvZiBieXRlcyAobnVtYmVycyB3aXRoXHJcbiAgICAgKiAgICAgdmFsdWUgaW4gWzAsIDI1NV0pIHRvIGVuY29kZS5cclxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIEJvb2xlYW4gaW5kaWNhdGluZyB3ZSBzaG91bGQgdXNlIHRoZVxyXG4gICAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxyXG4gICAgICogQHJldHVybiBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBlbmNvZGVCeXRlQXJyYXkoaW5wdXQsIHdlYlNhZmUpIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdlbmNvZGVCeXRlQXJyYXkgdGFrZXMgYW4gYXJyYXkgYXMgYSBwYXJhbWV0ZXInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0XygpO1xyXG4gICAgICAgIGNvbnN0IGJ5dGVUb0NoYXJNYXAgPSB3ZWJTYWZlXHJcbiAgICAgICAgICAgID8gdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9cclxuICAgICAgICAgICAgOiB0aGlzLmJ5dGVUb0NoYXJNYXBfO1xyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBpbnB1dFtpXTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSArIDEgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUyID0gaGF2ZUJ5dGUyID8gaW5wdXRbaSArIDFdIDogMDtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUzID0gaSArIDIgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gaW5wdXRbaSArIDJdIDogMDtcclxuICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTEgPSBieXRlMSA+PiAyO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRCeXRlMiA9ICgoYnl0ZTEgJiAweDAzKSA8PCA0KSB8IChieXRlMiA+PiA0KTtcclxuICAgICAgICAgICAgbGV0IG91dEJ5dGUzID0gKChieXRlMiAmIDB4MGYpIDw8IDIpIHwgKGJ5dGUzID4+IDYpO1xyXG4gICAgICAgICAgICBsZXQgb3V0Qnl0ZTQgPSBieXRlMyAmIDB4M2Y7XHJcbiAgICAgICAgICAgIGlmICghaGF2ZUJ5dGUzKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRCeXRlNCA9IDY0O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXZlQnl0ZTIpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRCeXRlMyA9IDY0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTFdLCBieXRlVG9DaGFyTWFwW291dEJ5dGUyXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlM10sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTRdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1lbmNvZGUgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlucHV0IEEgc3RyaW5nIHRvIGVuY29kZS5cclxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIElmIHRydWUsIHdlIHNob3VsZCB1c2UgdGhlXHJcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGVuY29kZVN0cmluZyhpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XHJcbiAgICAgICAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxyXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYnRvYShpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZUJ5dGVBcnJheShzdHJpbmdUb0J5dGVBcnJheSQxKGlucHV0KSwgd2ViU2FmZSk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dCB0byBkZWNvZGUuXHJcbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlXHJcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXHJcbiAgICAgKiBAcmV0dXJuIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGRlY29kZVN0cmluZyhpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XHJcbiAgICAgICAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxyXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXRvYihpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBieXRlQXJyYXlUb1N0cmluZyh0aGlzLmRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEluIGJhc2UtNjQgZGVjb2RpbmcsIGdyb3VwcyBvZiBmb3VyIGNoYXJhY3RlcnMgYXJlIGNvbnZlcnRlZCBpbnRvIHRocmVlXHJcbiAgICAgKiBieXRlcy4gIElmIHRoZSBlbmNvZGVyIGRpZCBub3QgYXBwbHkgcGFkZGluZywgdGhlIGlucHV0IGxlbmd0aCBtYXkgbm90XHJcbiAgICAgKiBiZSBhIG11bHRpcGxlIG9mIDQuXHJcbiAgICAgKlxyXG4gICAgICogSW4gdGhpcyBjYXNlLCB0aGUgbGFzdCBncm91cCB3aWxsIGhhdmUgZmV3ZXIgdGhhbiA0IGNoYXJhY3RlcnMsIGFuZFxyXG4gICAgICogcGFkZGluZyB3aWxsIGJlIGluZmVycmVkLiAgSWYgdGhlIGdyb3VwIGhhcyBvbmUgb3IgdHdvIGNoYXJhY3RlcnMsIGl0IGRlY29kZXNcclxuICAgICAqIHRvIG9uZSBieXRlLiAgSWYgdGhlIGdyb3VwIGhhcyB0aHJlZSBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzIHRvIHR3byBieXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgSW5wdXQgdG8gZGVjb2RlLlxyXG4gICAgICogQHBhcmFtIHdlYlNhZmUgVHJ1ZSBpZiB3ZSBzaG91bGQgdXNlIHRoZSB3ZWItc2FmZSBhbHBoYWJldC5cclxuICAgICAqIEByZXR1cm4gYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBkZWNvZGVTdHJpbmdUb0J5dGVBcnJheShpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIHRoaXMuaW5pdF8oKTtcclxuICAgICAgICBjb25zdCBjaGFyVG9CeXRlTWFwID0gd2ViU2FmZVxyXG4gICAgICAgICAgICA/IHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfXHJcbiAgICAgICAgICAgIDogdGhpcy5jaGFyVG9CeXRlTWFwXztcclxuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDspIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKyspXTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiAwO1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMyA9IGkgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogNjQ7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGU0ID0gaSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTQgPSBoYXZlQnl0ZTQgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBpZiAoYnl0ZTEgPT0gbnVsbCB8fCBieXRlMiA9PSBudWxsIHx8IGJ5dGUzID09IG51bGwgfHwgYnl0ZTQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERlY29kZUJhc2U2NFN0cmluZ0Vycm9yKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTEgPSAoYnl0ZTEgPDwgMikgfCAoYnl0ZTIgPj4gNCk7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUxKTtcclxuICAgICAgICAgICAgaWYgKGJ5dGUzICE9PSA2NCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTIgPSAoKGJ5dGUyIDw8IDQpICYgMHhmMCkgfCAoYnl0ZTMgPj4gMik7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMik7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZTQgIT09IDY0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTMgPSAoKGJ5dGUzIDw8IDYpICYgMHhjMCkgfCBieXRlNDtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIExhenkgc3RhdGljIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uLiBDYWxsZWQgYmVmb3JlXHJcbiAgICAgKiBhY2Nlc3NpbmcgYW55IG9mIHRoZSBzdGF0aWMgbWFwIHZhcmlhYmxlcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGluaXRfKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5ieXRlVG9DaGFyTWFwXykge1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF8gPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV8gPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV8gPSB7fTtcclxuICAgICAgICAgICAgLy8gV2Ugd2FudCBxdWljayBtYXBwaW5ncyBiYWNrIGFuZCBmb3J0aCwgc28gd2UgcHJlY29tcHV0ZSB0d28gbWFwcy5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVOQ09ERURfVkFMUy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF9bdGhpcy5ieXRlVG9DaGFyTWFwX1tpXV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9baV0gPSB0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldXSA9IGk7XHJcbiAgICAgICAgICAgICAgICAvLyBCZSBmb3JnaXZpbmcgd2hlbiBkZWNvZGluZyBhbmQgY29ycmVjdGx5IGRlY29kZSBib3RoIGVuY29kaW5ncy5cclxuICAgICAgICAgICAgICAgIGlmIChpID49IHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQW4gZXJyb3IgZW5jb3VudGVyZWQgd2hpbGUgZGVjb2RpbmcgYmFzZTY0IHN0cmluZy5cclxuICovXHJcbmNsYXNzIERlY29kZUJhc2U2NFN0cmluZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSAnRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3InO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmdcclxuICovXHJcbmNvbnN0IGJhc2U2NEVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGNvbnN0IHV0ZjhCeXRlcyA9IHN0cmluZ1RvQnl0ZUFycmF5JDEoc3RyKTtcclxuICAgIHJldHVybiBiYXNlNjQuZW5jb2RlQnl0ZUFycmF5KHV0ZjhCeXRlcywgdHJ1ZSk7XHJcbn07XHJcbi8qKlxyXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmcgKHdpdGhvdXQgXCIuXCIgcGFkZGluZyBpbiB0aGUgZW5kKS5cclxuICogZS5nLiBVc2VkIGluIEpTT04gV2ViIFRva2VuIChKV1QpIHBhcnRzLlxyXG4gKi9cclxuY29uc3QgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAvLyBVc2UgYmFzZTY0dXJsIGVuY29kaW5nIGFuZCByZW1vdmUgcGFkZGluZyBpbiB0aGUgZW5kIChkb3QgY2hhcmFjdGVycykuXHJcbiAgICByZXR1cm4gYmFzZTY0RW5jb2RlKHN0cikucmVwbGFjZSgvXFwuL2csICcnKTtcclxufTtcclxuLyoqXHJcbiAqIFVSTC1zYWZlIGJhc2U2NCBkZWNvZGluZ1xyXG4gKlxyXG4gKiBOT1RFOiBETyBOT1QgdXNlIHRoZSBnbG9iYWwgYXRvYigpIGZ1bmN0aW9uIC0gaXQgZG9lcyBOT1Qgc3VwcG9ydCB0aGVcclxuICogYmFzZTY0VXJsIHZhcmlhbnQgZW5jb2RpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBzdHIgVG8gYmUgZGVjb2RlZFxyXG4gKiBAcmV0dXJuIERlY29kZWQgcmVzdWx0LCBpZiBwb3NzaWJsZVxyXG4gKi9cclxuY29uc3QgYmFzZTY0RGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gYmFzZTY0LmRlY29kZVN0cmluZyhzdHIsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdiYXNlNjREZWNvZGUgZmFpbGVkOiAnLCBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRG8gYSBkZWVwLWNvcHkgb2YgYmFzaWMgSmF2YVNjcmlwdCBPYmplY3RzIG9yIEFycmF5cy5cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBDb3B5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gZGVlcEV4dGVuZCh1bmRlZmluZWQsIHZhbHVlKTtcclxufVxyXG4vKipcclxuICogQ29weSBwcm9wZXJ0aWVzIGZyb20gc291cmNlIHRvIHRhcmdldCAocmVjdXJzaXZlbHkgYWxsb3dzIGV4dGVuc2lvblxyXG4gKiBvZiBPYmplY3RzIGFuZCBBcnJheXMpLiAgU2NhbGFyIHZhbHVlcyBpbiB0aGUgdGFyZ2V0IGFyZSBvdmVyLXdyaXR0ZW4uXHJcbiAqIElmIHRhcmdldCBpcyB1bmRlZmluZWQsIGFuIG9iamVjdCBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZSB3aWxsIGJlIGNyZWF0ZWRcclxuICogKGFuZCByZXR1cm5lZCkuXHJcbiAqXHJcbiAqIFdlIHJlY3Vyc2l2ZWx5IGNvcHkgYWxsIGNoaWxkIHByb3BlcnRpZXMgb2YgcGxhaW4gT2JqZWN0cyBpbiB0aGUgc291cmNlLSBzb1xyXG4gKiB0aGF0IG5hbWVzcGFjZS0gbGlrZSBkaWN0aW9uYXJpZXMgYXJlIG1lcmdlZC5cclxuICpcclxuICogTm90ZSB0aGF0IHRoZSB0YXJnZXQgY2FuIGJlIGEgZnVuY3Rpb24sIGluIHdoaWNoIGNhc2UgdGhlIHByb3BlcnRpZXMgaW5cclxuICogdGhlIHNvdXJjZSBPYmplY3QgYXJlIGNvcGllZCBvbnRvIGl0IGFzIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBGdW5jdGlvbi5cclxuICpcclxuICogTm90ZTogd2UgZG9uJ3QgbWVyZ2UgX19wcm90b19fIHRvIHByZXZlbnQgcHJvdG90eXBlIHBvbGx1dGlvblxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcEV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xyXG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKHNvdXJjZS5jb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgIGNhc2UgRGF0ZTpcclxuICAgICAgICAgICAgLy8gVHJlYXQgRGF0ZXMgbGlrZSBzY2FsYXJzOyBpZiB0aGUgdGFyZ2V0IGRhdGUgb2JqZWN0IGhhZCBhbnkgY2hpbGRcclxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyAtIHRoZXkgd2lsbCBiZSBsb3N0IVxyXG4gICAgICAgICAgICBjb25zdCBkYXRlVmFsdWUgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlVmFsdWUuZ2V0VGltZSgpKTtcclxuICAgICAgICBjYXNlIE9iamVjdDpcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEFycmF5OlxyXG4gICAgICAgICAgICAvLyBBbHdheXMgY29weSB0aGUgYXJyYXkgc291cmNlIGFuZCBvdmVyd3JpdGUgdGhlIHRhcmdldC5cclxuICAgICAgICAgICAgdGFyZ2V0ID0gW107XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIC8vIE5vdCBhIHBsYWluIE9iamVjdCAtIHRyZWF0IGl0IGFzIGEgc2NhbGFyLlxyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBwcm9wIGluIHNvdXJjZSkge1xyXG4gICAgICAgIC8vIHVzZSBpc1ZhbGlkS2V5IHRvIGd1YXJkIGFnYWluc3QgcHJvdG90eXBlIHBvbGx1dGlvbi4gU2VlIGh0dHBzOi8vc255ay5pby92dWxuL1NOWUstSlMtTE9EQVNILTQ1MDIwMlxyXG4gICAgICAgIGlmICghc291cmNlLmhhc093blByb3BlcnR5KHByb3ApIHx8ICFpc1ZhbGlkS2V5KHByb3ApKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBkZWVwRXh0ZW5kKHRhcmdldFtwcm9wXSwgc291cmNlW3Byb3BdKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcclxuICAgIHJldHVybiBrZXkgIT09ICdfX3Byb3RvX18nO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQb2x5ZmlsbCBmb3IgYGdsb2JhbFRoaXNgIG9iamVjdC5cclxuICogQHJldHVybnMgdGhlIGBnbG9iYWxUaGlzYCBvYmplY3QgZm9yIHRoZSBnaXZlbiBlbnZpcm9ubWVudC5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdC4nKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0c0Zyb21HbG9iYWwgPSAoKSA9PiBnZXRHbG9iYWwoKS5fX0ZJUkVCQVNFX0RFRkFVTFRTX187XHJcbi8qKlxyXG4gKiBBdHRlbXB0IHRvIHJlYWQgZGVmYXVsdHMgZnJvbSBhIEpTT04gc3RyaW5nIHByb3ZpZGVkIHRvXHJcbiAqIHByb2Nlc3MoLillbnYoLilfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb3IgYSBKU09OIGZpbGUgd2hvc2UgcGF0aCBpcyBpblxyXG4gKiBwcm9jZXNzKC4pZW52KC4pX19GSVJFQkFTRV9ERUZBVUxUU19QQVRIX19cclxuICogVGhlIGRvdHMgYXJlIGluIHBhcmVucyBiZWNhdXNlIGNlcnRhaW4gY29tcGlsZXJzIChWaXRlPykgY2Fubm90XHJcbiAqIGhhbmRsZSBzZWVpbmcgdGhhdCB2YXJpYWJsZSBpbiBjb21tZW50cy5cclxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvaXNzdWVzLzY4MzhcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRzRnJvbUVudlZhcmlhYmxlID0gKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgcHJvY2Vzcy5lbnYgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVmYXVsdHNKc29uU3RyaW5nID0gcHJvY2Vzcy5lbnYuX19GSVJFQkFTRV9ERUZBVUxUU19fO1xyXG4gICAgaWYgKGRlZmF1bHRzSnNvblN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRlZmF1bHRzSnNvblN0cmluZyk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGdldERlZmF1bHRzRnJvbUNvb2tpZSA9ICgpID0+IHtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IG1hdGNoO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaCgvX19GSVJFQkFTRV9ERUZBVUxUU19fPShbXjtdKykvKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gU29tZSBlbnZpcm9ubWVudHMgc3VjaCBhcyBBbmd1bGFyIFVuaXZlcnNhbCBTU1IgaGF2ZSBhXHJcbiAgICAgICAgLy8gYGRvY3VtZW50YCBvYmplY3QgYnV0IGVycm9yIG9uIGFjY2Vzc2luZyBgZG9jdW1lbnQuY29va2llYC5cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWNvZGVkID0gbWF0Y2ggJiYgYmFzZTY0RGVjb2RlKG1hdGNoWzFdKTtcclxuICAgIHJldHVybiBkZWNvZGVkICYmIEpTT04ucGFyc2UoZGVjb2RlZCk7XHJcbn07XHJcbi8qKlxyXG4gKiBHZXQgdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuIEl0IGNoZWNrcyBpbiBvcmRlcjpcclxuICogKDEpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBhcyBhIHByb3BlcnR5IG9mIGBnbG9iYWxUaGlzYFxyXG4gKiAoMikgaWYgc3VjaCBhbiBvYmplY3Qgd2FzIHByb3ZpZGVkIG9uIGEgc2hlbGwgZW52aXJvbm1lbnQgdmFyaWFibGVcclxuICogKDMpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBpbiBhIGNvb2tpZVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0cyA9ICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChnZXREZWZhdWx0c0Zyb21HbG9iYWwoKSB8fFxyXG4gICAgICAgICAgICBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSgpIHx8XHJcbiAgICAgICAgICAgIGdldERlZmF1bHRzRnJvbUNvb2tpZSgpKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2F0Y2gtYWxsIGZvciBiZWluZyB1bmFibGUgdG8gZ2V0IF9fRklSRUJBU0VfREVGQVVMVFNfXyBkdWVcclxuICAgICAgICAgKiB0byBhbnkgZW52aXJvbm1lbnQgY2FzZSB3ZSBoYXZlIG5vdCBhY2NvdW50ZWQgZm9yLiBMb2cgdG9cclxuICAgICAgICAgKiBpbmZvIGluc3RlYWQgb2Ygc3dhbGxvd2luZyBzbyB3ZSBjYW4gZmluZCB0aGVzZSB1bmtub3duIGNhc2VzXHJcbiAgICAgICAgICogYW5kIGFkZCBwYXRocyBmb3IgdGhlbSBpZiBuZWVkZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc29sZS5pbmZvKGBVbmFibGUgdG8gZ2V0IF9fRklSRUJBU0VfREVGQVVMVFNfXyBkdWUgdG86ICR7ZX1gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGVtdWxhdG9yIGhvc3Qgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0XHJcbiAqIGZvciB0aGUgZ2l2ZW4gcHJvZHVjdC5cclxuICogQHJldHVybnMgYSBVUkwgaG9zdCBmb3JtYXR0ZWQgbGlrZSBgMTI3LjAuMC4xOjk5OTlgIG9yIGBbOjoxXTo0MDAwYCBpZiBhdmFpbGFibGVcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCA9IChwcm9kdWN0TmFtZSkgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtdWxhdG9ySG9zdHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltwcm9kdWN0TmFtZV07IH07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGVtdWxhdG9yIGhvc3RuYW1lIGFuZCBwb3J0IHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdFxyXG4gKiBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXHJcbiAqIEByZXR1cm5zIGEgcGFpciBvZiBob3N0bmFtZSBhbmQgcG9ydCBsaWtlIGBbXCI6OjFcIiwgNDAwMF1gIGlmIGF2YWlsYWJsZVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQgPSAocHJvZHVjdE5hbWUpID0+IHtcclxuICAgIGNvbnN0IGhvc3QgPSBnZXREZWZhdWx0RW11bGF0b3JIb3N0KHByb2R1Y3ROYW1lKTtcclxuICAgIGlmICghaG9zdCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXBhcmF0b3JJbmRleCA9IGhvc3QubGFzdEluZGV4T2YoJzonKTsgLy8gRmluZGluZyB0aGUgbGFzdCBzaW5jZSBJUHY2IGFkZHIgYWxzbyBoYXMgY29sb25zLlxyXG4gICAgaWYgKHNlcGFyYXRvckluZGV4IDw9IDAgfHwgc2VwYXJhdG9ySW5kZXggKyAxID09PSBob3N0Lmxlbmd0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBob3N0ICR7aG9zdH0gd2l0aCBubyBzZXBhcmF0ZSBob3N0bmFtZSBhbmQgcG9ydCFgKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcclxuICAgIGNvbnN0IHBvcnQgPSBwYXJzZUludChob3N0LnN1YnN0cmluZyhzZXBhcmF0b3JJbmRleCArIDEpLCAxMCk7XHJcbiAgICBpZiAoaG9zdFswXSA9PT0gJ1snKSB7XHJcbiAgICAgICAgLy8gQnJhY2tldC1xdW90ZWQgYFtpcHY2YWRkcl06cG9ydGAgPT4gcmV0dXJuIFwiaXB2NmFkZHJcIiAod2l0aG91dCBicmFja2V0cykuXHJcbiAgICAgICAgcmV0dXJuIFtob3N0LnN1YnN0cmluZygxLCBzZXBhcmF0b3JJbmRleCAtIDEpLCBwb3J0XTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbaG9zdC5zdWJzdHJpbmcoMCwgc2VwYXJhdG9ySW5kZXgpLCBwb3J0XTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgRmlyZWJhc2UgYXBwIGNvbmZpZyBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRBcHBDb25maWcgPSAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25maWc7IH07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGV4cGVyaW1lbnRhbCBzZXR0aW5nIG9uIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0IChwcm9wZXJ0aWVzXHJcbiAqIHByZWZpeGVkIGJ5IFwiX1wiKVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXRFeHBlcmltZW50YWxTZXR0aW5nID0gKG5hbWUpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2BfJHtuYW1lfWBdOyB9O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBEZWZlcnJlZCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnJlamVjdCA9ICgpID0+IHsgfTtcclxuICAgICAgICB0aGlzLnJlc29sdmUgPSAoKSA9PiB7IH07XHJcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3VyIEFQSSBpbnRlcm5hbHMgYXJlIG5vdCBwcm9taXNlaWZpZWQgYW5kIGNhbm5vdCBiZWNhdXNlIG91ciBjYWxsYmFjayBBUElzIGhhdmUgc3VidGxlIGV4cGVjdGF0aW9ucyBhcm91bmRcclxuICAgICAqIGludm9raW5nIHByb21pc2VzIGlubGluZSwgd2hpY2ggUHJvbWlzZXMgYXJlIGZvcmJpZGRlbiB0byBkby4gVGhpcyBtZXRob2QgYWNjZXB0cyBhbiBvcHRpb25hbCBub2RlLXN0eWxlIGNhbGxiYWNrXHJcbiAgICAgKiBhbmQgcmV0dXJucyBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgd2hpY2ggd2lsbCByZXNvbHZlIG9yIHJlamVjdCB0aGUgRGVmZXJyZWQncyBwcm9taXNlLlxyXG4gICAgICovXHJcbiAgICB3cmFwQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gKGVycm9yLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgLy8gQXR0YWNoaW5nIG5vb3AgaGFuZGxlciBqdXN0IGluIGNhc2UgZGV2ZWxvcGVyIHdhc24ndCBleHBlY3RpbmdcclxuICAgICAgICAgICAgICAgIC8vIHByb21pc2VzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2UuY2F0Y2goKCkgPT4geyB9KTtcclxuICAgICAgICAgICAgICAgIC8vIFNvbWUgb2Ygb3VyIGNhbGxiYWNrcyBkb24ndCBleHBlY3QgYSB2YWx1ZSBhbmQgb3VyIG93biB0ZXN0c1xyXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0IHRoYXQgdGhlIHBhcmFtZXRlciBsZW5ndGggaXMgMVxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZU1vY2tVc2VyVG9rZW4odG9rZW4sIHByb2plY3RJZCkge1xyXG4gICAgaWYgKHRva2VuLnVpZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFwidWlkXCIgZmllbGQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBieSBtb2NrVXNlclRva2VuLiBQbGVhc2UgdXNlIFwic3ViXCIgaW5zdGVhZCBmb3IgRmlyZWJhc2UgQXV0aCBVc2VyIElELicpO1xyXG4gICAgfVxyXG4gICAgLy8gVW5zZWN1cmVkIEpXVHMgdXNlIFwibm9uZVwiIGFzIHRoZSBhbGdvcml0aG0uXHJcbiAgICBjb25zdCBoZWFkZXIgPSB7XHJcbiAgICAgICAgYWxnOiAnbm9uZScsXHJcbiAgICAgICAgdHlwZTogJ0pXVCdcclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9qZWN0ID0gcHJvamVjdElkIHx8ICdkZW1vLXByb2plY3QnO1xyXG4gICAgY29uc3QgaWF0ID0gdG9rZW4uaWF0IHx8IDA7XHJcbiAgICBjb25zdCBzdWIgPSB0b2tlbi5zdWIgfHwgdG9rZW4udXNlcl9pZDtcclxuICAgIGlmICghc3ViKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW9ja1VzZXJUb2tlbiBtdXN0IGNvbnRhaW4gJ3N1Yicgb3IgJ3VzZXJfaWQnIGZpZWxkIVwiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBheWxvYWQgPSBPYmplY3QuYXNzaWduKHsgXHJcbiAgICAgICAgLy8gU2V0IGFsbCByZXF1aXJlZCBmaWVsZHMgdG8gZGVjZW50IGRlZmF1bHRzXHJcbiAgICAgICAgaXNzOiBgaHR0cHM6Ly9zZWN1cmV0b2tlbi5nb29nbGUuY29tLyR7cHJvamVjdH1gLCBhdWQ6IHByb2plY3QsIGlhdCwgZXhwOiBpYXQgKyAzNjAwLCBhdXRoX3RpbWU6IGlhdCwgc3ViLCB1c2VyX2lkOiBzdWIsIGZpcmViYXNlOiB7XHJcbiAgICAgICAgICAgIHNpZ25faW5fcHJvdmlkZXI6ICdjdXN0b20nLFxyXG4gICAgICAgICAgICBpZGVudGl0aWVzOiB7fVxyXG4gICAgICAgIH0gfSwgdG9rZW4pO1xyXG4gICAgLy8gVW5zZWN1cmVkIEpXVHMgdXNlIHRoZSBlbXB0eSBzdHJpbmcgYXMgYSBzaWduYXR1cmUuXHJcbiAgICBjb25zdCBzaWduYXR1cmUgPSAnJztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSksXHJcbiAgICAgICAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpLFxyXG4gICAgICAgIHNpZ25hdHVyZVxyXG4gICAgXS5qb2luKCcuJyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgbmF2aWdhdG9yLnVzZXJBZ2VudCBzdHJpbmcgb3IgJycgaWYgaXQncyBub3QgZGVmaW5lZC5cclxuICogQHJldHVybiB1c2VyIGFnZW50IHN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VUEoKSB7XHJcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yWyd1c2VyQWdlbnQnXSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gbmF2aWdhdG9yWyd1c2VyQWdlbnQnXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRGV0ZWN0IENvcmRvdmEgLyBQaG9uZUdhcCAvIElvbmljIGZyYW1ld29ya3Mgb24gYSBtb2JpbGUgZGV2aWNlLlxyXG4gKlxyXG4gKiBEZWxpYmVyYXRlbHkgZG9lcyBub3QgcmVseSBvbiBjaGVja2luZyBgZmlsZTovL2AgVVJMcyAoYXMgdGhpcyBmYWlscyBQaG9uZUdhcFxyXG4gKiBpbiB0aGUgUmlwcGxlIGVtdWxhdG9yKSBub3IgQ29yZG92YSBgb25EZXZpY2VSZWFkeWAsIHdoaWNoIHdvdWxkIG5vcm1hbGx5XHJcbiAqIHdhaXQgZm9yIGEgY2FsbGJhY2suXHJcbiAqL1xyXG5mdW5jdGlvbiBpc01vYmlsZUNvcmRvdmEoKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBTZXR0aW5nIHVwIGFuIGJyb2FkbHkgYXBwbGljYWJsZSBpbmRleCBzaWduYXR1cmUgZm9yIFdpbmRvd1xyXG4gICAgICAgIC8vIGp1c3QgdG8gZGVhbCB3aXRoIHRoaXMgY2FzZSB3b3VsZCBwcm9iYWJseSBiZSBhIGJhZCBpZGVhLlxyXG4gICAgICAgICEhKHdpbmRvd1snY29yZG92YSddIHx8IHdpbmRvd1sncGhvbmVnYXAnXSB8fCB3aW5kb3dbJ1Bob25lR2FwJ10pICYmXHJcbiAgICAgICAgL2lvc3xpcGhvbmV8aXBvZHxpcGFkfGFuZHJvaWR8YmxhY2tiZXJyeXxpZW1vYmlsZS9pLnRlc3QoZ2V0VUEoKSkpO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlY3QgTm9kZS5qcy5cclxuICpcclxuICogQHJldHVybiB0cnVlIGlmIE5vZGUuanMgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQgb3Igc3BlY2lmaWVkLlxyXG4gKi9cclxuLy8gTm9kZSBkZXRlY3Rpb24gbG9naWMgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2lsaWFrYW4vZGV0ZWN0LW5vZGUvXHJcbmZ1bmN0aW9uIGlzTm9kZSgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IGZvcmNlRW52aXJvbm1lbnQgPSAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yY2VFbnZpcm9ubWVudDtcclxuICAgIGlmIChmb3JjZUVudmlyb25tZW50ID09PSAnbm9kZScpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZvcmNlRW52aXJvbm1lbnQgPT09ICdicm93c2VyJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCBCcm93c2VyIEVudmlyb25tZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZjtcclxufVxyXG5mdW5jdGlvbiBpc0Jyb3dzZXJFeHRlbnNpb24oKSB7XHJcbiAgICBjb25zdCBydW50aW1lID0gdHlwZW9mIGNocm9tZSA9PT0gJ29iamVjdCdcclxuICAgICAgICA/IGNocm9tZS5ydW50aW1lXHJcbiAgICAgICAgOiB0eXBlb2YgYnJvd3NlciA9PT0gJ29iamVjdCdcclxuICAgICAgICAgICAgPyBicm93c2VyLnJ1bnRpbWVcclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gdHlwZW9mIHJ1bnRpbWUgPT09ICdvYmplY3QnICYmIHJ1bnRpbWUuaWQgIT09IHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICogRGV0ZWN0IFJlYWN0IE5hdGl2ZS5cclxuICpcclxuICogQHJldHVybiB0cnVlIGlmIFJlYWN0TmF0aXZlIGVudmlyb25tZW50IGlzIGRldGVjdGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSgpIHtcclxuICAgIHJldHVybiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgJiYgbmF2aWdhdG9yWydwcm9kdWN0J10gPT09ICdSZWFjdE5hdGl2ZScpO1xyXG59XHJcbi8qKiBEZXRlY3RzIEVsZWN0cm9uIGFwcHMuICovXHJcbmZ1bmN0aW9uIGlzRWxlY3Ryb24oKSB7XHJcbiAgICByZXR1cm4gZ2V0VUEoKS5pbmRleE9mKCdFbGVjdHJvbi8nKSA+PSAwO1xyXG59XHJcbi8qKiBEZXRlY3RzIEludGVybmV0IEV4cGxvcmVyLiAqL1xyXG5mdW5jdGlvbiBpc0lFKCkge1xyXG4gICAgY29uc3QgdWEgPSBnZXRVQSgpO1xyXG4gICAgcmV0dXJuIHVhLmluZGV4T2YoJ01TSUUgJykgPj0gMCB8fCB1YS5pbmRleE9mKCdUcmlkZW50LycpID49IDA7XHJcbn1cclxuLyoqIERldGVjdHMgVW5pdmVyc2FsIFdpbmRvd3MgUGxhdGZvcm0gYXBwcy4gKi9cclxuZnVuY3Rpb24gaXNVV1AoKSB7XHJcbiAgICByZXR1cm4gZ2V0VUEoKS5pbmRleE9mKCdNU0FwcEhvc3QvJykgPj0gMDtcclxufVxyXG4vKipcclxuICogRGV0ZWN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgU0RLIGJ1aWxkIGlzIHRoZSBOb2RlIHZlcnNpb24uXHJcbiAqXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpdCdzIHRoZSBOb2RlIFNESyBidWlsZC5cclxuICovXHJcbmZ1bmN0aW9uIGlzTm9kZVNkaygpIHtcclxuICAgIHJldHVybiBDT05TVEFOVFMuTk9ERV9DTElFTlQgPT09IHRydWUgfHwgQ09OU1RBTlRTLk5PREVfQURNSU4gPT09IHRydWU7XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgcnVubmluZyBpbiBTYWZhcmkuICovXHJcbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xyXG4gICAgcmV0dXJuICghaXNOb2RlKCkgJiZcclxuICAgICAgICAhIW5hdmlnYXRvci51c2VyQWdlbnQgJiZcclxuICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdTYWZhcmknKSAmJlxyXG4gICAgICAgICFuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdDaHJvbWUnKSk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0luZGV4ZWREQkF2YWlsYWJsZSgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbmRleGVkREIgPT09ICdvYmplY3QnO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIHZhbGlkYXRlcyBicm93c2VyL3N3IGNvbnRleHQgZm9yIGluZGV4ZWREQiBieSBvcGVuaW5nIGEgZHVtbXkgaW5kZXhlZERCIGRhdGFiYXNlIGFuZCByZWplY3RcclxuICogaWYgZXJyb3JzIG9jY3VyIGR1cmluZyB0aGUgZGF0YWJhc2Ugb3BlbiBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIEB0aHJvd3MgZXhjZXB0aW9uIGlmIGN1cnJlbnQgYnJvd3Nlci9zdyBjb250ZXh0IGNhbid0IHJ1biBpZGIub3BlbiAoZXg6IFNhZmFyaSBpZnJhbWUsIEZpcmVmb3hcclxuICogcHJpdmF0ZSBicm93c2luZylcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBwcmVFeGlzdCA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IERCX0NIRUNLX05BTUUgPSAndmFsaWRhdGUtYnJvd3Nlci1jb250ZXh0LWZvci1pbmRleGVkZGItYW5hbHl0aWNzLW1vZHVsZSc7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzZWxmLmluZGV4ZWREQi5vcGVuKERCX0NIRUNLX05BTUUpO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzdWx0LmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgZGF0YWJhc2Ugb25seSB3aGVuIGl0IGRvZXNuJ3QgcHJlLWV4aXN0XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByZUV4aXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoREJfQ0hFQ0tfTkFNRSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHByZUV4aXN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHJlamVjdCgoKF9hID0gcmVxdWVzdC5lcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lc3NhZ2UpIHx8ICcnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyB3aGV0aGVyIGNvb2tpZSBpcyBlbmFibGVkIHdpdGhpbiBjdXJyZW50IGJyb3dzZXJcclxuICogQHJldHVybiB0cnVlIGlmIGNvb2tpZSBpcyBlbmFibGVkIHdpdGhpbiBjdXJyZW50IGJyb3dzZXJcclxuICovXHJcbmZ1bmN0aW9uIGFyZUNvb2tpZXNFbmFibGVkKCkge1xyXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICFuYXZpZ2F0b3IuY29va2llRW5hYmxlZCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IFN0YW5kYXJkaXplZCBGaXJlYmFzZSBFcnJvci5cclxuICpcclxuICogVXNhZ2U6XHJcbiAqXHJcbiAqICAgLy8gVHlwZXNjcmlwdCBzdHJpbmcgbGl0ZXJhbHMgZm9yIHR5cGUtc2FmZSBjb2Rlc1xyXG4gKiAgIHR5cGUgRXJyID1cclxuICogICAgICd1bmtub3duJyB8XHJcbiAqICAgICAnb2JqZWN0LW5vdC1mb3VuZCdcclxuICogICAgIDtcclxuICpcclxuICogICAvLyBDbG9zdXJlIGVudW0gZm9yIHR5cGUtc2FmZSBlcnJvciBjb2Rlc1xyXG4gKiAgIC8vIGF0LWVudW0ge3N0cmluZ31cclxuICogICB2YXIgRXJyID0ge1xyXG4gKiAgICAgVU5LTk9XTjogJ3Vua25vd24nLFxyXG4gKiAgICAgT0JKRUNUX05PVF9GT1VORDogJ29iamVjdC1ub3QtZm91bmQnLFxyXG4gKiAgIH1cclxuICpcclxuICogICBsZXQgZXJyb3JzOiBNYXA8RXJyLCBzdHJpbmc+ID0ge1xyXG4gKiAgICAgJ2dlbmVyaWMtZXJyb3InOiBcIlVua25vd24gZXJyb3JcIixcclxuICogICAgICdmaWxlLW5vdC1mb3VuZCc6IFwiQ291bGQgbm90IGZpbmQgZmlsZTogeyRmaWxlfVwiLFxyXG4gKiAgIH07XHJcbiAqXHJcbiAqICAgLy8gVHlwZS1zYWZlIGZ1bmN0aW9uIC0gbXVzdCBwYXNzIGEgdmFsaWQgZXJyb3IgY29kZSBhcyBwYXJhbS5cclxuICogICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JGYWN0b3J5PEVycj4oJ3NlcnZpY2UnLCAnU2VydmljZScsIGVycm9ycyk7XHJcbiAqXHJcbiAqICAgLi4uXHJcbiAqICAgdGhyb3cgZXJyb3IuY3JlYXRlKEVyci5HRU5FUklDKTtcclxuICogICAuLi5cclxuICogICB0aHJvdyBlcnJvci5jcmVhdGUoRXJyLkZJTEVfTk9UX0ZPVU5ELCB7J2ZpbGUnOiBmaWxlTmFtZX0pO1xyXG4gKiAgIC4uLlxyXG4gKiAgIC8vIFNlcnZpY2U6IENvdWxkIG5vdCBmaWxlIGZpbGU6IGZvby50eHQgKHNlcnZpY2UvZmlsZS1ub3QtZm91bmQpLlxyXG4gKlxyXG4gKiAgIGNhdGNoIChlKSB7XHJcbiAqICAgICBhc3NlcnQoZS5tZXNzYWdlID09PSBcIkNvdWxkIG5vdCBmaW5kIGZpbGU6IGZvby50eHQuXCIpO1xyXG4gKiAgICAgaWYgKChlIGFzIEZpcmViYXNlRXJyb3IpPy5jb2RlID09PSAnc2VydmljZS9maWxlLW5vdC1mb3VuZCcpIHtcclxuICogICAgICAgY29uc29sZS5sb2coXCJDb3VsZCBub3QgcmVhZCBmaWxlOiBcIiArIGVbJ2ZpbGUnXSk7XHJcbiAqICAgICB9XHJcbiAqICAgfVxyXG4gKi9cclxuY29uc3QgRVJST1JfTkFNRSA9ICdGaXJlYmFzZUVycm9yJztcclxuLy8gQmFzZWQgb24gY29kZSBmcm9tOlxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNDdXN0b21fRXJyb3JfVHlwZXNcclxuY2xhc3MgRmlyZWJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSBlcnJvciBjb2RlIGZvciB0aGlzIGVycm9yLiAqL1xyXG4gICAgY29kZSwgbWVzc2FnZSwgXHJcbiAgICAvKiogQ3VzdG9tIGRhdGEgZm9yIHRoaXMgZXJyb3IuICovXHJcbiAgICBjdXN0b21EYXRhKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICB0aGlzLmN1c3RvbURhdGEgPSBjdXN0b21EYXRhO1xyXG4gICAgICAgIC8qKiBUaGUgY3VzdG9tIG5hbWUgZm9yIGFsbCBGaXJlYmFzZUVycm9ycy4gKi9cclxuICAgICAgICB0aGlzLm5hbWUgPSBFUlJPUl9OQU1FO1xyXG4gICAgICAgIC8vIEZpeCBGb3IgRVM1XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0LXdpa2kvYmxvYi9tYXN0ZXIvQnJlYWtpbmctQ2hhbmdlcy5tZCNleHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC1tYXktbm8tbG9uZ2VyLXdvcmtcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgRmlyZWJhc2VFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgICAgIC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgZm9yIHdoZXJlIG91ciBlcnJvciB3YXMgdGhyb3duLlxyXG4gICAgICAgIC8vIE9ubHkgYXZhaWxhYmxlIG9uIFY4LlxyXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xyXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBFcnJvckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIEVycm9yRmFjdG9yeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlLCBzZXJ2aWNlTmFtZSwgZXJyb3JzKSB7XHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcclxuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XHJcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XHJcbiAgICB9XHJcbiAgICBjcmVhdGUoY29kZSwgLi4uZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGN1c3RvbURhdGEgPSBkYXRhWzBdIHx8IHt9O1xyXG4gICAgICAgIGNvbnN0IGZ1bGxDb2RlID0gYCR7dGhpcy5zZXJ2aWNlfS8ke2NvZGV9YDtcclxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuZXJyb3JzW2NvZGVdO1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0ZW1wbGF0ZSA/IHJlcGxhY2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgY3VzdG9tRGF0YSkgOiAnRXJyb3InO1xyXG4gICAgICAgIC8vIFNlcnZpY2UgTmFtZTogRXJyb3IgbWVzc2FnZSAoc2VydmljZS9jb2RlKS5cclxuICAgICAgICBjb25zdCBmdWxsTWVzc2FnZSA9IGAke3RoaXMuc2VydmljZU5hbWV9OiAke21lc3NhZ2V9ICgke2Z1bGxDb2RlfSkuYDtcclxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBGaXJlYmFzZUVycm9yKGZ1bGxDb2RlLCBmdWxsTWVzc2FnZSwgY3VzdG9tRGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcGxhY2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgZGF0YSkge1xyXG4gICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoUEFUVEVSTiwgKF8sIGtleSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gU3RyaW5nKHZhbHVlKSA6IGA8JHtrZXl9Pz5gO1xyXG4gICAgfSk7XHJcbn1cclxuY29uc3QgUEFUVEVSTiA9IC9cXHtcXCQoW159XSspfS9nO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRXZhbHVhdGVzIGEgSlNPTiBzdHJpbmcgaW50byBhIGphdmFzY3JpcHQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGNvbnRhaW5pbmcgSlNPTi5cclxuICogQHJldHVybiB7Kn0gVGhlIGphdmFzY3JpcHQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIEpTT04uXHJcbiAqL1xyXG5mdW5jdGlvbiBqc29uRXZhbChzdHIpIHtcclxuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cik7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgSlNPTiByZXByZXNlbnRpbmcgYSBqYXZhc2NyaXB0IG9iamVjdC5cclxuICogQHBhcmFtIHsqfSBkYXRhIEphdmFzY3JpcHQgb2JqZWN0IHRvIGJlIHN0cmluZ2lmaWVkLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBKU09OIGNvbnRlbnRzIG9mIHRoZSBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpbmdpZnkoZGF0YSkge1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gaW50byBjb25zdGl0dWVudCBwYXJ0cy5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiB3aXRoIGludmFsaWQgLyBpbmNvbXBsZXRlIGNsYWltcyBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGRlY29kZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgbGV0IGhlYWRlciA9IHt9LCBjbGFpbXMgPSB7fSwgZGF0YSA9IHt9LCBzaWduYXR1cmUgPSAnJztcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdCgnLicpO1xyXG4gICAgICAgIGhlYWRlciA9IGpzb25FdmFsKGJhc2U2NERlY29kZShwYXJ0c1swXSkgfHwgJycpO1xyXG4gICAgICAgIGNsYWltcyA9IGpzb25FdmFsKGJhc2U2NERlY29kZShwYXJ0c1sxXSkgfHwgJycpO1xyXG4gICAgICAgIHNpZ25hdHVyZSA9IHBhcnRzWzJdO1xyXG4gICAgICAgIGRhdGEgPSBjbGFpbXNbJ2QnXSB8fCB7fTtcclxuICAgICAgICBkZWxldGUgY2xhaW1zWydkJ107XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhlYWRlcixcclxuICAgICAgICBjbGFpbXMsXHJcbiAgICAgICAgZGF0YSxcclxuICAgICAgICBzaWduYXR1cmVcclxuICAgIH07XHJcbn07XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIGNoZWNrcyB0aGUgdmFsaWRpdHkgb2YgaXRzIHRpbWUtYmFzZWQgY2xhaW1zLiBXaWxsIHJldHVybiB0cnVlIGlmIHRoZVxyXG4gKiB0b2tlbiBpcyB3aXRoaW4gdGhlIHRpbWUgd2luZG93IGF1dGhvcml6ZWQgYnkgdGhlICduYmYnIChub3QtYmVmb3JlKSBhbmQgJ2lhdCcgKGlzc3VlZC1hdCkgY2xhaW1zLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBpc1ZhbGlkVGltZXN0YW1wID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcclxuICAgIGNvbnN0IG5vdyA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcclxuICAgIGxldCB2YWxpZFNpbmNlID0gMCwgdmFsaWRVbnRpbCA9IDA7XHJcbiAgICBpZiAodHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCduYmYnKSkge1xyXG4gICAgICAgICAgICB2YWxpZFNpbmNlID0gY2xhaW1zWyduYmYnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKSkge1xyXG4gICAgICAgICAgICB2YWxpZFNpbmNlID0gY2xhaW1zWydpYXQnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnZXhwJykpIHtcclxuICAgICAgICAgICAgdmFsaWRVbnRpbCA9IGNsYWltc1snZXhwJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0b2tlbiB3aWxsIGV4cGlyZSBhZnRlciAyNGggYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICB2YWxpZFVudGlsID0gdmFsaWRTaW5jZSArIDg2NDAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAoISFub3cgJiZcclxuICAgICAgICAhIXZhbGlkU2luY2UgJiZcclxuICAgICAgICAhIXZhbGlkVW50aWwgJiZcclxuICAgICAgICBub3cgPj0gdmFsaWRTaW5jZSAmJlxyXG4gICAgICAgIG5vdyA8PSB2YWxpZFVudGlsKTtcclxufTtcclxuLyoqXHJcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgcmV0dXJucyBpdHMgaXNzdWVkIGF0IHRpbWUgaWYgdmFsaWQsIG51bGwgb3RoZXJ3aXNlLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIG51bGwgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBpc3N1ZWRBdFRpbWUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGNvbnN0IGNsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xyXG4gICAgaWYgKHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcclxuICAgICAgICByZXR1cm4gY2xhaW1zWydpYXQnXTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG4vKipcclxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyBmb3JtYXQuIEV4cGVjdHMgYSB2YWxpZCBpc3N1ZWQtYXQgdGltZS5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgaXNWYWxpZEZvcm1hdCA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZSh0b2tlbiksIGNsYWltcyA9IGRlY29kZWQuY2xhaW1zO1xyXG4gICAgcmV0dXJuICEhY2xhaW1zICYmIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0Jyk7XHJcbn07XHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byBwZWVyIGludG8gYW4gYXV0aCB0b2tlbiBhbmQgZGV0ZXJtaW5lIGlmIGl0J3MgYW4gYWRtaW4gYXV0aCB0b2tlbiBieSBsb29raW5nIGF0IHRoZSBjbGFpbXMgcG9ydGlvbi5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgaXNBZG1pbiA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XHJcbiAgICByZXR1cm4gdHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zWydhZG1pbiddID09PSB0cnVlO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb250YWlucyhvYmosIGtleSkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XHJcbn1cclxuZnVuY3Rpb24gc2FmZUdldChvYmosIGtleSkge1xyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICByZXR1cm4gb2JqW2tleV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gbWFwKG9iaiwgZm4sIGNvbnRleHRPYmopIHtcclxuICAgIGNvbnN0IHJlcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICAgICAgcmVzW2tleV0gPSBmbi5jYWxsKGNvbnRleHRPYmosIG9ialtrZXldLCBrZXksIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vKipcclxuICogRGVlcCBlcXVhbCB0d28gb2JqZWN0cy4gU3VwcG9ydCBBcnJheXMgYW5kIE9iamVjdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xyXG4gICAgaWYgKGEgPT09IGIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XHJcbiAgICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xyXG4gICAgZm9yIChjb25zdCBrIG9mIGFLZXlzKSB7XHJcbiAgICAgICAgaWYgKCFiS2V5cy5pbmNsdWRlcyhrKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFQcm9wID0gYVtrXTtcclxuICAgICAgICBjb25zdCBiUHJvcCA9IGJba107XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KGFQcm9wKSAmJiBpc09iamVjdChiUHJvcCkpIHtcclxuICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVByb3AsIGJQcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFQcm9wICE9PSBiUHJvcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrIG9mIGJLZXlzKSB7XHJcbiAgICAgICAgaWYgKCFhS2V5cy5pbmNsdWRlcyhrKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gaXNPYmplY3QodGhpbmcpIHtcclxuICAgIHJldHVybiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZWplY3RzIGlmIHRoZSBnaXZlbiBwcm9taXNlIGRvZXNuJ3QgcmVzb2x2ZSBpbiB0aW1lSW5NUyBtaWxsaXNlY29uZHMuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gcHJvbWlzZVdpdGhUaW1lb3V0KHByb21pc2UsIHRpbWVJbk1TID0gMjAwMCkge1xyXG4gICAgY29uc3QgZGVmZXJyZWRQcm9taXNlID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IGRlZmVycmVkUHJvbWlzZS5yZWplY3QoJ3RpbWVvdXQhJyksIHRpbWVJbk1TKTtcclxuICAgIHByb21pc2UudGhlbihkZWZlcnJlZFByb21pc2UucmVzb2x2ZSwgZGVmZXJyZWRQcm9taXNlLnJlamVjdCk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWRQcm9taXNlLnByb21pc2U7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYSBxdWVyeXN0cmluZy1mb3JtYXR0ZWQgc3RyaW5nIChlLmcuICZhcmc9dmFsJmFyZzI9dmFsMikgZnJvbSBhXHJcbiAqIHBhcmFtcyBvYmplY3QgKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXHJcbiAqIE5vdGU6IFlvdSBtdXN0IHByZXBlbmQgaXQgd2l0aCA/IHdoZW4gYWRkaW5nIGl0IHRvIGEgVVJMLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnlzdHJpbmdQYXJhbXMpIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnlzdHJpbmdQYXJhbXMpKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goYXJyYXlWYWwgPT4ge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJyYXlWYWwpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXJhbXMubGVuZ3RoID8gJyYnICsgcGFyYW1zLmpvaW4oJyYnKSA6ICcnO1xyXG59XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgcXVlcnlzdHJpbmcgKGUuZy4gP2FyZz12YWwmYXJnMj12YWwyKSBpbnRvIGEgcGFyYW1zIG9iamVjdFxyXG4gKiAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nRGVjb2RlKHF1ZXJ5c3RyaW5nKSB7XHJcbiAgICBjb25zdCBvYmogPSB7fTtcclxuICAgIGNvbnN0IHRva2VucyA9IHF1ZXJ5c3RyaW5nLnJlcGxhY2UoL15cXD8vLCAnJykuc3BsaXQoJyYnKTtcclxuICAgIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHtcclxuICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gdG9rZW4uc3BsaXQoJz0nKTtcclxuICAgICAgICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChrZXkpXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gb2JqO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0IHRoZSBxdWVyeSBzdHJpbmcgcGFydCBvZiBhIFVSTCwgaW5jbHVkaW5nIHRoZSBsZWFkaW5nIHF1ZXN0aW9uIG1hcmsgKGlmIHByZXNlbnQpLlxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdFF1ZXJ5c3RyaW5nKHVybCkge1xyXG4gICAgY29uc3QgcXVlcnlTdGFydCA9IHVybC5pbmRleE9mKCc/Jyk7XHJcbiAgICBpZiAoIXF1ZXJ5U3RhcnQpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmcmFnbWVudFN0YXJ0ID0gdXJsLmluZGV4T2YoJyMnLCBxdWVyeVN0YXJ0KTtcclxuICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKHF1ZXJ5U3RhcnQsIGZyYWdtZW50U3RhcnQgPiAwID8gZnJhZ21lbnRTdGFydCA6IHVuZGVmaW5lZCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgU0hBLTEgY3J5cHRvZ3JhcGhpYyBoYXNoLlxyXG4gKiBWYXJpYWJsZSBuYW1lcyBmb2xsb3cgdGhlIG5vdGF0aW9uIGluIEZJUFMgUFVCIDE4MC0zOlxyXG4gKiBodHRwOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZmlwcy9maXBzMTgwLTMvZmlwczE4MC0zX2ZpbmFsLnBkZi5cclxuICpcclxuICogVXNhZ2U6XHJcbiAqICAgdmFyIHNoYTEgPSBuZXcgc2hhMSgpO1xyXG4gKiAgIHNoYTEudXBkYXRlKGJ5dGVzKTtcclxuICogICB2YXIgaGFzaCA9IHNoYTEuZGlnZXN0KCk7XHJcbiAqXHJcbiAqIFBlcmZvcm1hbmNlOlxyXG4gKiAgIENocm9tZSAyMzogICB+NDAwIE1iaXQvc1xyXG4gKiAgIEZpcmVmb3ggMTY6ICB+MjUwIE1iaXQvc1xyXG4gKlxyXG4gKi9cclxuLyoqXHJcbiAqIFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaCBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogVGhlIHByb3BlcnRpZXMgZGVjbGFyZWQgaGVyZSBhcmUgZGlzY3Vzc2VkIGluIHRoZSBhYm92ZSBhbGdvcml0aG0gZG9jdW1lbnQuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZmluYWxcclxuICogQHN0cnVjdFxyXG4gKi9cclxuY2xhc3MgU2hhMSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIb2xkcyB0aGUgcHJldmlvdXMgdmFsdWVzIG9mIGFjY3VtdWxhdGVkIHZhcmlhYmxlcyBhLWUgaW4gdGhlIGNvbXByZXNzX1xyXG4gICAgICAgICAqIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jaGFpbl8gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGJ1ZmZlciBob2xkaW5nIHRoZSBwYXJ0aWFsbHkgY29tcHV0ZWQgaGFzaCByZXN1bHQuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJ1Zl8gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBhcnJheSBvZiA4MCBieXRlcywgZWFjaCBhIHBhcnQgb2YgdGhlIG1lc3NhZ2UgdG8gYmUgaGFzaGVkLiAgUmVmZXJyZWQgdG9cclxuICAgICAgICAgKiBhcyB0aGUgbWVzc2FnZSBzY2hlZHVsZSBpbiB0aGUgZG9jcy5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuV18gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb250YWlucyBkYXRhIG5lZWRlZCB0byBwYWQgbWVzc2FnZXMgbGVzcyB0aGFuIDY0IGJ5dGVzLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYWRfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmluYnVmXyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRvdGFsXyA9IDA7XHJcbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSA1MTIgLyA4O1xyXG4gICAgICAgIHRoaXMucGFkX1swXSA9IDEyODtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuYmxvY2tTaXplOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5wYWRfW2ldID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAweDY3NDUyMzAxO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzFdID0gMHhlZmNkYWI4OTtcclxuICAgICAgICB0aGlzLmNoYWluX1syXSA9IDB4OThiYWRjZmU7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAweDEwMzI1NDc2O1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzRdID0gMHhjM2QyZTFmMDtcclxuICAgICAgICB0aGlzLmluYnVmXyA9IDA7XHJcbiAgICAgICAgdGhpcy50b3RhbF8gPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBjb21wcmVzcyBoZWxwZXIgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gYnVmIEJsb2NrIHRvIGNvbXByZXNzLlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBPZmZzZXQgb2YgdGhlIGJsb2NrIGluIHRoZSBidWZmZXIuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjb21wcmVzc18oYnVmLCBvZmZzZXQpIHtcclxuICAgICAgICBpZiAoIW9mZnNldCkge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBXID0gdGhpcy5XXztcclxuICAgICAgICAvLyBnZXQgMTYgYmlnIGVuZGlhbiB3b3Jkc1xyXG4gICAgICAgIGlmICh0eXBlb2YgYnVmID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8odXNlcik6IFtidWcgODE0MDEyMl0gUmVjZW50IHZlcnNpb25zIG9mIFNhZmFyaSBmb3IgTWFjIE9TIGFuZCBpT1NcclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgYSBidWcgdGhhdCB0dXJucyB0aGUgcG9zdC1pbmNyZW1lbnQgKysgb3BlcmF0b3IgaW50byBwcmUtaW5jcmVtZW50XHJcbiAgICAgICAgICAgICAgICAvLyBkdXJpbmcgSklUIGNvbXBpbGF0aW9uLiAgV2UgaGF2ZSBjb2RlIHRoYXQgZGVwZW5kcyBoZWF2aWx5IG9uIFNIQS0xIGZvclxyXG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdG5lc3MgYW5kIHdoaWNoIGlzIGFmZmVjdGVkIGJ5IHRoaXMgYnVnLCBzbyBJJ3ZlIHJlbW92ZWQgYWxsIHVzZXNcclxuICAgICAgICAgICAgICAgIC8vIG9mIHBvc3QtaW5jcmVtZW50ICsrIGluIHdoaWNoIHRoZSByZXN1bHQgdmFsdWUgaXMgdXNlZC4gIFdlIGNhbiByZXZlcnRcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2hhbmdlIG9uY2UgdGhlIFNhZmFyaSBidWdcclxuICAgICAgICAgICAgICAgIC8vIChodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTA5MDM2KSBoYXMgYmVlbiBmaXhlZCBhbmRcclxuICAgICAgICAgICAgICAgIC8vIG1vc3QgY2xpZW50cyBoYXZlIGJlZW4gdXBkYXRlZC5cclxuICAgICAgICAgICAgICAgIFdbaV0gPVxyXG4gICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQpIDw8IDI0KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQgKyAxKSA8PCAxNikgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWYuY2hhckNvZGVBdChvZmZzZXQgKyAzKTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIFdbaV0gPVxyXG4gICAgICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0XSA8PCAyNCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDFdIDw8IDE2KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0ICsgMl0gPDwgOCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZbb2Zmc2V0ICsgM107XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBleHBhbmQgdG8gODAgd29yZHNcclxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xyXG4gICAgICAgICAgICBXW2ldID0gKCh0IDw8IDEpIHwgKHQgPj4+IDMxKSkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYSA9IHRoaXMuY2hhaW5fWzBdO1xyXG4gICAgICAgIGxldCBiID0gdGhpcy5jaGFpbl9bMV07XHJcbiAgICAgICAgbGV0IGMgPSB0aGlzLmNoYWluX1syXTtcclxuICAgICAgICBsZXQgZCA9IHRoaXMuY2hhaW5fWzNdO1xyXG4gICAgICAgIGxldCBlID0gdGhpcy5jaGFpbl9bNF07XHJcbiAgICAgICAgbGV0IGYsIGs7XHJcbiAgICAgICAgLy8gVE9ETyh1c2VyKTogVHJ5IHRvIHVucm9sbCB0aGlzIGxvb3AgdG8gc3BlZWQgdXAgdGhlIGNvbXB1dGF0aW9uLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA8IDQwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDIwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDVhODI3OTk5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGIgXiBjIF4gZDtcclxuICAgICAgICAgICAgICAgICAgICBrID0gMHg2ZWQ5ZWJhMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgNjApIHtcclxuICAgICAgICAgICAgICAgICAgICBmID0gKGIgJiBjKSB8IChkICYgKGIgfCBjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4OGYxYmJjZGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmID0gYiBeIGMgXiBkO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSAweGNhNjJjMWQ2O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSAoKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIGsgKyBXW2ldKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgICAgIGUgPSBkO1xyXG4gICAgICAgICAgICBkID0gYztcclxuICAgICAgICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICAgICAgYiA9IGE7XHJcbiAgICAgICAgICAgIGEgPSB0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoYWluX1swXSA9ICh0aGlzLmNoYWluX1swXSArIGEpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1sxXSA9ICh0aGlzLmNoYWluX1sxXSArIGIpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1syXSA9ICh0aGlzLmNoYWluX1syXSArIGMpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1szXSA9ICh0aGlzLmNoYWluX1szXSArIGQpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1s0XSA9ICh0aGlzLmNoYWluX1s0XSArIGUpICYgMHhmZmZmZmZmZjtcclxuICAgIH1cclxuICAgIHVwZGF0ZShieXRlcywgbGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gVE9ETyhqb2hubGVueik6IHRpZ2h0ZW4gdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSBhbmQgcmVtb3ZlIHRoaXMgY2hlY2tcclxuICAgICAgICBpZiAoYnl0ZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZW5ndGggPSBieXRlcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlbmd0aE1pbnVzQmxvY2sgPSBsZW5ndGggLSB0aGlzLmJsb2NrU2l6ZTtcclxuICAgICAgICBsZXQgbiA9IDA7XHJcbiAgICAgICAgLy8gVXNpbmcgbG9jYWwgaW5zdGVhZCBvZiBtZW1iZXIgdmFyaWFibGVzIGdpdmVzIH41JSBzcGVlZHVwIG9uIEZpcmVmb3ggMTYuXHJcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5idWZfO1xyXG4gICAgICAgIGxldCBpbmJ1ZiA9IHRoaXMuaW5idWZfO1xyXG4gICAgICAgIC8vIFRoZSBvdXRlciB3aGlsZSBsb29wIHNob3VsZCBleGVjdXRlIGF0IG1vc3QgdHdpY2UuXHJcbiAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBoYXZlIG5vIGRhdGEgaW4gdGhlIGJsb2NrIHRvIHRvcCB1cCwgd2UgY2FuIGRpcmVjdGx5IHByb2Nlc3MgdGhlXHJcbiAgICAgICAgICAgIC8vIGlucHV0IGJ1ZmZlciAoYXNzdW1pbmcgaXQgY29udGFpbnMgc3VmZmljaWVudCBkYXRhKS4gVGhpcyBnaXZlcyB+MjUlXHJcbiAgICAgICAgICAgIC8vIHNwZWVkdXAgb24gQ2hyb21lIDIzIGFuZCB+MTUlIHNwZWVkdXAgb24gRmlyZWZveCAxNiwgYnV0IHJlcXVpcmVzIHRoYXRcclxuICAgICAgICAgICAgLy8gdGhlIGRhdGEgaXMgcHJvdmlkZWQgaW4gbGFyZ2UgY2h1bmtzIChvciBpbiBtdWx0aXBsZXMgb2YgNjQgYnl0ZXMpLlxyXG4gICAgICAgICAgICBpZiAoaW5idWYgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuIDw9IGxlbmd0aE1pbnVzQmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhieXRlcywgbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbiArPSB0aGlzLmJsb2NrU2l6ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBidWZbaW5idWZdID0gYnl0ZXMuY2hhckNvZGVBdChuKTtcclxuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xyXG4gICAgICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5idWYgPT09IHRoaXMuYmxvY2tTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZltpbmJ1Zl0gPSBieXRlc1tuXTtcclxuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xyXG4gICAgICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5idWYgPT09IHRoaXMuYmxvY2tTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSBpbmJ1ZjtcclxuICAgICAgICB0aGlzLnRvdGFsXyArPSBsZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKiogQG92ZXJyaWRlICovXHJcbiAgICBkaWdlc3QoKSB7XHJcbiAgICAgICAgY29uc3QgZGlnZXN0ID0gW107XHJcbiAgICAgICAgbGV0IHRvdGFsQml0cyA9IHRoaXMudG90YWxfICogODtcclxuICAgICAgICAvLyBBZGQgcGFkIDB4ODAgMHgwMCouXHJcbiAgICAgICAgaWYgKHRoaXMuaW5idWZfIDwgNTYpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy5wYWRfLCA1NiAtIHRoaXMuaW5idWZfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgdGhpcy5ibG9ja1NpemUgLSAodGhpcy5pbmJ1Zl8gLSA1NikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgIyBiaXRzLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmJsb2NrU2l6ZSAtIDE7IGkgPj0gNTY7IGktLSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1Zl9baV0gPSB0b3RhbEJpdHMgJiAyNTU7XHJcbiAgICAgICAgICAgIHRvdGFsQml0cyAvPSAyNTY7IC8vIERvbid0IHVzZSBiaXQtc2hpZnRpbmcgaGVyZSFcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21wcmVzc18odGhpcy5idWZfKTtcclxuICAgICAgICBsZXQgbiA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xyXG4gICAgICAgICAgICAgICAgZGlnZXN0W25dID0gKHRoaXMuY2hhaW5fW2ldID4+IGopICYgMjU1O1xyXG4gICAgICAgICAgICAgICAgKytuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaWdlc3Q7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEhlbHBlciB0byBtYWtlIGEgU3Vic2NyaWJlIGZ1bmN0aW9uIChqdXN0IGxpa2UgUHJvbWlzZSBoZWxwcyBtYWtlIGFcclxuICogVGhlbmFibGUpLlxyXG4gKlxyXG4gKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcclxuICogICAgIGFzIGEgcHJveHkuXHJcbiAqIEBwYXJhbSBvbk5vT2JzZXJ2ZXJzIENhbGxiYWNrIHdoZW4gY291bnQgb2YgT2JzZXJ2ZXJzIGdvZXMgdG8gemVyby5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmliZShleGVjdXRvciwgb25Ob09ic2VydmVycykge1xyXG4gICAgY29uc3QgcHJveHkgPSBuZXcgT2JzZXJ2ZXJQcm94eShleGVjdXRvciwgb25Ob09ic2VydmVycyk7XHJcbiAgICByZXR1cm4gcHJveHkuc3Vic2NyaWJlLmJpbmQocHJveHkpO1xyXG59XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnQgZmFuLW91dCBmb3IgYW55IG51bWJlciBvZiBPYnNlcnZlcnMgYXR0YWNoZWQgdmlhIGEgc3Vic2NyaWJlXHJcbiAqIGZ1bmN0aW9uLlxyXG4gKi9cclxuY2xhc3MgT2JzZXJ2ZXJQcm94eSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBleGVjdXRvciBGdW5jdGlvbiB3aGljaCBjYW4gbWFrZSBjYWxscyB0byBhIHNpbmdsZSBPYnNlcnZlclxyXG4gICAgICogICAgIGFzIGEgcHJveHkuXHJcbiAgICAgKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGV4ZWN1dG9yLCBvbk5vT2JzZXJ2ZXJzKSB7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJDb3VudCA9IDA7XHJcbiAgICAgICAgLy8gTWljcm8tdGFzayBzY2hlZHVsaW5nIGJ5IGNhbGxpbmcgdGFzay50aGVuKCkuXHJcbiAgICAgICAgdGhpcy50YXNrID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnMgPSBvbk5vT2JzZXJ2ZXJzO1xyXG4gICAgICAgIC8vIENhbGwgdGhlIGV4ZWN1dG9yIGFzeW5jaHJvbm91c2x5IHNvIHN1YnNjcmliZXJzIHRoYXQgYXJlIGNhbGxlZFxyXG4gICAgICAgIC8vIHN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIGNyZWF0aW9uIG9mIHRoZSBzdWJzY3JpYmUgZnVuY3Rpb25cclxuICAgICAgICAvLyBjYW4gc3RpbGwgcmVjZWl2ZSB0aGUgdmVyeSBmaXJzdCB2YWx1ZSBnZW5lcmF0ZWQgaW4gdGhlIGV4ZWN1dG9yLlxyXG4gICAgICAgIHRoaXMudGFza1xyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGV4ZWN1dG9yKHRoaXMpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG5leHQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlcnJvcihlcnJvcikge1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcikgPT4ge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jbG9zZShlcnJvcik7XHJcbiAgICB9XHJcbiAgICBjb21wbGV0ZSgpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBhbiBPYnNlcnZlciB0byB0aGUgZmFuLW91dCBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIC0gV2UgcmVxdWlyZSB0aGF0IG5vIGV2ZW50IGlzIHNlbnQgdG8gYSBzdWJzY3JpYmVyIHN5Y2hyb25vdXNseSB0byB0aGVpclxyXG4gICAgICogICBjYWxsIHRvIHN1YnNjcmliZSgpLlxyXG4gICAgICovXHJcbiAgICBzdWJzY3JpYmUobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xyXG4gICAgICAgIGxldCBvYnNlcnZlcjtcclxuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgPT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICBlcnJvciA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIGNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIE9ic2VydmVyLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBc3NlbWJsZSBhbiBPYnNlcnZlciBvYmplY3Qgd2hlbiBwYXNzZWQgYXMgY2FsbGJhY2sgZnVuY3Rpb25zLlxyXG4gICAgICAgIGlmIChpbXBsZW1lbnRzQW55TWV0aG9kcyhuZXh0T3JPYnNlcnZlciwgW1xyXG4gICAgICAgICAgICAnbmV4dCcsXHJcbiAgICAgICAgICAgICdlcnJvcicsXHJcbiAgICAgICAgICAgICdjb21wbGV0ZSdcclxuICAgICAgICBdKSkge1xyXG4gICAgICAgICAgICBvYnNlcnZlciA9IG5leHRPck9ic2VydmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIgPSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0OiBuZXh0T3JPYnNlcnZlcixcclxuICAgICAgICAgICAgICAgIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgY29tcGxldGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9ic2VydmVyLm5leHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0ID0gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9ic2VydmVyLmVycm9yID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IgPSBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JzZXJ2ZXIuY29tcGxldGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSA9IG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVuc3ViID0gdGhpcy51bnN1YnNjcmliZU9uZS5iaW5kKHRoaXMsIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCk7XHJcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBzdWJzY3JpYmUgdG8gYSB0ZXJtaW5hdGVkIE9ic2VydmFibGUgLSB3ZVxyXG4gICAgICAgIC8vIGp1c3QgcmVzcG9uZCB0byB0aGUgT2JzZXJ2ZXIgd2l0aCB0aGUgZmluYWwgZXJyb3Igb3IgY29tcGxldGVcclxuICAgICAgICAvLyBldmVudC5cclxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IodGhpcy5maW5hbEVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICByZXR1cm4gdW5zdWI7XHJcbiAgICB9XHJcbiAgICAvLyBVbnN1YnNjcmliZSBpcyBzeW5jaHJvbm91cyAtIHdlIGd1YXJhbnRlZSB0aGF0IG5vIGV2ZW50cyBhcmUgc2VudCB0b1xyXG4gICAgLy8gYW55IHVuc3Vic2NyaWJlZCBPYnNlcnZlci5cclxuICAgIHVuc3Vic2NyaWJlT25lKGkpIHtcclxuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcnMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9ic2VydmVyc1tpXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHRoaXMub2JzZXJ2ZXJzW2ldO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJDb3VudCAtPSAxO1xyXG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyQ291bnQgPT09IDAgJiYgdGhpcy5vbk5vT2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvckVhY2hPYnNlcnZlcihmbikge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xyXG4gICAgICAgICAgICAvLyBBbHJlYWR5IGNsb3NlZCBieSBwcmV2aW91cyBldmVudC4uLi5qdXN0IGVhdCB0aGUgYWRkaXRpb25hbCB2YWx1ZXMuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2luY2Ugc2VuZE9uZSBjYWxscyBhc3luY2hyb25vdXNseSAtIHRoZXJlIGlzIG5vIGNoYW5jZSB0aGF0XHJcbiAgICAgICAgLy8gdGhpcy5vYnNlcnZlcnMgd2lsbCBiZWNvbWUgdW5kZWZpbmVkLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kT25lKGksIGZuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDYWxsIHRoZSBPYnNlcnZlciB2aWEgb25lIG9mIGl0J3MgY2FsbGJhY2sgZnVuY3Rpb24uIFdlIGFyZSBjYXJlZnVsIHRvXHJcbiAgICAvLyBjb25maXJtIHRoYXQgdGhlIG9ic2VydmUgaGFzIG5vdCBiZWVuIHVuc3Vic2NyaWJlZCBzaW5jZSB0aGlzIGFzeW5jaHJvbm91c1xyXG4gICAgLy8gZnVuY3Rpb24gaGFkIGJlZW4gcXVldWVkLlxyXG4gICAgc2VuZE9uZShpLCBmbikge1xyXG4gICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIGFzeW5jaHJvbm91c2x5XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vYnNlcnZlcnNbaV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBmbih0aGlzLm9ic2VydmVyc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBleGNlcHRpb25zIHJhaXNlZCBpbiBPYnNlcnZlcnMgb3IgbWlzc2luZyBtZXRob2RzIG9mIGFuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT2JzZXJ2ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9nIGVycm9yIHRvIGNvbnNvbGUuIGIvMzE0MDQ4MDZcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNsb3NlKGVycikge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5maW5hbEVycm9yID0gZXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcm94eSBpcyBubyBsb25nZXIgbmVlZGVkIC0gZ2FyYmFnZSBjb2xsZWN0IHJlZmVyZW5jZXNcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKiBUdXJuIHN5bmNocm9ub3VzIGZ1bmN0aW9uIGludG8gb25lIGNhbGxlZCBhc3luY2hyb25vdXNseS4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcclxuZnVuY3Rpb24gYXN5bmMoZm4sIG9uRXJyb3IpIHtcclxuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh0cnVlKVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGZuKC4uLmFyZ3MpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgb2JqZWN0IHBhc3NlZCBpbiBpbXBsZW1lbnRzIGFueSBvZiB0aGUgbmFtZWQgbWV0aG9kcy5cclxuICovXHJcbmZ1bmN0aW9uIGltcGxlbWVudHNBbnlNZXRob2RzKG9iaiwgbWV0aG9kcykge1xyXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcclxuICAgICAgICBpZiAobWV0aG9kIGluIG9iaiAmJiB0eXBlb2Ygb2JqW21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIG5vb3AoKSB7XHJcbiAgICAvLyBkbyBub3RoaW5nXHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgZm9yIGEgcHVibGljIGZ1bmN0aW9uLlxyXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZmFpbHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWVcclxuICogQHBhcmFtIG1pbkNvdW50IFRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXHJcbiAqIEBwYXJhbSBtYXhDb3VudCBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnQgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXHJcbiAqIEBwYXJhbSBhcmdDb3VudCBUaGUgYWN0dWFsIG51bWJlciBvZiBhcmd1bWVudHMgcHJvdmlkZWQuXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUFyZ0NvdW50ID0gZnVuY3Rpb24gKGZuTmFtZSwgbWluQ291bnQsIG1heENvdW50LCBhcmdDb3VudCkge1xyXG4gICAgbGV0IGFyZ0Vycm9yO1xyXG4gICAgaWYgKGFyZ0NvdW50IDwgbWluQ291bnQpIHtcclxuICAgICAgICBhcmdFcnJvciA9ICdhdCBsZWFzdCAnICsgbWluQ291bnQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhcmdDb3VudCA+IG1heENvdW50KSB7XHJcbiAgICAgICAgYXJnRXJyb3IgPSBtYXhDb3VudCA9PT0gMCA/ICdub25lJyA6ICdubyBtb3JlIHRoYW4gJyArIG1heENvdW50O1xyXG4gICAgfVxyXG4gICAgaWYgKGFyZ0Vycm9yKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBmbk5hbWUgK1xyXG4gICAgICAgICAgICAnIGZhaWxlZDogV2FzIGNhbGxlZCB3aXRoICcgK1xyXG4gICAgICAgICAgICBhcmdDb3VudCArXHJcbiAgICAgICAgICAgIChhcmdDb3VudCA9PT0gMSA/ICcgYXJndW1lbnQuJyA6ICcgYXJndW1lbnRzLicpICtcclxuICAgICAgICAgICAgJyBFeHBlY3RzICcgK1xyXG4gICAgICAgICAgICBhcmdFcnJvciArXHJcbiAgICAgICAgICAgICcuJztcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogR2VuZXJhdGVzIGEgc3RyaW5nIHRvIHByZWZpeCBhbiBlcnJvciBtZXNzYWdlIGFib3V0IGZhaWxlZCBhcmd1bWVudCB2YWxpZGF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWVcclxuICogQHBhcmFtIGFyZ05hbWUgVGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50XHJcbiAqIEByZXR1cm4gVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIGVycm9yIHRocm93biBmb3IgdmFsaWRhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGVycm9yUHJlZml4KGZuTmFtZSwgYXJnTmFtZSkge1xyXG4gICAgcmV0dXJuIGAke2ZuTmFtZX0gZmFpbGVkOiAke2FyZ05hbWV9IGFyZ3VtZW50IGA7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBmbk5hbWVcclxuICogQHBhcmFtIGFyZ3VtZW50TnVtYmVyXHJcbiAqIEBwYXJhbSBuYW1lc3BhY2VcclxuICogQHBhcmFtIG9wdGlvbmFsXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWVzcGFjZShmbk5hbWUsIG5hbWVzcGFjZSwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiAhbmFtZXNwYWNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy9UT0RPOiBJIHNob3VsZCBkbyBtb3JlIHZhbGlkYXRpb24gaGVyZS4gV2Ugb25seSBhbGxvdyBjZXJ0YWluIGNoYXJzIGluIG5hbWVzcGFjZXMuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgJ25hbWVzcGFjZScpICsgJ211c3QgYmUgYSB2YWxpZCBmaXJlYmFzZSBuYW1lc3BhY2UuJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVDYWxsYmFjayhmbk5hbWUsIGFyZ3VtZW50TmFtZSwgXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXHJcbmNhbGxiYWNrLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmICFjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBmdW5jdGlvbi4nKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbnRleHRPYmplY3QoZm5OYW1lLCBhcmd1bWVudE5hbWUsIGNvbnRleHQsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgIWNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnIHx8IGNvbnRleHQgPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBjb250ZXh0IG9iamVjdC4nKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBDb2RlIG9yaWdpbmFsbHkgY2FtZSBmcm9tIGdvb2cuY3J5cHQuc3RyaW5nVG9VdGY4Qnl0ZUFycmF5LCBidXQgZm9yIHNvbWUgcmVhc29uIHRoZXlcclxuLy8gYXV0b21hdGljYWxseSByZXBsYWNlZCAnXFxyXFxuJyB3aXRoICdcXG4nLCBhbmQgdGhleSBkaWRuJ3QgaGFuZGxlIHN1cnJvZ2F0ZSBwYWlycyxcclxuLy8gc28gaXQncyBiZWVuIG1vZGlmaWVkLlxyXG4vLyBOb3RlIHRoYXQgbm90IGFsbCBVbmljb2RlIGNoYXJhY3RlcnMgYXBwZWFyIGFzIHNpbmdsZSBjaGFyYWN0ZXJzIGluIEphdmFTY3JpcHQgc3RyaW5ncy5cclxuLy8gZnJvbUNoYXJDb2RlIHJldHVybnMgdGhlIFVURi0xNiBlbmNvZGluZyBvZiBhIGNoYXJhY3RlciAtIHNvIHNvbWUgVW5pY29kZSBjaGFyYWN0ZXJzXHJcbi8vIHVzZSAyIGNoYXJhY3RlcnMgaW4gSmF2YXNjcmlwdC4gIEFsbCA0LWJ5dGUgVVRGLTggY2hhcmFjdGVycyBiZWdpbiB3aXRoIGEgZmlyc3RcclxuLy8gY2hhcmFjdGVyIGluIHRoZSByYW5nZSAweEQ4MDAgLSAweERCRkYgKHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzby1jYWxsZWQgc3Vycm9nYXRlXHJcbi8vIHBhaXIpLlxyXG4vLyBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTE1LjEuM1xyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5ID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICBsZXQgcCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgLy8gSXMgdGhpcyB0aGUgbGVhZCBzdXJyb2dhdGUgaW4gYSBzdXJyb2dhdGUgcGFpcj9cclxuICAgICAgICBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRiZmYpIHtcclxuICAgICAgICAgICAgY29uc3QgaGlnaCA9IGMgLSAweGQ4MDA7IC8vIHRoZSBoaWdoIDEwIGJpdHMuXHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgYXNzZXJ0KGkgPCBzdHIubGVuZ3RoLCAnU3Vycm9nYXRlIHBhaXIgbWlzc2luZyB0cmFpbCBzdXJyb2dhdGUuJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvdyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gMHhkYzAwOyAvLyB0aGUgbG93IDEwIGJpdHMuXHJcbiAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKGhpZ2ggPDwgMTApICsgbG93O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYyA8IDEyOCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCA2NTUzNikge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG4vKipcclxuICogQ2FsY3VsYXRlIGxlbmd0aCB3aXRob3V0IGFjdHVhbGx5IGNvbnZlcnRpbmc7IHVzZWZ1bCBmb3IgZG9pbmcgY2hlYXBlciB2YWxpZGF0aW9uLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICovXHJcbmNvbnN0IHN0cmluZ0xlbmd0aCA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGxldCBwID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIHArKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcclxuICAgICAgICAgICAgcCArPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjID49IDB4ZDgwMCAmJiBjIDw9IDB4ZGJmZikge1xyXG4gICAgICAgICAgICAvLyBMZWFkIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLiAgVGhlIHBhaXIgdG9nZXRoZXIgd2lsbCB0YWtlIDQgYnl0ZXMgdG8gcmVwcmVzZW50LlxyXG4gICAgICAgICAgICBwICs9IDQ7XHJcbiAgICAgICAgICAgIGkrKzsgLy8gc2tpcCB0cmFpbCBzdXJyb2dhdGUuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwICs9IDM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHA7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDb3BpZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjExNzUyM1xyXG4gKiBHZW5lcmF0ZXMgYSBuZXcgdXVpZC5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgdXVpZHY0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgYyA9PiB7XHJcbiAgICAgICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCwgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDg7XHJcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xyXG4gICAgfSk7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgYW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBleHBvbmVudGlhbGx5IGluY3JlYXNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9JTlRFUlZBTF9NSUxMSVMgPSAxMDAwO1xyXG4vKipcclxuICogVGhlIGZhY3RvciB0byBiYWNrb2ZmIGJ5LlxyXG4gKiBTaG91bGQgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDEuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SID0gMjtcclxuLyoqXHJcbiAqIFRoZSBtYXhpbXVtIG1pbGxpc2Vjb25kcyB0byBpbmNyZWFzZSB0by5cclxuICpcclxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZ1xyXG4gKi9cclxuY29uc3QgTUFYX1ZBTFVFX01JTExJUyA9IDQgKiA2MCAqIDYwICogMTAwMDsgLy8gRm91ciBob3VycywgbGlrZSBpT1MgYW5kIEFuZHJvaWQuXHJcbi8qKlxyXG4gKiBUaGUgcGVyY2VudGFnZSBvZiBiYWNrb2ZmIHRpbWUgdG8gcmFuZG9taXplIGJ5LlxyXG4gKiBTZWVcclxuICogaHR0cDovL2dvL3NhZmUtY2xpZW50LWJlaGF2aW9yI3N0ZXAtMS1kZXRlcm1pbmUtdGhlLWFwcHJvcHJpYXRlLXJldHJ5LWludGVydmFsLXRvLWhhbmRsZS1zcGlrZS10cmFmZmljXHJcbiAqIGZvciBjb250ZXh0LlxyXG4gKlxyXG4gKiA8cD5WaXNpYmxlIGZvciB0ZXN0aW5nXHJcbiAqL1xyXG5jb25zdCBSQU5ET01fRkFDVE9SID0gMC41O1xyXG4vKipcclxuICogQmFzZWQgb24gdGhlIGJhY2tvZmYgbWV0aG9kIGZyb21cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvY2xvc3VyZS9nb29nL21hdGgvZXhwb25lbnRpYWxiYWNrb2ZmLmpzLlxyXG4gKiBFeHRyYWN0ZWQgaGVyZSBzbyB3ZSBkb24ndCBuZWVkIHRvIHBhc3MgbWV0YWRhdGEgYW5kIGEgc3RhdGVmdWwgRXhwb25lbnRpYWxCYWNrb2ZmIG9iamVjdCBhcm91bmQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzKGJhY2tvZmZDb3VudCwgaW50ZXJ2YWxNaWxsaXMgPSBERUZBVUxUX0lOVEVSVkFMX01JTExJUywgYmFja29mZkZhY3RvciA9IERFRkFVTFRfQkFDS09GRl9GQUNUT1IpIHtcclxuICAgIC8vIENhbGN1bGF0ZXMgYW4gZXhwb25lbnRpYWxseSBpbmNyZWFzaW5nIHZhbHVlLlxyXG4gICAgLy8gRGV2aWF0aW9uOiBjYWxjdWxhdGVzIHZhbHVlIGZyb20gY291bnQgYW5kIGEgY29uc3RhbnQgaW50ZXJ2YWwsIHNvIHdlIG9ubHkgbmVlZCB0byBzYXZlIHZhbHVlXHJcbiAgICAvLyBhbmQgY291bnQgdG8gcmVzdG9yZSBzdGF0ZS5cclxuICAgIGNvbnN0IGN1cnJCYXNlVmFsdWUgPSBpbnRlcnZhbE1pbGxpcyAqIE1hdGgucG93KGJhY2tvZmZGYWN0b3IsIGJhY2tvZmZDb3VudCk7XHJcbiAgICAvLyBBIHJhbmRvbSBcImZ1enpcIiB0byBhdm9pZCB3YXZlcyBvZiByZXRyaWVzLlxyXG4gICAgLy8gRGV2aWF0aW9uOiByYW5kb21GYWN0b3IgaXMgcmVxdWlyZWQuXHJcbiAgICBjb25zdCByYW5kb21XYWl0ID0gTWF0aC5yb3VuZChcclxuICAgIC8vIEEgZnJhY3Rpb24gb2YgdGhlIGJhY2tvZmYgdmFsdWUgdG8gYWRkL3N1YnRyYWN0LlxyXG4gICAgLy8gRGV2aWF0aW9uOiBjaGFuZ2VzIG11bHRpcGxpY2F0aW9uIG9yZGVyIHRvIGltcHJvdmUgcmVhZGFiaWxpdHkuXHJcbiAgICBSQU5ET01fRkFDVE9SICpcclxuICAgICAgICBjdXJyQmFzZVZhbHVlICpcclxuICAgICAgICAvLyBBIHJhbmRvbSBmbG9hdCAocm91bmRlZCB0byBpbnQgYnkgTWF0aC5yb3VuZCBhYm92ZSkgaW4gdGhlIHJhbmdlIFstMSwgMV0uIERldGVybWluZXNcclxuICAgICAgICAvLyBpZiB3ZSBhZGQgb3Igc3VidHJhY3QuXHJcbiAgICAgICAgKE1hdGgucmFuZG9tKCkgLSAwLjUpICpcclxuICAgICAgICAyKTtcclxuICAgIC8vIExpbWl0cyBiYWNrb2ZmIHRvIG1heCB0byBhdm9pZCBlZmZlY3RpdmVseSBwZXJtYW5lbnQgYmFja29mZi5cclxuICAgIHJldHVybiBNYXRoLm1pbihNQVhfVkFMVUVfTUlMTElTLCBjdXJyQmFzZVZhbHVlICsgcmFuZG9tV2FpdCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGUgRW5nbGlzaCBvcmRpbmFsIGxldHRlcnMgYWZ0ZXIgYSBudW1iZXJcclxuICovXHJcbmZ1bmN0aW9uIG9yZGluYWwoaSkge1xyXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaSkpIHtcclxuICAgICAgICByZXR1cm4gYCR7aX1gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGkgKyBpbmRpY2F0b3IoaSk7XHJcbn1cclxuZnVuY3Rpb24gaW5kaWNhdG9yKGkpIHtcclxuICAgIGkgPSBNYXRoLmFicyhpKTtcclxuICAgIGNvbnN0IGNlbnQgPSBpICUgMTAwO1xyXG4gICAgaWYgKGNlbnQgPj0gMTAgJiYgY2VudCA8PSAyMCkge1xyXG4gICAgICAgIHJldHVybiAndGgnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVjID0gaSAlIDEwO1xyXG4gICAgaWYgKGRlYyA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiAnc3QnO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlYyA9PT0gMikge1xyXG4gICAgICAgIHJldHVybiAnbmQnO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlYyA9PT0gMykge1xyXG4gICAgICAgIHJldHVybiAncmQnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICd0aCc7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TW9kdWxhckluc3RhbmNlKHNlcnZpY2UpIHtcclxuICAgIGlmIChzZXJ2aWNlICYmIHNlcnZpY2UuX2RlbGVnYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcnZpY2UuX2RlbGVnYXRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcnZpY2U7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gT3ZlcnJpZGluZyB0aGUgY29uc3RhbnQgKHdlIHNob3VsZCBiZSB0aGUgb25seSBvbmVzIGRvaW5nIHRoaXMpXHJcbkNPTlNUQU5UUy5OT0RFX0NMSUVOVCA9IHRydWU7XG5cbmV4cG9ydCB7IENPTlNUQU5UUywgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IsIERlZmVycmVkLCBFcnJvckZhY3RvcnksIEZpcmViYXNlRXJyb3IsIE1BWF9WQUxVRV9NSUxMSVMsIFJBTkRPTV9GQUNUT1IsIFNoYTEsIGFyZUNvb2tpZXNFbmFibGVkLCBhc3NlcnQsIGFzc2VydGlvbkVycm9yLCBhc3luYywgYmFzZTY0LCBiYXNlNjREZWNvZGUsIGJhc2U2NEVuY29kZSwgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcsIGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMsIGNvbnRhaW5zLCBjcmVhdGVNb2NrVXNlclRva2VuLCBjcmVhdGVTdWJzY3JpYmUsIGRlY29kZSwgZGVlcENvcHksIGRlZXBFcXVhbCwgZGVlcEV4dGVuZCwgZXJyb3JQcmVmaXgsIGV4dHJhY3RRdWVyeXN0cmluZywgZ2V0RGVmYXVsdEFwcENvbmZpZywgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCwgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0LCBnZXREZWZhdWx0cywgZ2V0RXhwZXJpbWVudGFsU2V0dGluZywgZ2V0R2xvYmFsLCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldFVBLCBpc0FkbWluLCBpc0Jyb3dzZXIsIGlzQnJvd3NlckV4dGVuc2lvbiwgaXNFbGVjdHJvbiwgaXNFbXB0eSwgaXNJRSwgaXNJbmRleGVkREJBdmFpbGFibGUsIGlzTW9iaWxlQ29yZG92YSwgaXNOb2RlLCBpc05vZGVTZGssIGlzUmVhY3ROYXRpdmUsIGlzU2FmYXJpLCBpc1VXUCwgaXNWYWxpZEZvcm1hdCwgaXNWYWxpZFRpbWVzdGFtcCwgaXNzdWVkQXRUaW1lLCBqc29uRXZhbCwgbWFwLCBvcmRpbmFsLCBwcm9taXNlV2l0aFRpbWVvdXQsIHF1ZXJ5c3RyaW5nLCBxdWVyeXN0cmluZ0RlY29kZSwgc2FmZUdldCwgc3RyaW5nTGVuZ3RoLCBzdHJpbmdUb0J5dGVBcnJheSwgc3RyaW5naWZ5LCB1dWlkdjQsIHZhbGlkYXRlQXJnQ291bnQsIHZhbGlkYXRlQ2FsbGJhY2ssIHZhbGlkYXRlQ29udGV4dE9iamVjdCwgdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSwgdmFsaWRhdGVOYW1lc3BhY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkNPTlNUQU5UUyIsIk5PREVfQ0xJRU5UIiwiTk9ERV9BRE1JTiIsIlNES19WRVJTSU9OIiwiYXNzZXJ0IiwiYXNzZXJ0aW9uIiwibWVzc2FnZSIsImFzc2VydGlvbkVycm9yIiwiRXJyb3IiLCJzdHJpbmdUb0J5dGVBcnJheSQxIiwic3RyIiwib3V0IiwicCIsImkiLCJsZW5ndGgiLCJjIiwiY2hhckNvZGVBdCIsImJ5dGVBcnJheVRvU3RyaW5nIiwiYnl0ZXMiLCJwb3MiLCJjMSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImMyIiwiYzMiLCJjNCIsInUiLCJqb2luIiwiYmFzZTY0IiwiYnl0ZVRvQ2hhck1hcF8iLCJjaGFyVG9CeXRlTWFwXyIsImJ5dGVUb0NoYXJNYXBXZWJTYWZlXyIsImNoYXJUb0J5dGVNYXBXZWJTYWZlXyIsIkVOQ09ERURfVkFMU19CQVNFIiwiRU5DT0RFRF9WQUxTIiwiRU5DT0RFRF9WQUxTX1dFQlNBRkUiLCJIQVNfTkFUSVZFX1NVUFBPUlQiLCJhdG9iIiwiZW5jb2RlQnl0ZUFycmF5IiwiaW5wdXQiLCJ3ZWJTYWZlIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5pdF8iLCJieXRlVG9DaGFyTWFwIiwib3V0cHV0IiwiYnl0ZTEiLCJoYXZlQnl0ZTIiLCJieXRlMiIsImhhdmVCeXRlMyIsImJ5dGUzIiwib3V0Qnl0ZTEiLCJvdXRCeXRlMiIsIm91dEJ5dGUzIiwib3V0Qnl0ZTQiLCJwdXNoIiwiZW5jb2RlU3RyaW5nIiwiYnRvYSIsImRlY29kZVN0cmluZyIsImRlY29kZVN0cmluZ1RvQnl0ZUFycmF5IiwiY2hhclRvQnl0ZU1hcCIsImNoYXJBdCIsImhhdmVCeXRlNCIsImJ5dGU0IiwiRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IiLCJjb25zdHJ1Y3RvciIsImFyZ3VtZW50cyIsIm5hbWUiLCJiYXNlNjRFbmNvZGUiLCJ1dGY4Qnl0ZXMiLCJiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyIsInJlcGxhY2UiLCJiYXNlNjREZWNvZGUiLCJlIiwiY29uc29sZSIsImVycm9yIiwiZGVlcENvcHkiLCJ2YWx1ZSIsImRlZXBFeHRlbmQiLCJ1bmRlZmluZWQiLCJ0YXJnZXQiLCJzb3VyY2UiLCJPYmplY3QiLCJEYXRlIiwiZGF0ZVZhbHVlIiwiZ2V0VGltZSIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsImlzVmFsaWRLZXkiLCJrZXkiLCJnZXRHbG9iYWwiLCJzZWxmIiwid2luZG93IiwiZ2xvYmFsIiwiZ2V0RGVmYXVsdHNGcm9tR2xvYmFsIiwiX19GSVJFQkFTRV9ERUZBVUxUU19fIiwiZ2V0RGVmYXVsdHNGcm9tRW52VmFyaWFibGUiLCJwcm9jZXNzIiwiZW52IiwiZGVmYXVsdHNKc29uU3RyaW5nIiwiSlNPTiIsInBhcnNlIiwiZ2V0RGVmYXVsdHNGcm9tQ29va2llIiwiZG9jdW1lbnQiLCJtYXRjaCIsImNvb2tpZSIsImRlY29kZWQiLCJnZXREZWZhdWx0cyIsImluZm8iLCJnZXREZWZhdWx0RW11bGF0b3JIb3N0IiwicHJvZHVjdE5hbWUiLCJfYSIsIl9iIiwiZW11bGF0b3JIb3N0cyIsImdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCIsImhvc3QiLCJzZXBhcmF0b3JJbmRleCIsImxhc3RJbmRleE9mIiwicG9ydCIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiZ2V0RGVmYXVsdEFwcENvbmZpZyIsImNvbmZpZyIsImdldEV4cGVyaW1lbnRhbFNldHRpbmciLCJEZWZlcnJlZCIsInJlamVjdCIsInJlc29sdmUiLCJwcm9taXNlIiwiUHJvbWlzZSIsIndyYXBDYWxsYmFjayIsImNhbGxiYWNrIiwiY2F0Y2giLCJjcmVhdGVNb2NrVXNlclRva2VuIiwidG9rZW4iLCJwcm9qZWN0SWQiLCJ1aWQiLCJoZWFkZXIiLCJhbGciLCJ0eXBlIiwicHJvamVjdCIsImlhdCIsInN1YiIsInVzZXJfaWQiLCJwYXlsb2FkIiwiYXNzaWduIiwiaXNzIiwiYXVkIiwiZXhwIiwiYXV0aF90aW1lIiwiZmlyZWJhc2UiLCJzaWduX2luX3Byb3ZpZGVyIiwiaWRlbnRpdGllcyIsInNpZ25hdHVyZSIsInN0cmluZ2lmeSIsImdldFVBIiwibmF2aWdhdG9yIiwiaXNNb2JpbGVDb3Jkb3ZhIiwidGVzdCIsImlzTm9kZSIsImZvcmNlRW52aXJvbm1lbnQiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc0Jyb3dzZXIiLCJpc0Jyb3dzZXJFeHRlbnNpb24iLCJydW50aW1lIiwiY2hyb21lIiwiYnJvd3NlciIsImlkIiwiaXNSZWFjdE5hdGl2ZSIsImlzRWxlY3Ryb24iLCJpbmRleE9mIiwiaXNJRSIsInVhIiwiaXNVV1AiLCJpc05vZGVTZGsiLCJpc1NhZmFyaSIsInVzZXJBZ2VudCIsImluY2x1ZGVzIiwiaXNJbmRleGVkREJBdmFpbGFibGUiLCJpbmRleGVkREIiLCJ2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlIiwicHJlRXhpc3QiLCJEQl9DSEVDS19OQU1FIiwicmVxdWVzdCIsIm9wZW4iLCJvbnN1Y2Nlc3MiLCJyZXN1bHQiLCJjbG9zZSIsImRlbGV0ZURhdGFiYXNlIiwib251cGdyYWRlbmVlZGVkIiwib25lcnJvciIsImFyZUNvb2tpZXNFbmFibGVkIiwiY29va2llRW5hYmxlZCIsIkVSUk9SX05BTUUiLCJGaXJlYmFzZUVycm9yIiwiY29kZSIsImN1c3RvbURhdGEiLCJzZXRQcm90b3R5cGVPZiIsImNhcHR1cmVTdGFja1RyYWNlIiwiRXJyb3JGYWN0b3J5IiwiY3JlYXRlIiwic2VydmljZSIsInNlcnZpY2VOYW1lIiwiZXJyb3JzIiwiZGF0YSIsImZ1bGxDb2RlIiwidGVtcGxhdGUiLCJyZXBsYWNlVGVtcGxhdGUiLCJmdWxsTWVzc2FnZSIsIlBBVFRFUk4iLCJfIiwianNvbkV2YWwiLCJkZWNvZGUiLCJjbGFpbXMiLCJwYXJ0cyIsInNwbGl0IiwiaXNWYWxpZFRpbWVzdGFtcCIsIm5vdyIsIk1hdGgiLCJmbG9vciIsInZhbGlkU2luY2UiLCJ2YWxpZFVudGlsIiwiaXNzdWVkQXRUaW1lIiwiaXNWYWxpZEZvcm1hdCIsImlzQWRtaW4iLCJjb250YWlucyIsIm9iaiIsInNhZmVHZXQiLCJpc0VtcHR5IiwibWFwIiwiZm4iLCJjb250ZXh0T2JqIiwicmVzIiwiZGVlcEVxdWFsIiwiYSIsImIiLCJhS2V5cyIsImtleXMiLCJiS2V5cyIsImsiLCJhUHJvcCIsImJQcm9wIiwiaXNPYmplY3QiLCJ0aGluZyIsInByb21pc2VXaXRoVGltZW91dCIsInRpbWVJbk1TIiwiZGVmZXJyZWRQcm9taXNlIiwic2V0VGltZW91dCIsInRoZW4iLCJxdWVyeXN0cmluZyIsInF1ZXJ5c3RyaW5nUGFyYW1zIiwicGFyYW1zIiwiZW50cmllcyIsImZvckVhY2giLCJhcnJheVZhbCIsImVuY29kZVVSSUNvbXBvbmVudCIsInF1ZXJ5c3RyaW5nRGVjb2RlIiwidG9rZW5zIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXh0cmFjdFF1ZXJ5c3RyaW5nIiwidXJsIiwicXVlcnlTdGFydCIsImZyYWdtZW50U3RhcnQiLCJTaGExIiwiY2hhaW5fIiwiYnVmXyIsIldfIiwicGFkXyIsImluYnVmXyIsInRvdGFsXyIsImJsb2NrU2l6ZSIsInJlc2V0IiwiY29tcHJlc3NfIiwiYnVmIiwib2Zmc2V0IiwiVyIsInQiLCJkIiwiZiIsInVwZGF0ZSIsImxlbmd0aE1pbnVzQmxvY2siLCJuIiwiaW5idWYiLCJkaWdlc3QiLCJ0b3RhbEJpdHMiLCJqIiwiY3JlYXRlU3Vic2NyaWJlIiwiZXhlY3V0b3IiLCJvbk5vT2JzZXJ2ZXJzIiwicHJveHkiLCJPYnNlcnZlclByb3h5Iiwic3Vic2NyaWJlIiwiYmluZCIsIm9ic2VydmVycyIsInVuc3Vic2NyaWJlcyIsIm9ic2VydmVyQ291bnQiLCJ0YXNrIiwiZmluYWxpemVkIiwibmV4dCIsImZvckVhY2hPYnNlcnZlciIsIm9ic2VydmVyIiwiY29tcGxldGUiLCJuZXh0T3JPYnNlcnZlciIsImltcGxlbWVudHNBbnlNZXRob2RzIiwibm9vcCIsInVuc3ViIiwidW5zdWJzY3JpYmVPbmUiLCJmaW5hbEVycm9yIiwic2VuZE9uZSIsImVyciIsImFzeW5jIiwib25FcnJvciIsImFyZ3MiLCJtZXRob2RzIiwibWV0aG9kIiwidmFsaWRhdGVBcmdDb3VudCIsImZuTmFtZSIsIm1pbkNvdW50IiwibWF4Q291bnQiLCJhcmdDb3VudCIsImFyZ0Vycm9yIiwiZXJyb3JQcmVmaXgiLCJhcmdOYW1lIiwidmFsaWRhdGVOYW1lc3BhY2UiLCJuYW1lc3BhY2UiLCJvcHRpb25hbCIsInZhbGlkYXRlQ2FsbGJhY2siLCJhcmd1bWVudE5hbWUiLCJ2YWxpZGF0ZUNvbnRleHRPYmplY3QiLCJjb250ZXh0Iiwic3RyaW5nVG9CeXRlQXJyYXkiLCJoaWdoIiwibG93Iiwic3RyaW5nTGVuZ3RoIiwidXVpZHY0IiwiciIsInJhbmRvbSIsInYiLCJERUZBVUxUX0lOVEVSVkFMX01JTExJUyIsIkRFRkFVTFRfQkFDS09GRl9GQUNUT1IiLCJNQVhfVkFMVUVfTUlMTElTIiwiUkFORE9NX0ZBQ1RPUiIsImNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMiLCJiYWNrb2ZmQ291bnQiLCJpbnRlcnZhbE1pbGxpcyIsImJhY2tvZmZGYWN0b3IiLCJjdXJyQmFzZVZhbHVlIiwicG93IiwicmFuZG9tV2FpdCIsInJvdW5kIiwibWluIiwib3JkaW5hbCIsIk51bWJlciIsImlzRmluaXRlIiwiaW5kaWNhdG9yIiwiYWJzIiwiY2VudCIsImRlYyIsImdldE1vZHVsYXJJbnN0YW5jZSIsIl9kZWxlZ2F0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\n");

/***/ })

};
;